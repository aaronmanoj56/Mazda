<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mazda Validator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/exceljs/4.4.0/exceljs.min.js"></script>
    <script src="https://apis.google.com/js/api.js"></script>
    <script src="https://accounts.google.com/gsi/client"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Helvetica Neue', sans-serif;
            padding-top: 70px; /* Space for fixed header */
            padding-left: 320px; /* Space for sidebar */
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            margin: 0;
            min-height: 100vh;
            line-height: 1.6;
            color: #2d2d2d;
        }

        /* Fixed Headline */
        .headline {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: linear-gradient(135deg, #250651 0%, #3d0a7a 100%);
            color: #ffffff;
            padding: 18px 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(37, 6, 81, 0.3);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .headline-logo {
            height: 50px;
            width: auto;
            object-fit: contain;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.2));
            transition: transform 0.3s ease;
        }

        .headline-logo:hover {
            transform: scale(1.05);
        }

        .headline h1 {
            font-size: 2rem;
            font-weight: 700;
            margin: 0;
            letter-spacing: -0.5px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .menu-toggle {
            display: none;
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 1001;
            background: linear-gradient(135deg, #250651 0%, #3d0a7a 100%);
            color: #ffffff;
            border: none;
            padding: 12px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1.2rem;
            box-shadow: 0 4px 12px rgba(37, 6, 81, 0.4);
            transition: all 0.3s ease;
        }

        .menu-toggle:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 16px rgba(37, 6, 81, 0.5);
        }

        /* Sidebar */
        .sidebar {
            position: fixed;
            top: 70px; /* Below headline */
            left: 0;
            width: 320px;
            height: calc(100vh - 70px);
            background: linear-gradient(180deg, #ffffff 0%, #fafafa 100%);
            box-shadow: 4px 0 16px rgba(0, 0, 0, 0.08);
            z-index: 999;
            overflow-y: auto;
            padding: 25px 0;
            border-right: 1px solid rgba(86, 18, 189, 0.1);
        }

        .sidebar::-webkit-scrollbar {
            width: 6px;
        }

        .sidebar::-webkit-scrollbar-track {
            background: #f1f1f1;
        }

        .sidebar::-webkit-scrollbar-thumb {
            background: #5612BD;
            border-radius: 3px;
        }

        .sidebar::-webkit-scrollbar-thumb:hover {
            background: #9250F2;
        }

        .sidebar-section {
            margin-bottom: 8px;
        }

        .sidebar-headline {
            padding: 14px 24px;
            font-size: 1.05rem;
            font-weight: 700;
            color: #1a1a1a;
            background: linear-gradient(90deg, #f8f9fa 0%, #ffffff 100%);
            border-left: 5px solid #5612BD;
            user-select: none;
            margin: 0 12px;
            border-radius: 8px 0 0 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.04);
        }

        .sidebar-items {
            display: block;
            overflow: visible;
        }

        .sidebar-item {
            padding: 12px 24px 12px 48px;
            color: #4a4a4a;
            text-decoration: none;
            display: block;
            transition: all 0.3s ease;
            cursor: pointer;
            font-size: 0.95rem;
            font-weight: 500;
            margin: 2px 12px;
            border-radius: 6px;
            position: relative;
        }

        .sidebar-item:hover {
            background: linear-gradient(90deg, #f3e8ff 0%, rgba(243, 232, 255, 0.5) 100%);
            color: #5612BD;
            transform: translateX(4px);
            box-shadow: 0 2px 8px rgba(86, 18, 189, 0.15);
        }

        .sidebar-item.active {
            background: linear-gradient(90deg, #f3e8ff 0%, rgba(243, 232, 255, 0.7) 100%);
            color: #5612BD;
            font-weight: 600;
            box-shadow: 0 4px 12px rgba(86, 18, 189, 0.2);
        }

        /* Main Content Area */
        .content {
            max-width: 1400px;
            margin: 0 auto;
            padding: 30px;
        }

        /* Page Sections */
        .page-section {
            display: none;
            background: linear-gradient(135deg, #ffffff 0%, #fafafa 100%);
            padding: 40px;
            border-radius: 16px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.08), 0 2px 8px rgba(0, 0, 0, 0.04);
            border: 1px solid rgba(86, 18, 189, 0.1);
            animation: fadeIn 0.4s ease;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .page-section.active {
            display: block;
        }

        /* Compare Images Page */
        .dropdowns-container {
            display: flex;
            gap: 30px;
            margin-bottom: 40px;
            flex-wrap: wrap;
            padding: 30px;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.8) 0%, rgba(250, 250, 250, 0.8) 100%);
            border-radius: 16px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.06);
            border: 1px solid rgba(86, 18, 189, 0.1);
        }

        .dropdown-group {
            flex: 1;
            min-width: 250px;
        }

        .dropdown-group label {
            display: block;
            margin-bottom: 10px;
            font-weight: 600;
            color: #2d2d2d;
            font-size: 1rem;
            letter-spacing: 0.3px;
        }

        .dropdown-group select {
            width: 100%;
            padding: 14px 16px;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            font-size: 1rem;
            background-color: #ffffff;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.04);
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%235612BD' d='M6 9L1 4h10z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 16px center;
            padding-right: 40px;
        }

        .dropdown-group select:hover {
            border-color: #5612BD;
            box-shadow: 0 4px 8px rgba(86, 18, 189, 0.1);
        }

        .dropdown-group select:focus {
            outline: none;
            border-color: #5612BD;
            box-shadow: 0 0 0 4px rgba(86, 18, 189, 0.1), 0 4px 12px rgba(86, 18, 189, 0.15);
            transform: translateY(-2px);
        }

        .input-field-group {
            margin-top: 20px;
            display: none;
        }

        .input-field-group.active {
            display: block;
        }

        .input-field-group label {
            display: block;
            margin-bottom: 10px;
            font-weight: 600;
            color: #2d2d2d;
            font-size: 0.95rem;
            letter-spacing: 0.3px;
        }

        .input-field-group input {
            width: 100%;
            padding: 14px 16px;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            font-size: 1rem;
            transition: all 0.3s ease;
            background-color: #ffffff;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.04);
        }

        .input-field-group input:hover {
            border-color: #5612BD;
            box-shadow: 0 4px 8px rgba(86, 18, 189, 0.1);
        }

        .input-field-group input:focus {
            outline: none;
            border-color: #5612BD;
            box-shadow: 0 0 0 4px rgba(86, 18, 189, 0.1), 0 4px 12px rgba(86, 18, 189, 0.15);
            transform: translateY(-2px);
        }

        .input-field-group input[type="file"] {
            padding: 8px;
            cursor: pointer;
        }

        .input-field-group input[type="file"]::file-selector-button {
            padding: 10px 20px;
            margin-right: 12px;
            border: 2px solid #5612BD;
            border-radius: 8px;
            background: linear-gradient(135deg, #5612BD 0%, #6b1dd4 100%);
            color: #ffffff;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 6px rgba(86, 18, 189, 0.3);
            letter-spacing: 0.3px;
        }

        .input-field-group input[type="file"]::file-selector-button:hover {
            background: linear-gradient(135deg, #9250F2 0%, #a866ff 100%);
            border-color: #9250F2;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(86, 18, 189, 0.4);
        }

        /* Compare Images Button */
        .compare-button-container {
            margin-top: 40px;
            text-align: center;
            padding: 20px;
        }

        .compare-button {
            padding: 16px 48px;
            background: linear-gradient(135deg, #5612BD 0%, #6b1dd4 100%);
            color: #ffffff;
            border: none;
            border-radius: 12px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 4px 12px rgba(86, 18, 189, 0.4), 0 2px 4px rgba(86, 18, 189, 0.2);
            letter-spacing: 0.5px;
            position: relative;
            overflow: hidden;
        }

        .compare-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s ease;
        }

        .compare-button:hover::before {
            left: 100%;
        }

        .compare-button:hover {
            background: linear-gradient(135deg, #9250F2 0%, #a866ff 100%);
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(86, 18, 189, 0.5), 0 4px 8px rgba(86, 18, 189, 0.3);
        }

        .compare-button:active {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(86, 18, 189, 0.4);
        }

        .compare-button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        /* Results Section */
        .results-section {
            margin-top: 40px;
            display: none;
            animation: fadeIn 0.5s ease;
        }

        .results-section.active {
            display: block;
        }

        .results-header {
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 3px solid;
            border-image: linear-gradient(90deg, #5612BD 0%, #9250F2 100%) 1;
            background: linear-gradient(135deg, rgba(86, 18, 189, 0.05) 0%, rgba(146, 80, 242, 0.05) 100%);
            padding: 20px 24px;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(86, 18, 189, 0.08);
        }

        .results-header h2 {
            font-size: 1.75rem;
            color: #250651;
            margin-bottom: 8px;
            font-weight: 700;
            letter-spacing: -0.5px;
        }

        .results-count {
            color: #5612BD;
            font-size: 1rem;
            font-weight: 500;
        }

        .images-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(600px, 1fr));
            gap: 30px;
            margin-top: 30px;
            width: 100%;
            max-width: 100%;
            box-sizing: border-box;
        }

        .image-pair {
            display: flex;
            gap: 20px;
            background: linear-gradient(135deg, #ffffff 0%, #fafafa 100%);
            padding: 24px;
            border-radius: 16px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.08), 0 2px 8px rgba(0, 0, 0, 0.04);
            border: 1px solid rgba(86, 18, 189, 0.1);
            transition: all 0.3s ease;
            align-items: center;
            box-sizing: border-box;
            width: 100%;
            max-width: 100%;
        }

        .image-pair:hover {
            box-shadow: 0 12px 32px rgba(86, 18, 189, 0.15), 0 4px 12px rgba(0, 0, 0, 0.08);
        }

        .image-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 0;
            max-width: 50%;
            box-sizing: border-box;
        }

        .image-name {
            font-weight: 600;
            color: #250651;
            margin-bottom: 12px;
            text-align: center;
            font-size: 0.95rem;
            word-break: break-word;
            padding: 8px 12px;
            background: linear-gradient(135deg, rgba(86, 18, 189, 0.1) 0%, rgba(146, 80, 242, 0.1) 100%);
            border-radius: 8px;
            letter-spacing: 0.3px;
        }

        .image-wrapper {
            border: 3px solid #e0e0e0;
            border-radius: 12px;
            overflow: hidden;
            background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
            display: inline-block;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        }

        .image-wrapper.white-image-bg {
            background: #000000 !important;
        }

        .image-wrapper:hover {
            border-color: #5612BD;
            box-shadow: 0 8px 20px rgba(86, 18, 189, 0.2);
        }

        .image-wrapper img {
            width: 100%;
            height: 100%;
            display: block;
            object-fit: contain;
        }

        .loading-message,
        .error-message,
        .no-results {
            text-align: center;
            padding: 40px;
            color: #666;
            font-size: 1.1rem;
            border-radius: 16px;
            margin-top: 20px;
            font-weight: 500;
        }

        .loading-message {
            background: linear-gradient(135deg, rgba(86, 18, 189, 0.1) 0%, rgba(146, 80, 242, 0.1) 100%);
            border: 2px dashed #5612BD;
            color: #5612BD;
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.7;
            }
        }

        .error-message {
            color: #d32f2f;
            background: linear-gradient(135deg, #ffebee 0%, #fce4ec 100%);
            border: 2px solid #f8bbd0;
            box-shadow: 0 4px 12px rgba(211, 47, 47, 0.15);
        }

        .no-results {
            color: #666;
            background: linear-gradient(135deg, #f5f5f5 0%, #e9ecef 100%);
            border: 2px solid #dee2e6;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            body {
                padding-top: 60px;
                padding-left: 0;
            }

            .headline {
                padding: 10px 15px;
                gap: 15px;
            }

            .headline-logo {
                height: 35px;
            }

            .headline h1 {
                font-size: 1.5rem;
            }

            .menu-toggle {
                display: block;
            }

            .sidebar {
                width: 100%;
                height: auto;
                max-height: 0;
                overflow: hidden;
                transition: max-height 0.3s ease;
                top: 60px;
                box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            }

            .sidebar.open {
                max-height: 500px;
            }

            .content {
                padding: 15px;
            }

            .dropdowns-container {
                flex-direction: column;
                gap: 20px;
            }

            .dropdown-group {
                min-width: 100%;
            }

            .page-section {
                padding: 20px;
            }

            .compare-button {
                padding: 12px 30px;
                font-size: 1rem;
                width: 100%;
            }

            .images-grid {
                grid-template-columns: 1fr;
                gap: 20px;
            }

            .image-pair {
                flex-direction: column;
                gap: 15px;
            }

            .image-wrapper {
                max-width: 100%;
            }
            
            .image-wrapper img {
                max-width: 100%;
            }
            
            .image-container {
                max-width: 100%;
            }
        }

        @media (max-width: 480px) {
            body {
                padding-top: 55px;
                padding-left: 0;
            }

            .headline {
                padding: 8px 12px;
                gap: 10px;
            }

            .headline-logo {
                height: 30px;
            }

            .headline h1 {
                font-size: 1.25rem;
            }

            .sidebar {
                top: 55px;
            }

            .sidebar-headline {
                font-size: 1rem;
                padding: 10px 15px;
            }

            .sidebar-item {
                padding: 8px 15px 8px 30px;
                font-size: 0.9rem;
            }
        }
    </style>
</head>
<body>
    <!-- Fixed Headline -->
    <header class="headline">
        <button class="menu-toggle" id="menu-toggle">â˜°</button>
        <img src="MAZDA-Logo_white_212x182.png" alt="Mazda Logo" class="headline-logo">
        <h1>Mazda Validator</h1>
    </header>

    <!-- Sidebar -->
    <aside class="sidebar">
        <div class="sidebar-section">
            <div class="sidebar-headline">Image Verification</div>
            <div class="sidebar-items">
                <a href="#" class="sidebar-item nav-link" data-page="image-preview">Image Preview</a>
                <a href="#" class="sidebar-item nav-link" data-page="compare-images">Compare Images</a>
            </div>
        </div>
        <div class="sidebar-section">
            <div class="sidebar-headline">DB Verification</div>
            <div class="sidebar-items">
                <a href="#" class="sidebar-item nav-link" data-page="find-blank-space">Find Blank Space</a>
                <a href="#" class="sidebar-item nav-link" data-page="http-https-verification">HTTP/HTTPS</a>
                <a href="#" class="sidebar-item nav-link" data-page="logo-color">Logo Color</a>
                <a href="#" class="sidebar-item nav-link" data-page="logo-orientation">Warranty Logo Orientation</a>
                <a href="#" class="sidebar-item nav-link" data-page="logo-language">Warranty Logo Language</a>
                <a href="#" class="sidebar-item nav-link" data-page="year-of-warranty-logo">Year of Warranty Logo</a>
                <a href="#" class="sidebar-item nav-link" data-page="rate-format">Rate Format</a>
                <a href="#" class="sidebar-item nav-link" data-page="frame-count">Frame Count</a>
            </div>
        </div>
        <div class="sidebar-section">
            <div class="sidebar-headline">Visual Verification</div>
            <div class="sidebar-items">
                <a href="#" class="sidebar-item nav-link" data-page="brand-names">Model Names</a>
                <a href="#" class="sidebar-item nav-link" data-page="rate-card">Rate Card</a>
                <a href="#" class="sidebar-item nav-link" data-page="font-size">Font Size</a>
            </div>
        </div>
    </aside>

    <!-- Main Content Area -->
    <main class="content">
        <!-- Image Preview Page -->
        <div id="image-preview" class="page-section">
            <div class="dropdowns-container">
                <div class="dropdown-group">
                    <label for="image-preview-sheet-type">Sheet Type</label>
                    <select id="image-preview-sheet-type" name="image-preview-sheet-type">
                        <option value="">Select an option</option>
                        <option value="gsheet">GSheet</option>
                        <option value="excel-csv">Excel/CSV</option>
                    </select>
                    <div id="image-preview-input" class="input-field-group">
                        <label for="image-preview-value" id="image-preview-label">Enter value</label>
                        <input type="text" id="image-preview-value" placeholder="Enter GSheet URL" accept="">
                    </div>
                </div>
            </div>
            <div class="compare-button-container">
                <button class="compare-button" id="image-preview-btn">Preview Images</button>
            </div>
            <div id="image-preview-results-section" class="results-section">
                <div class="results-header">
                    <h2>Image Preview Results</h2>
                    <div class="results-count" id="image-preview-results-count"></div>
                </div>
                <div id="image-preview-loading-message" class="loading-message" style="display: none;">
                    Processing sheet and loading images...
                </div>
                <div id="image-preview-error-message" class="error-message" style="display: none;"></div>
                <div id="image-preview-no-results" class="no-results" style="display: none;">
                    No images found in the sheet.
                </div>
                <div id="image-preview-results" style="margin-top: 20px;"></div>
            </div>
        </div>

        <!-- Compare Images Page -->
        <div id="compare-images" class="page-section">
            <div class="dropdowns-container">
                <div class="dropdown-group">
                    <label for="sheet1">Sheet 1</label>
                    <select id="sheet1" name="sheet1">
                        <option value="">Select an option</option>
                        <option value="gsheet">GSheet</option>
                        <option value="excel-csv">Excel/CSV</option>
                    </select>
                    <div id="sheet1-input" class="input-field-group">
                        <label for="sheet1-value" id="sheet1-label">Enter value</label>
                        <input type="text" id="sheet1-value" placeholder="Enter GSheet value" accept="">
                    </div>
                </div>
                <div class="dropdown-group">
                    <label for="sheet2">Sheet 2</label>
                    <select id="sheet2" name="sheet2">
                        <option value="">Select an option</option>
                        <option value="gsheet">GSheet</option>
                        <option value="excel-csv">Excel/CSV</option>
                    </select>
                    <div id="sheet2-input" class="input-field-group">
                        <label for="sheet2-value" id="sheet2-label">Enter value</label>
                        <input type="text" id="sheet2-value" placeholder="Enter GSheet value" accept="">
                    </div>
                </div>
            </div>
            <div class="compare-button-container">
                <button class="compare-button" id="compare-images-btn">Compare Images</button>
            </div>
            <div id="results-section" class="results-section">
                <div class="results-header">
                    <h2>Common Images</h2>
                    <div class="results-count" id="results-count"></div>
                </div>
                <div id="loading-message" class="loading-message" style="display: none;">
                    Processing sheets and comparing images...
                </div>
                <div id="error-message" class="error-message" style="display: none;"></div>
                <div id="no-results" class="no-results" style="display: none;">
                    No common images found between the sheets.
                </div>
                <div id="images-grid" class="images-grid"></div>
            </div>
        </div>

        <!-- Find Blank Space Page -->
        <div id="find-blank-space" class="page-section">
            <div class="dropdowns-container">
                <div class="dropdown-group">
                    <label for="blank-space-sheet-type">Sheet Type</label>
                    <select id="blank-space-sheet-type" name="blank-space-sheet-type">
                        <option value="">Select an option</option>
                        <option value="gsheet">GSheet</option>
                        <option value="excel-csv">Excel/CSV</option>
                    </select>
                    <div id="blank-space-input" class="input-field-group">
                        <label for="blank-space-value" id="blank-space-label">Enter value</label>
                        <input type="text" id="blank-space-value" placeholder="Enter GSheet URL" accept="">
                    </div>
                </div>
            </div>
            <div class="compare-button-container">
                <button class="compare-button" id="find-blank-space-btn">Find Blank Space</button>
            </div>
            <div id="blank-space-results-section" class="results-section">
                <div class="results-header">
                    <h2>Blank Spaces Found</h2>
                    <div class="results-count" id="blank-space-results-count"></div>
                </div>
                <div id="blank-space-download-container" style="margin-top: 20px; margin-bottom: 20px; text-align: center; display: none;">
                    <button class="compare-button" id="download-highlighted-file-btn" style="display: none;">Download Highlighted File</button>
                </div>
                <div id="blank-space-loading-message" class="loading-message" style="display: none;">
                    Processing sheet and finding blank spaces...
                </div>
                <div id="blank-space-error-message" class="error-message" style="display: none;"></div>
                <div id="blank-space-no-results" class="no-results" style="display: none;">
                    No blank spaces found in the sheet.
                </div>
                <div id="blank-space-results" style="margin-top: 20px;"></div>
            </div>
        </div>

        <!-- HTTP/HTTPS Verification Page -->
        <div id="http-https-verification" class="page-section">
            <div class="dropdowns-container">
                <div class="dropdown-group">
                    <label for="http-https-sheet-type">Sheet Type</label>
                    <select id="http-https-sheet-type" name="http-https-sheet-type">
                        <option value="">Select an option</option>
                        <option value="gsheet">GSheet</option>
                        <option value="excel-csv">Excel/CSV</option>
                    </select>
                    <div id="http-https-input" class="input-field-group">
                        <label for="http-https-value" id="http-https-label">Enter value</label>
                        <input type="text" id="http-https-value" placeholder="Enter GSheet URL" accept="">
                    </div>
                </div>
            </div>
            <div class="compare-button-container">
                <button class="compare-button" id="http-https-verification-btn">Verify HTTP/HTTPS</button>
            </div>
            <div id="http-https-results-section" class="results-section">
                <div class="results-header">
                    <h2>HTTP/HTTPS Results</h2>
                    <div class="results-count" id="http-https-results-count"></div>
                </div>
                <div id="http-https-loading-message" class="loading-message" style="display: none;">
                    Processing sheet and verifying URLs...
                </div>
                <div id="http-https-error-message" class="error-message" style="display: none;"></div>
                <div id="http-https-no-results" class="no-results" style="display: none;">
                    No HTTP URLs found in the sheet. All URLs are HTTPS.
                </div>
                <div id="http-https-results" style="margin-top: 20px;"></div>
            </div>
        </div>

        <!-- Logo Color Page -->
        <div id="logo-color" class="page-section">
            <div class="dropdowns-container">
                <div class="dropdown-group">
                    <label for="logo-color-sheet-type">Sheet Type</label>
                    <select id="logo-color-sheet-type" name="logo-color-sheet-type">
                        <option value="">Select an option</option>
                        <option value="gsheet">GSheet</option>
                        <option value="excel-csv">Excel/CSV</option>
                    </select>
                    <div id="logo-color-input" class="input-field-group">
                        <label for="logo-color-value" id="logo-color-label">Enter value</label>
                        <input type="text" id="logo-color-value" placeholder="Enter GSheet URL" accept="">
                    </div>
                </div>
            </div>
            <div class="compare-button-container">
                <button class="compare-button" id="logo-color-btn">Verify Logo Color</button>
            </div>
            <div id="logo-color-results-section" class="results-section">
                <div class="results-header">
                    <h2>Logo Color Results</h2>
                    <div class="results-count" id="logo-color-results-count"></div>
                </div>
                <div id="logo-color-loading-message" class="loading-message" style="display: none;">
                    Processing sheet and verifying logo colors...
                </div>
                <div id="logo-color-error-message" class="error-message" style="display: none;"></div>
                <div id="logo-color-no-results" class="no-results" style="display: none;">
                    No logo colors found in the sheet.
                </div>
                <div id="logo-color-results" style="margin-top: 20px;"></div>
            </div>
        </div>

        <!-- Warranty Logo Orientation Page -->
        <div id="logo-orientation" class="page-section">
            <div class="dropdowns-container">
                <div class="dropdown-group">
                    <label for="logo-orientation-sheet-type">Sheet Type</label>
                    <select id="logo-orientation-sheet-type" name="logo-orientation-sheet-type">
                        <option value="">Select an option</option>
                        <option value="gsheet">GSheet</option>
                        <option value="excel-csv">Excel/CSV</option>
                    </select>
                    <div id="logo-orientation-input" class="input-field-group">
                        <label for="logo-orientation-value" id="logo-orientation-label">Enter value</label>
                        <input type="text" id="logo-orientation-value" placeholder="Enter GSheet URL" accept="">
                    </div>
                </div>
            </div>
            <div class="compare-button-container">
                <button class="compare-button" id="logo-orientation-btn">Verify Warranty Logo Orientation</button>
            </div>
            <div id="logo-orientation-results-section" class="results-section">
                <div class="results-header">
                    <h2>Warranty Logo Orientation Results</h2>
                    <div class="results-count" id="logo-orientation-results-count"></div>
                </div>
                <div id="logo-orientation-loading-message" class="loading-message" style="display: none;">
                    Processing sheet and verifying warranty logo orientations...
                </div>
                <div id="logo-orientation-error-message" class="error-message" style="display: none;"></div>
                <div id="logo-orientation-no-results" class="no-results" style="display: none;">
                    No warranty logo orientation issues found in the sheet.
                </div>
                <div id="logo-orientation-results" style="margin-top: 20px;"></div>
            </div>
        </div>

        <!-- Warranty Logo Language Page -->
        <div id="logo-language" class="page-section">
            <div class="dropdowns-container">
                <div class="dropdown-group">
                    <label for="logo-language-sheet-type">Sheet Type</label>
                    <select id="logo-language-sheet-type" name="logo-language-sheet-type">
                        <option value="">Select an option</option>
                        <option value="gsheet">GSheet</option>
                        <option value="excel-csv">Excel/CSV</option>
                    </select>
                    <div id="logo-language-input" class="input-field-group">
                        <label for="logo-language-value" id="logo-language-label">Enter value</label>
                        <input type="text" id="logo-language-value" placeholder="Enter GSheet URL" accept="">
                    </div>
                </div>
            </div>
            <div class="compare-button-container">
                <button class="compare-button" id="logo-language-btn">Verify Warranty Logo Language</button>
            </div>
            <div id="logo-language-results-section" class="results-section">
                <div class="results-header">
                    <h2>Warranty Logo Language Results</h2>
                    <div class="results-count" id="logo-language-results-count"></div>
                </div>
                <div id="logo-language-loading-message" class="loading-message" style="display: none;">
                    Processing sheet and verifying warranty logo languages...
                </div>
                <div id="logo-language-error-message" class="error-message" style="display: none;"></div>
                <div id="logo-language-no-results" class="no-results" style="display: none;">
                    No warranty logo language issues found in the sheet.
                </div>
                <div id="logo-language-results" style="margin-top: 20px;"></div>
            </div>
        </div>

        <!-- Year of Warranty Logo Page -->
        <div id="year-of-warranty-logo" class="page-section">
            <div class="dropdowns-container">
                <div class="dropdown-group">
                    <label for="year-of-warranty-logo-sheet-type">Sheet Type</label>
                    <select id="year-of-warranty-logo-sheet-type" name="year-of-warranty-logo-sheet-type">
                        <option value="">Select an option</option>
                        <option value="gsheet">GSheet</option>
                        <option value="excel-csv">Excel/CSV</option>
                    </select>
                    <div id="year-of-warranty-logo-input" class="input-field-group">
                        <label for="year-of-warranty-logo-value" id="year-of-warranty-logo-label">Enter value</label>
                        <input type="text" id="year-of-warranty-logo-value" placeholder="Enter GSheet URL" accept="">
                    </div>
                </div>
            </div>
            <div class="compare-button-container">
                <button class="compare-button" id="year-of-warranty-logo-btn">Verify Year of Warranty Logo</button>
            </div>
            <div id="year-of-warranty-logo-results-section" class="results-section">
                <div class="results-header">
                    <h2>Year of Warranty Logo Results</h2>
                    <div class="results-count" id="year-of-warranty-logo-results-count"></div>
                </div>
                <div id="year-of-warranty-logo-loading-message" class="loading-message" style="display: none;">
                    Processing sheet and verifying year of warranty logos...
                </div>
                <div id="year-of-warranty-logo-error-message" class="error-message" style="display: none;"></div>
                <div id="year-of-warranty-logo-no-results" class="no-results" style="display: none;">
                    No year of warranty logo issues found in the sheet.
                </div>
                <div id="year-of-warranty-logo-results" style="margin-top: 20px;"></div>
            </div>
        </div>

        <!-- Rate Format Page -->
        <div id="rate-format" class="page-section">
            <div class="dropdowns-container">
                <div class="dropdown-group">
                    <label for="rate-format-sheet-type">Sheet Type</label>
                    <select id="rate-format-sheet-type" name="rate-format-sheet-type">
                        <option value="">Select an option</option>
                        <option value="gsheet">GSheet</option>
                        <option value="excel-csv">Excel/CSV</option>
                    </select>
                    <div id="rate-format-input" class="input-field-group">
                        <label for="rate-format-value" id="rate-format-label">Enter value</label>
                        <input type="text" id="rate-format-value" placeholder="Enter GSheet URL" accept="">
                    </div>
                </div>
            </div>
            <div class="compare-button-container">
                <button class="compare-button" id="rate-format-btn">Verify Rate Format</button>
            </div>
            <div id="rate-format-results-section" class="results-section">
                <div class="results-header">
                    <h2>Rate Format Results</h2>
                    <div class="results-count" id="rate-format-results-count"></div>
                </div>
                <div id="rate-format-loading-message" class="loading-message" style="display: none;">
                    Processing sheet and verifying rate formats...
                </div>
                <div id="rate-format-error-message" class="error-message" style="display: none;"></div>
                <div id="rate-format-no-results" class="no-results" style="display: none;">
                    No rate format issues found in the sheet.
                </div>
                <div id="rate-format-results" style="margin-top: 20px;"></div>
            </div>
        </div>

        <!-- Frame Count Page -->
        <div id="frame-count" class="page-section">
            <div class="dropdowns-container">
                <div class="dropdown-group">
                    <label for="frame-count-sheet-type">Sheet Type</label>
                    <select id="frame-count-sheet-type" name="frame-count-sheet-type">
                        <option value="">Select an option</option>
                        <option value="gsheet">GSheet</option>
                        <option value="excel-csv">Excel/CSV</option>
                    </select>
                    <div id="frame-count-input" class="input-field-group">
                        <label for="frame-count-value" id="frame-count-label">Enter value</label>
                        <input type="text" id="frame-count-value" placeholder="Enter GSheet URL" accept="">
                    </div>
                </div>
            </div>
            <div class="compare-button-container">
                <button class="compare-button" id="frame-count-btn">Verify Frame Count</button>
            </div>
            <div id="frame-count-results-section" class="results-section">
                <div class="results-header">
                    <h2>Frame Count Results</h2>
                    <div class="results-count" id="frame-count-results-count"></div>
                </div>
                <div id="frame-count-loading-message" class="loading-message" style="display: none;">
                    Processing sheet and verifying frame counts...
                </div>
                <div id="frame-count-error-message" class="error-message" style="display: none;"></div>
                <div id="frame-count-no-results" class="no-results" style="display: none;">
                    No frame count issues found in the sheet.
                </div>
                <div id="frame-count-results" style="margin-top: 20px;"></div>
            </div>
        </div>

        <!-- Model Names Page -->
        <div id="brand-names" class="page-section">
            <div class="dropdowns-container">
                <div class="dropdown-group">
                    <div id="brand-names-input" class="input-field-group active">
                        <label for="brand-names-value" id="brand-names-label">Enter Jivox Preview URL</label>
                        <input type="text" id="brand-names-value" placeholder="Enter Jivox preview URL (e.g., https://jvx.app.euw1.jivox.com/studio/previewCreatives.php?campaignId=...)" accept="">
                    </div>
                </div>
            </div>
            <div class="compare-button-container">
                <button class="compare-button" id="brand-names-btn">Analyze</button>
            </div>
            <div id="brand-names-results-section" class="results-section">
                <div class="results-header">
                    <h2>Jivox Preview Analysis Results</h2>
                </div>
                <div id="brand-names-loading-message" class="loading-message" style="display: none;">
                    Loading page and scanning for elements...
                </div>
                <div id="brand-names-error-message" class="error-message" style="display: none;"></div>
                <div id="brand-names-no-results" class="no-results" style="display: none;">
                    No results found.
                </div>
                <div id="brand-names-results" style="margin-top: 20px;"></div>
            </div>
        </div>

        <!-- Rate Card Page -->
        <div id="rate-card" class="page-section">
            <div class="dropdowns-container">
                <div class="dropdown-group">
                    <label for="rate-card-sheet-type">Sheet Type</label>
                    <select id="rate-card-sheet-type" name="rate-card-sheet-type">
                        <option value="">Select an option</option>
                        <option value="gsheet">GSheet</option>
                        <option value="excel-csv">Excel/CSV</option>
                    </select>
                    <div id="rate-card-input" class="input-field-group">
                        <label for="rate-card-value" id="rate-card-label">Enter value</label>
                        <input type="text" id="rate-card-value" placeholder="Enter GSheet URL" accept="">
                    </div>
                </div>
            </div>
            <div class="compare-button-container">
                <button class="compare-button" id="rate-card-btn">Process Rate Card</button>
            </div>
            <div id="rate-card-results-section" class="results-section">
                <div class="results-header">
                    <h2>Rate Card Results</h2>
                    <div class="results-count" id="rate-card-results-count"></div>
                </div>
                <div id="rate-card-loading-message" class="loading-message" style="display: none;">
                    Processing sheet...
                </div>
                <div id="rate-card-error-message" class="error-message" style="display: none;"></div>
                <div id="rate-card-no-results" class="no-results" style="display: none;">
                    No results found.
                </div>
                <div id="rate-card-results" style="margin-top: 20px;"></div>
            </div>
        </div>

        <!-- Font Size Page -->
        <div id="font-size" class="page-section">
            <div class="dropdowns-container">
                <div class="dropdown-group">
                    <label for="font-size-sheet-type">Sheet Type</label>
                    <select id="font-size-sheet-type" name="font-size-sheet-type">
                        <option value="">Select an option</option>
                        <option value="gsheet">GSheet</option>
                        <option value="excel-csv">Excel/CSV</option>
                    </select>
                    <div id="font-size-input" class="input-field-group">
                        <label for="font-size-value" id="font-size-label">Enter value</label>
                        <input type="text" id="font-size-value" placeholder="Enter GSheet URL" accept="">
                    </div>
                </div>
            </div>
            <div class="compare-button-container">
                <button class="compare-button" id="font-size-btn">Process Font Size</button>
            </div>
            <div id="font-size-results-section" class="results-section">
                <div class="results-header">
                    <h2>Font Size Results</h2>
                    <div class="results-count" id="font-size-results-count"></div>
                </div>
                <div id="font-size-loading-message" class="loading-message" style="display: none;">
                    Processing sheet...
                </div>
                <div id="font-size-error-message" class="error-message" style="display: none;"></div>
                <div id="font-size-no-results" class="no-results" style="display: none;">
                    No results found.
                </div>
                <div id="font-size-results" style="margin-top: 20px;"></div>
            </div>
        </div>
    </main>

    <script>
        // Navigation functionality
        document.addEventListener('DOMContentLoaded', function() {
            const navLinks = document.querySelectorAll('.nav-link');
            const pageSections = document.querySelectorAll('.page-section');
            const menuToggle = document.getElementById('menu-toggle');
            const sidebar = document.querySelector('.sidebar');

            // Mobile menu toggle
            if (menuToggle && sidebar) {
                menuToggle.addEventListener('click', function() {
                    sidebar.classList.toggle('open');
                });
            }

            // Navigation link clicks
            navLinks.forEach(link => {
                link.addEventListener('click', function(e) {
                    e.preventDefault();
                    
                    // Remove active class from all links
                    navLinks.forEach(l => l.classList.remove('active'));
                    // Add active class to clicked link
                    this.classList.add('active');
                    
                    // Hide all page sections
                    pageSections.forEach(section => section.classList.remove('active'));
                    
                    // Show the selected page
                    const pageId = this.getAttribute('data-page');
                    const targetPage = document.getElementById(pageId);
                    if (targetPage) {
                        targetPage.classList.add('active');
                    }

                    // Close sidebar on mobile after clicking a link
                    if (window.innerWidth <= 768 && sidebar) {
                        sidebar.classList.remove('open');
                    }
                });
            });

            // Dropdown functionality for Sheet 1
            const sheet1Dropdown = document.getElementById('sheet1');
            const sheet1Input = document.getElementById('sheet1-input');
            const sheet1ValueInput = document.getElementById('sheet1-value');
            const sheet1Label = document.getElementById('sheet1-label');
            
            sheet1Dropdown.addEventListener('change', function() {
                if (this.value) {
                    sheet1Input.classList.add('active');
                    if (this.value === 'excel-csv') {
                        sheet1ValueInput.type = 'file';
                        sheet1ValueInput.accept = '.xlsx,.xls,.csv';
                        sheet1ValueInput.placeholder = '';
                        sheet1Label.textContent = 'Select file';
                    } else if (this.value === 'gsheet') {
                        sheet1ValueInput.type = 'text';
                        sheet1ValueInput.placeholder = 'Enter GSheet value';
                        sheet1Label.textContent = 'Enter value';
                    }
                } else {
                    sheet1Input.classList.remove('active');
                    sheet1ValueInput.value = '';
                    sheet1ValueInput.type = 'text';
                }
            });

            // Dropdown functionality for Sheet 2
            const sheet2Dropdown = document.getElementById('sheet2');
            const sheet2Input = document.getElementById('sheet2-input');
            const sheet2ValueInput = document.getElementById('sheet2-value');
            const sheet2Label = document.getElementById('sheet2-label');
            
            sheet2Dropdown.addEventListener('change', function() {
                if (this.value) {
                    sheet2Input.classList.add('active');
                    if (this.value === 'excel-csv') {
                        sheet2ValueInput.type = 'file';
                        sheet2ValueInput.accept = '.xlsx,.xls,.csv';
                        sheet2ValueInput.placeholder = '';
                        sheet2Label.textContent = 'Select file';
                    } else if (this.value === 'gsheet') {
                        sheet2ValueInput.type = 'text';
                        sheet2ValueInput.placeholder = 'Enter GSheet value';
                        sheet2Label.textContent = 'Enter value';
                    }
                } else {
                    sheet2Input.classList.remove('active');
                    sheet2ValueInput.value = '';
                    sheet2ValueInput.type = 'text';
                }
            });

            // Compare Images button functionality
            // Image Preview functionality
            const imagePreviewDropdown = document.getElementById('image-preview-sheet-type');
            const imagePreviewInput = document.getElementById('image-preview-input');
            const imagePreviewValueInput = document.getElementById('image-preview-value');
            const imagePreviewLabel = document.getElementById('image-preview-label');
            
            imagePreviewDropdown.addEventListener('change', function() {
                if (this.value) {
                    imagePreviewInput.classList.add('active');
                    if (this.value === 'excel-csv') {
                        imagePreviewValueInput.type = 'file';
                        imagePreviewValueInput.accept = '.xlsx,.xls,.csv';
                        imagePreviewValueInput.placeholder = '';
                        imagePreviewLabel.textContent = 'Select file';
                    } else if (this.value === 'gsheet') {
                        imagePreviewValueInput.type = 'text';
                        imagePreviewValueInput.accept = '';
                        imagePreviewValueInput.placeholder = 'Enter GSheet URL';
                        imagePreviewLabel.textContent = 'Enter GSheet URL';
                    }
                } else {
                    imagePreviewInput.classList.remove('active');
                }
            });

            // Image Preview button functionality
            const imagePreviewButton = document.getElementById('image-preview-btn');
            const imagePreviewResultsSection = document.getElementById('image-preview-results-section');
            const imagePreviewLoadingMessage = document.getElementById('image-preview-loading-message');
            const imagePreviewErrorMessage = document.getElementById('image-preview-error-message');
            const imagePreviewNoResults = document.getElementById('image-preview-no-results');
            const imagePreviewResults = document.getElementById('image-preview-results');
            const imagePreviewResultsCount = document.getElementById('image-preview-results-count');

            function showImagePreviewError(message) {
                imagePreviewResultsSection.classList.add('active');
                imagePreviewErrorMessage.textContent = message;
                imagePreviewErrorMessage.style.display = 'block';
                imagePreviewLoadingMessage.style.display = 'none';
                imagePreviewNoResults.style.display = 'none';
            }

            function clearImagePreviewResults() {
                imagePreviewResults.innerHTML = '';
                imagePreviewErrorMessage.style.display = 'none';
                imagePreviewNoResults.style.display = 'none';
                imagePreviewResultsCount.textContent = '';
            }

            imagePreviewButton.addEventListener('click', async function() {
                const sheetType = imagePreviewDropdown.value;
                const sheetValue = imagePreviewValueInput.value;

                if (!sheetType) {
                    showImagePreviewError('Please select a sheet type');
                    return;
                }

                if (!sheetValue) {
                    showImagePreviewError('Please provide a sheet URL or file');
                    return;
                }

                clearImagePreviewResults();
                imagePreviewResultsSection.classList.add('active');
                imagePreviewLoadingMessage.style.display = 'block';
                imagePreviewButton.disabled = true;
                imagePreviewButton.textContent = 'Processing...';

                try {
                    let data = [];
                    let file = null;
                    
                    if (sheetType === 'excel-csv') {
                        file = imagePreviewValueInput.files[0];
                        if (!file) {
                            throw new Error('Please select a file');
                        }
                        data = await readExcelFile(file);
                    } else if (sheetType === 'gsheet') {
                        data = await readGoogleSheet(sheetValue);
                    }
                    
                    // Extract all image URLs from the sheet
                    const imageUrls = [];
                    const urlPattern = /(https?:\/\/[^\s]+\.(jpg|jpeg|png|gif|webp|bmp|svg))/gi;
                    
                    data.forEach(row => {
                        Object.keys(row).forEach(columnName => {
                            const cell = row[columnName];
                            if (cell && typeof cell === 'string') {
                                const matches = cell.match(urlPattern);
                                if (matches) {
                                    matches.forEach(url => {
                                        const cleanUrl = url.replace(/[.,;!?]$/, ''); // Remove trailing punctuation
                                        imageUrls.push({
                                            url: cleanUrl,
                                            name: extractImageName(cleanUrl),
                                            column: columnName
                                        });
                                    });
                                }
                            }
                        });
                    });
                    
                    imagePreviewLoadingMessage.style.display = 'none';
                    imagePreviewButton.disabled = false;
                    imagePreviewButton.textContent = 'Preview Images';
                    
                    if (imageUrls.length === 0) {
                        imagePreviewNoResults.style.display = 'block';
                        imagePreviewResultsCount.textContent = 'No images found';
                    } else {
                        imagePreviewNoResults.style.display = 'none';
                        imagePreviewResultsCount.textContent = `Found ${imageUrls.length} image${imageUrls.length !== 1 ? 's' : ''}`;
                        displayImagePreviewResults(imageUrls);
                    }
                } catch (error) {
                    console.error('Error:', error);
                    showImagePreviewError('Error: ' + error.message);
                    imagePreviewButton.disabled = false;
                    imagePreviewButton.textContent = 'Preview Images';
                }
            });

            const compareButton = document.getElementById('compare-images-btn');
            const resultsSection = document.getElementById('results-section');
            const loadingMessage = document.getElementById('loading-message');
            const errorMessage = document.getElementById('error-message');
            const noResults = document.getElementById('no-results');
            const imagesGrid = document.getElementById('images-grid');
            const resultsCount = document.getElementById('results-count');

            compareButton.addEventListener('click', async function() {
                // Reset UI
                resultsSection.classList.remove('active');
                loadingMessage.style.display = 'none';
                errorMessage.style.display = 'none';
                noResults.style.display = 'none';
                imagesGrid.innerHTML = '';
                resultsCount.textContent = '';

                // Validate inputs
                const sheet1Type = sheet1Dropdown.value;
                const sheet2Type = sheet2Dropdown.value;
                const sheet1Value = sheet1ValueInput.value;
                const sheet2Value = sheet2ValueInput.value;
                const sheet1File = sheet1ValueInput.files && sheet1ValueInput.files[0];
                const sheet2File = sheet2ValueInput.files && sheet2ValueInput.files[0];

                if (!sheet1Type || !sheet2Type) {
                    showError('Please select options for both sheets.');
                    return;
                }

                if ((sheet1Type === 'gsheet' && !sheet1Value) || (sheet1Type === 'excel-csv' && !sheet1File)) {
                    showError('Please provide a value for Sheet 1.');
                    return;
                }

                if ((sheet2Type === 'gsheet' && !sheet2Value) || (sheet2Type === 'excel-csv' && !sheet2File)) {
                    showError('Please provide a value for Sheet 2.');
                    return;
                }

                // Show loading and results section
                resultsSection.classList.add('active');
                loadingMessage.style.display = 'block';
                compareButton.disabled = true;

                try {
                    // Extract image URLs from both sheets
                    const sheet1Images = await extractImageUrls(sheet1Type, sheet1Value, sheet1File);
                    const sheet2Images = await extractImageUrls(sheet2Type, sheet2Value, sheet2File);

                    // Find common images
                    const commonImages = findCommonImages(sheet1Images, sheet2Images);

                    // Display results
                    loadingMessage.style.display = 'none';
                    displayResults(commonImages);
                } catch (error) {
                    loadingMessage.style.display = 'none';
                    showError('Error processing sheets: ' + error.message);
                    console.error('Error:', error);
                } finally {
                    compareButton.disabled = false;
                }
            });

            function showError(message) {
                resultsSection.classList.add('active');
                errorMessage.textContent = message;
                errorMessage.style.display = 'block';
            }

            async function extractImageUrls(type, value, file) {
                let data = [];
                
                if (type === 'excel-csv') {
                    // Read Excel/CSV file
                    data = await readExcelFile(file);
                } else if (type === 'gsheet') {
                    // Read Google Sheet
                    data = await readGoogleSheet(value);
                }

                // Extract image URLs from all cells with column information
                const imageUrls = [];
                const urlPattern = /(https?:\/\/[^\s]+\.(jpg|jpeg|png|gif|webp|bmp|svg))/gi;

                data.forEach(row => {
                    Object.keys(row).forEach(columnName => {
                        const cell = row[columnName];
                        if (cell && typeof cell === 'string') {
                            const matches = cell.match(urlPattern);
                            if (matches) {
                                matches.forEach(url => {
                                    const cleanUrl = url.replace(/[.,;!?]$/, ''); // Remove trailing punctuation
                                    // Check if this URL already exists, if so add column to it
                                    const existingImage = imageUrls.find(img => img.url.toLowerCase() === cleanUrl.toLowerCase());
                                    if (existingImage) {
                                        // Add column if not already present
                                        if (!existingImage.columns.includes(columnName)) {
                                            existingImage.columns.push(columnName);
                                        }
                                    } else {
                                        imageUrls.push({
                                            url: cleanUrl,
                                            name: extractImageName(cleanUrl),
                                            columns: [columnName]
                                        });
                                    }
                                });
                            }
                        }
                    });
                });

                return imageUrls;
            }

            function extractImageName(url) {
                try {
                    const urlObj = new URL(url);
                    const pathname = urlObj.pathname;
                    const filename = pathname.split('/').pop() || pathname.split('/').slice(-2, -1)[0] || 'image';
                    return decodeURIComponent(filename.split('.')[0] || filename);
                } catch (e) {
                    // If URL parsing fails, try to extract from string
                    const match = url.match(/\/([^\/]+\.(jpg|jpeg|png|gif|webp|bmp|svg))/i);
                    if (match) {
                        return match[1].split('.')[0];
                    }
                    return 'image';
                }
            }

            function displayImagePreviewResults(imageUrls) {
                imagePreviewResults.innerHTML = '';
                
                // Create grid container for images
                const imagesGrid = document.createElement('div');
                imagesGrid.className = 'images-grid';
                imagesGrid.style.cssText = 'display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 20px; margin-top: 20px;';
                
                imageUrls.forEach((image, index) => {
                    const imageCard = document.createElement('div');
                    imageCard.style.cssText = 'background: linear-gradient(135deg, #ffffff 0%, #fafafa 100%); padding: 16px; border-radius: 12px; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08); border: 2px solid #e0e0e0;';
                    
                    const nameDiv = document.createElement('div');
                    nameDiv.className = 'image-name';
                    nameDiv.style.cssText = 'font-weight: 600; color: #250651; margin-bottom: 10px; text-align: center; font-size: 0.9rem; word-break: break-word; padding: 6px 10px; background: linear-gradient(135deg, rgba(86, 18, 189, 0.1) 0%, rgba(146, 80, 242, 0.1) 100%); border-radius: 6px;';
                    nameDiv.textContent = image.name || 'Image';
                    
                    const columnDiv = document.createElement('div');
                    columnDiv.style.cssText = 'font-size: 0.8rem; color: #666; margin-bottom: 10px; text-align: center; font-style: italic;';
                    columnDiv.textContent = `Column: ${image.column || 'Unknown'}`;
                    
                    const wrapper = document.createElement('div');
                    wrapper.className = 'image-wrapper';
                    wrapper.style.cssText = 'width: 100%; max-width: 100%; border: 3px solid #e0e0e0; border-radius: 8px; overflow: hidden; background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%); display: flex; align-items: center; justify-content: center; min-height: 200px;';
                    
                    // Check if filename contains "_white_" and set black background
                    if (image.url && image.url.toLowerCase().includes('_white_')) {
                        wrapper.classList.add('white-image-bg');
                    }
                    
                    const img = document.createElement('img');
                    img.src = image.url;
                    img.alt = image.name || 'Image';
                    img.style.cssText = 'max-width: 100%; max-height: 400px; width: auto; height: auto; display: block; object-fit: contain;';
                    
                    let isBroken = false;
                    
                    img.onerror = function() {
                        isBroken = true;
                        // Show broken image indicator
                        wrapper.style.border = '3px solid #dc3545'; // Red border for broken images
                        wrapper.style.backgroundColor = '#f8f9fa';
                        wrapper.innerHTML = `
                            <div style="text-align: center; padding: 20px; color: #dc3545;">
                                <div style="font-size: 3rem; margin-bottom: 10px;">âš ï¸</div>
                                <div style="font-weight: 600; font-size: 1rem;">Broken Image</div>
                                <div style="font-size: 0.85rem; margin-top: 5px; color: #666; word-break: break-all;">${image.url.substring(0, 50)}...</div>
                            </div>
                        `;
                    };
                    
                    img.onload = function() {
                        if (!isBroken) {
                            // Set container size based on image dimensions
                            const naturalWidth = this.naturalWidth;
                            const naturalHeight = this.naturalHeight;
                            
                            // Maximum display size
                            const maxDisplayWidth = 400;
                            const maxDisplayHeight = 400;
                            
                            let displayWidth = naturalWidth;
                            let displayHeight = naturalHeight;
                            
                            // Scale down proportionally if too large
                            if (displayWidth > maxDisplayWidth || displayHeight > maxDisplayHeight) {
                                const widthRatio = maxDisplayWidth / displayWidth;
                                const heightRatio = maxDisplayHeight / displayHeight;
                                const ratio = Math.min(widthRatio, heightRatio);
                                
                                displayWidth = Math.round(displayWidth * ratio);
                                displayHeight = Math.round(displayHeight * ratio);
                            }
                            
                            // Set wrapper size to match image display size
                            wrapper.style.width = displayWidth + 'px';
                            wrapper.style.height = displayHeight + 'px';
                            wrapper.style.minHeight = 'auto';
                        }
                    };
                    
                    wrapper.appendChild(img);
                    imageCard.appendChild(nameDiv);
                    imageCard.appendChild(columnDiv);
                    imageCard.appendChild(wrapper);
                    imagesGrid.appendChild(imageCard);
                });
                
                imagePreviewResults.appendChild(imagesGrid);
            }

            async function readExcelFile(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        try {
                            const data = new Uint8Array(e.target.result);
                            const workbook = XLSX.read(data, { type: 'array' });
                            const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
                            const jsonData = XLSX.utils.sheet_to_json(firstSheet);
                            resolve(jsonData);
                        } catch (error) {
                            reject(new Error('Failed to parse Excel/CSV file: ' + error.message));
                        }
                    };
                    reader.onerror = () => reject(new Error('Failed to read file'));
                    reader.readAsArrayBuffer(file);
                });
            }

            async function readGoogleSheet(url) {
                try {
                    // Clean and validate URL
                    url = url.trim();
                    
                    // Check if URL is already a CSV export URL
                    let csvUrl;
                    if (url.includes('/export?format=csv')) {
                        csvUrl = url;
                    } else {
                        // Extract sheet ID from various Google Sheets URL formats
                        let sheetId = null;
                        
                        // Format 1: https://docs.google.com/spreadsheets/d/SHEET_ID/edit
                        const match1 = url.match(/\/spreadsheets\/d\/([a-zA-Z0-9-_]+)/);
                        if (match1) {
                            sheetId = match1[1];
                        }
                        
                        // Format 2: https://docs.google.com/spreadsheets/d/SHEET_ID/edit#gid=0
                        if (!sheetId) {
                            const match2 = url.match(/\/d\/([a-zA-Z0-9-_]+)/);
                            if (match2) {
                                sheetId = match2[1];
                            }
                        }
                        
                        // Format 3: Just the sheet ID
                        if (!sheetId && /^[a-zA-Z0-9-_]+$/.test(url)) {
                            sheetId = url;
                        }
                        
                        if (!sheetId) {
                            throw new Error('Invalid Google Sheets URL. Please provide a valid Google Sheets URL or Sheet ID.');
                        }
                        
                        // Construct CSV export URL
                        csvUrl = `https://docs.google.com/spreadsheets/d/${sheetId}/export?format=csv&gid=0`;
                    }
                    
                    // Try to fetch directly first
                    let response;
                    let csvText;
                    
                    try {
                        // Create a timeout promise (30 seconds)
                        const timeoutPromise = new Promise((_, reject) => 
                            setTimeout(() => reject(new Error('Request timeout after 30 seconds')), 30000)
                        );
                        
                        // Race between fetch and timeout
                        response = await Promise.race([
                            fetch(csvUrl, {
                                method: 'GET',
                                mode: 'cors',
                                headers: {
                                    'Accept': 'text/csv'
                                }
                            }),
                            timeoutPromise
                        ]);
                        
                        if (!response.ok) {
                            if (response.status === 403) {
                                throw new Error('Access denied. Please make sure the Google Sheet is shared with "Anyone with the link" can view. Go to Share â†’ Change to "Anyone with the link" â†’ Viewer.');
                            } else if (response.status === 404) {
                                throw new Error('Google Sheet not found. Please check the URL or Sheet ID. Make sure you copied the complete URL.');
                            } else {
                                throw new Error(`Failed to fetch Google Sheet (Status: ${response.status}). Make sure the sheet is publicly accessible.`);
                            }
                        }
                        
                        csvText = await response.text();
                        
                        // Check if we got HTML instead of CSV (common when sheet is not public)
                        if (csvText.includes('<!DOCTYPE') || csvText.includes('<html') || csvText.includes('Sign in')) {
                            throw new Error('Received HTML instead of CSV. The sheet may not be publicly accessible. Please ensure it is shared with "Anyone with the link" can view.');
                        }
                    } catch (fetchError) {
                        // If direct fetch fails (likely CORS), try using CORS proxies
                        console.log('Direct fetch failed, trying CORS proxies...', fetchError);
                        
                        // List of CORS proxy services to try
                        const proxies = [
                            `https://api.allorigins.win/raw?url=${encodeURIComponent(csvUrl)}`,
                            `https://corsproxy.io/?${encodeURIComponent(csvUrl)}`,
                            `https://api.codetabs.com/v1/proxy?quest=${encodeURIComponent(csvUrl)}`
                        ];
                        
                        let lastError = fetchError;
                        let success = false;
                        
                        // Try each proxy in sequence
                        for (let i = 0; i < proxies.length; i++) {
                            try {
                                console.log(`Trying proxy ${i + 1}/${proxies.length}...`);
                                
                                // Create timeout for proxy request
                                const proxyTimeout = new Promise((_, reject) => 
                                    setTimeout(() => reject(new Error('Proxy request timeout')), 30000)
                                );
                                
                                response = await Promise.race([
                                    fetch(proxies[i], {
                                        method: 'GET',
                                        mode: 'cors',
                                        headers: {
                                            'Accept': 'text/csv'
                                        }
                                    }),
                                    proxyTimeout
                                ]);
                                
                                if (!response.ok) {
                                    throw new Error(`Proxy ${i + 1} failed with status ${response.status}`);
                                }
                                
                                csvText = await response.text();
                                
                                // Check if we got HTML instead of CSV
                                if (csvText.includes('<!DOCTYPE') || csvText.includes('<html') || csvText.includes('Sign in')) {
                                    throw new Error('Received HTML instead of CSV from proxy');
                                }
                                
                                console.log(`Successfully fetched via proxy ${i + 1}`);
                                success = true;
                                break;
                            } catch (proxyError) {
                                console.log(`Proxy ${i + 1} failed:`, proxyError.message);
                                lastError = proxyError;
                                // Continue to next proxy
                            }
                        }
                        
                        if (!success) {
                            // All proxies failed, provide detailed error message
                            const errorDetails = lastError.message || fetchError.message;
                            throw new Error(`Failed to fetch Google Sheet after trying multiple methods. Error: ${errorDetails}. Please ensure: 1) The sheet is shared with "Anyone with the link" can view, 2) You are using a valid Google Sheets URL (try copying the "Share" link), 3) As an alternative, download the sheet as CSV manually and upload it as a file instead.`);
                        }
                    }
                    
                    if (!csvText || csvText.trim().length === 0) {
                        throw new Error('Google Sheet appears to be empty or could not be read.');
                    }
                    
                    const workbook = XLSX.read(csvText, { type: 'string' });
                    const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
                    const jsonData = XLSX.utils.sheet_to_json(firstSheet);
                    return jsonData;
                } catch (error) {
                    // Provide more helpful error messages
                    if (error.message.includes('Failed to fetch') || error.message.includes('CORS')) {
                        throw new Error('Failed to fetch Google Sheet. This might be due to CORS restrictions. Please ensure: 1) The sheet is shared with "Anyone with the link" can view, 2) You are using a valid Google Sheets URL, 3) Try copying the "Share" link from Google Sheets.');
                    }
                    throw new Error('Failed to read Google Sheet: ' + error.message);
                }
            }

            // Helper function to get all sheets from a Google Sheet
            async function getAllSheets(spreadsheetId) {
                try {
                    const serverUrl = window.location.protocol === 'file:' 
                        ? 'http://localhost:3000' 
                        : window.location.origin;

                    const response = await fetch(`${serverUrl}/api/get-sheets/${spreadsheetId}`);
                    const data = await response.json();

                    if (!response.ok) {
                        throw new Error(data.error || 'Failed to get sheets');
                    }

                    return data.sheets || [];
                } catch (error) {
                    console.error('Error getting all sheets:', error);
                    // If backend fails, return empty array (will process only the first sheet)
                    return [];
                }
            }

            // Helper function to read a specific Google Sheet CSV by URL
            async function readGoogleSheetCSV(csvUrl) {
                try {
                    // Try to fetch directly first
                    let response;
                    let csvText;
                    
                    try {
                        const timeoutPromise = new Promise((_, reject) => 
                            setTimeout(() => reject(new Error('Request timeout after 30 seconds')), 30000)
                        );
                        
                        response = await Promise.race([
                            fetch(csvUrl, {
                                method: 'GET',
                                mode: 'cors',
                                headers: {
                                    'Accept': 'text/csv'
                                }
                            }),
                            timeoutPromise
                        ]);
                        
                        if (!response.ok) {
                            throw new Error(`Failed to fetch: ${response.status}`);
                        }
                        
                        csvText = await response.text();
                        
                        if (csvText.includes('<!DOCTYPE') || csvText.includes('<html') || csvText.includes('Sign in')) {
                            throw new Error('Received HTML instead of CSV');
                        }
                    } catch (fetchError) {
                        // Try CORS proxies
                        const proxies = [
                            `https://api.allorigins.win/raw?url=${encodeURIComponent(csvUrl)}`,
                            `https://corsproxy.io/?${encodeURIComponent(csvUrl)}`,
                            `https://api.codetabs.com/v1/proxy?quest=${encodeURIComponent(csvUrl)}`
                        ];
                        
                        let success = false;
                        for (let i = 0; i < proxies.length; i++) {
                            try {
                                const proxyTimeout = new Promise((_, reject) => 
                                    setTimeout(() => reject(new Error('Proxy request timeout')), 30000)
                                );
                                
                                response = await Promise.race([
                                    fetch(proxies[i], {
                                        method: 'GET',
                                        mode: 'cors',
                                        headers: {
                                            'Accept': 'text/csv'
                                        }
                                    }),
                                    proxyTimeout
                                ]);
                                
                                if (!response.ok) {
                                    throw new Error(`Proxy ${i + 1} failed with status ${response.status}`);
                                }
                                
                                csvText = await response.text();
                                
                                if (csvText.includes('<!DOCTYPE') || csvText.includes('<html') || csvText.includes('Sign in')) {
                                    throw new Error('Received HTML instead of CSV from proxy');
                                }
                                
                                success = true;
                                break;
                            } catch (proxyError) {
                                if (i === proxies.length - 1) {
                                    throw fetchError;
                                }
                            }
                        }
                        
                        if (!success) {
                            throw fetchError;
                        }
                    }
                    
                    if (!csvText || csvText.trim().length === 0) {
                        throw new Error('Sheet appears to be empty');
                    }
                    
                    const workbook = XLSX.read(csvText, { type: 'string' });
                    const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
                    const jsonData = XLSX.utils.sheet_to_json(firstSheet, { header: 1, defval: null });
                    
                    return { 
                        data: jsonData, 
                        workbook: workbook
                    };
                } catch (error) {
                    throw new Error('Failed to read Google Sheet: ' + error.message);
                }
            }

            function findCommonImages(sheet1Images, sheet2Images) {
                const common = [];
                const sheet2Urls = new Set(sheet2Images.map(img => img.url.toLowerCase()));

                sheet1Images.forEach(img1 => {
                    if (sheet2Urls.has(img1.url.toLowerCase())) {
                        // Find matching image from sheet2
                        const img2 = sheet2Images.find(img => img.url.toLowerCase() === img1.url.toLowerCase());
                        if (img2) {
                            common.push({
                                url: img1.url,
                                name: img1.name || img2.name || 'image',
                                sheet1Columns: img1.columns || [],
                                sheet2Columns: img2.columns || []
                            });
                        }
                    }
                });

                return common;
            }

            function displayResults(commonImages) {
                if (commonImages.length === 0) {
                    noResults.style.display = 'block';
                    return;
                }

                resultsCount.textContent = `Found ${commonImages.length} common image${commonImages.length !== 1 ? 's' : ''}`;

                imagesGrid.innerHTML = '';
                console.log(`Displaying ${commonImages.length} common images`);
                
                commonImages.forEach((image, index) => {
                    console.log(`Processing image ${index + 1}/${commonImages.length}: ${image.url}`);
                    const imagePair = document.createElement('div');
                    imagePair.className = 'image-pair';
                    
                    let imagesLoaded = 0;
                    let imageOrientation = null;
                    let displayWidth = null;
                    let displayHeight = null;
                    
                    // Function to extract dimensions from column name (e.g., LOGO_300x250 -> {width: 300, height: 250})
                    function extractDimensionsFromColumn(columnName) {
                        if (!columnName) return null;
                        
                        // Match pattern like LOGO_300x250 or 300x250
                        const match = columnName.match(/(\d+)x(\d+)/i);
                        if (match) {
                            return {
                                width: parseInt(match[1]),
                                height: parseInt(match[2])
                            };
                        }
                        return null;
                    }
                    
                    // Get expected dimensions from column name (use first column from either sheet)
                    const firstColumn = (image.sheet1Columns && image.sheet1Columns.length > 0) 
                        ? image.sheet1Columns[0] 
                        : ((image.sheet2Columns && image.sheet2Columns.length > 0) ? image.sheet2Columns[0] : null);
                    const expectedDimensions = extractDimensionsFromColumn(firstColumn);
                    
                    // Function to set layout once both images are loaded
                    function setLayoutIfReady() {
                        if (imagesLoaded === 2 && imageOrientation !== null) {
                            if (imageOrientation === 'horizontal') {
                                // Horizontal images: top and bottom layout
                                imagePair.style.flexDirection = 'column';
                                imagePair.style.gap = '20px';
                            } else {
                                // Vertical images: left and right layout
                                imagePair.style.flexDirection = 'row';
                                imagePair.style.gap = '20px';
                            }
                        }
                    }
                    
                    // Function to calculate display size based on expected dimensions or natural size
                    function calculateDisplaySize(expectedWidth, expectedHeight, naturalWidth, naturalHeight, isVerticalLayout) {
                        // For vertical layout (side by side), we need to account for two images + gap (20px) + padding (48px)
                        // Available width is typically around 900-1000px minus padding, so ~850px usable
                        // To prevent overlap, let's use 280px max to ensure 320px images get scaled down
                        // This will scale 320px images: 320 * (280/320) = 280px, giving us: 280 + 280 + 20 = 580px total (safe)
                        // For horizontal layout (top/bottom), we only need to fit one image
                        const maxDisplayWidth = isVerticalLayout ? 280 : 600; // Smaller for side-by-side to prevent overlap
                        const maxDisplayHeight = isVerticalLayout ? 450 : 500;
                        
                        let width, height;
                        
                        // Use expected dimensions from column name if available, otherwise use natural dimensions
                        if (expectedWidth && expectedHeight) {
                            width = expectedWidth;
                            height = expectedHeight;
                        } else {
                            width = naturalWidth;
                            height = naturalHeight;
                        }
                        
                        // For side-by-side layout, ALWAYS scale down to ensure fit
                        // Calculate the ratio needed to fit both images side by side
                        if (isVerticalLayout) {
                            // Always scale down when side-by-side to prevent overlap
                            // Use the smaller ratio to ensure both width and height fit
                            const widthRatio = maxDisplayWidth / width;
                            const heightRatio = maxDisplayHeight / height;
                            const ratio = Math.min(widthRatio, heightRatio);
                            
                            width = Math.round(width * ratio);
                            height = Math.round(height * ratio);
                            
                            // Double-check: ensure width doesn't exceed max (safety check)
                            if (width > maxDisplayWidth) {
                                const finalRatio = maxDisplayWidth / width;
                                width = Math.round(width * finalRatio);
                                height = Math.round(height * finalRatio);
                            }
                        } else if (!isVerticalLayout && (width > maxDisplayWidth || height > maxDisplayHeight)) {
                            // For top/bottom layout, scale if either dimension exceeds max
                            const widthRatio = maxDisplayWidth / width;
                            const heightRatio = maxDisplayHeight / height;
                            const ratio = Math.min(widthRatio, heightRatio);
                            
                            width = Math.round(width * ratio);
                            height = Math.round(height * ratio);
                        }
                        
                        return { width, height };
                    }
                    
                    // Sheet 1 container
                    const container1 = document.createElement('div');
                    container1.className = 'image-container';
                    
                    const name1 = document.createElement('div');
                    name1.className = 'image-name';
                    name1.innerHTML = `<strong>Sheet 1</strong><br>${image.name || 'Image'}`;
                    
                    // Show only first column from Sheet 1
                    const columns1 = document.createElement('div');
                    columns1.className = 'image-columns';
                    columns1.style.cssText = 'font-size: 0.85rem; color: #666; margin-top: 5px; font-style: italic;';
                    if (image.sheet1Columns && image.sheet1Columns.length > 0) {
                        columns1.textContent = `Column: ${image.sheet1Columns[0]}`;
                    } else {
                        columns1.textContent = 'Column: Unknown';
                    }
                    
                    const wrapper1 = document.createElement('div');
                    wrapper1.className = 'image-wrapper';
                    
                    // Check if filename contains "_white_" and set black background
                    if (image.url && image.url.toLowerCase().includes('_white_')) {
                        wrapper1.classList.add('white-image-bg');
                    }
                    
                    const img1 = document.createElement('img');
                    img1.src = image.url;
                    img1.alt = image.name;
                    img1.onerror = function() {
                        this.parentElement.innerHTML = '<div style="color: #999; padding: 20px;">Failed to load image</div>';
                    };
                    
                    img1.onload = function() {
                        const naturalWidth = this.naturalWidth;
                        const naturalHeight = this.naturalHeight;
                        
                        // Determine orientation first (based on expected dimensions or natural size)
                        let tempWidth = expectedDimensions ? expectedDimensions.width : naturalWidth;
                        let tempHeight = expectedDimensions ? expectedDimensions.height : naturalHeight;
                        if (imageOrientation === null) {
                            imageOrientation = tempWidth > tempHeight ? 'horizontal' : 'vertical';
                        }
                        
                        // Calculate display size using expected dimensions from column name
                        // Pass orientation to adjust max sizes for side-by-side layout
                        const size = calculateDisplaySize(
                            expectedDimensions ? expectedDimensions.width : null,
                            expectedDimensions ? expectedDimensions.height : null,
                            naturalWidth,
                            naturalHeight,
                            imageOrientation === 'vertical' // true if side-by-side layout
                        );
                        displayWidth = size.width;
                        displayHeight = size.height;
                        
                        // Set wrapper size
                        wrapper1.style.width = displayWidth + 'px';
                        wrapper1.style.height = displayHeight + 'px';
                        
                        imagesLoaded++;
                        setLayoutIfReady();
                    };
                    
                    wrapper1.appendChild(img1);
                    container1.appendChild(name1);
                    container1.appendChild(columns1);
                    container1.appendChild(wrapper1);
                    
                    // Sheet 2 container
                    const container2 = document.createElement('div');
                    container2.className = 'image-container';
                    
                    const name2 = document.createElement('div');
                    name2.className = 'image-name';
                    name2.innerHTML = `<strong>Sheet 2</strong><br>${image.name || 'Image'}`;
                    
                    // Show only first column from Sheet 2
                    const columns2 = document.createElement('div');
                    columns2.className = 'image-columns';
                    columns2.style.cssText = 'font-size: 0.85rem; color: #666; margin-top: 5px; font-style: italic;';
                    if (image.sheet2Columns && image.sheet2Columns.length > 0) {
                        columns2.textContent = `Column: ${image.sheet2Columns[0]}`;
                    } else {
                        columns2.textContent = 'Column: Unknown';
                    }
                    
                    const wrapper2 = document.createElement('div');
                    wrapper2.className = 'image-wrapper';
                    
                    // Check if filename contains "_white_" and set black background
                    if (image.url && image.url.toLowerCase().includes('_white_')) {
                        wrapper2.classList.add('white-image-bg');
                    }
                    
                    const img2 = document.createElement('img');
                    img2.src = image.url;
                    img2.alt = image.name;
                    img2.onerror = function() {
                        this.parentElement.innerHTML = '<div style="color: #999; padding: 20px;">Failed to load image</div>';
                    };
                    
                    img2.onload = function() {
                        const naturalWidth = this.naturalWidth;
                        const naturalHeight = this.naturalHeight;
                        
                        // Calculate display size (use same as img1 if already calculated, otherwise calculate)
                        let size;
                        if (displayWidth !== null && displayHeight !== null) {
                            size = { width: displayWidth, height: displayHeight };
                        } else {
                            // Determine orientation first if not set
                            let tempWidth = expectedDimensions ? expectedDimensions.width : naturalWidth;
                            let tempHeight = expectedDimensions ? expectedDimensions.height : naturalHeight;
                            if (imageOrientation === null) {
                                imageOrientation = tempWidth > tempHeight ? 'horizontal' : 'vertical';
                            }
                            
                            size = calculateDisplaySize(
                                expectedDimensions ? expectedDimensions.width : null,
                                expectedDimensions ? expectedDimensions.height : null,
                                naturalWidth,
                                naturalHeight,
                                imageOrientation === 'vertical' // true if side-by-side layout
                            );
                            displayWidth = size.width;
                            displayHeight = size.height;
                        }
                        
                        // Set wrapper size
                        wrapper2.style.width = size.width + 'px';
                        wrapper2.style.height = size.height + 'px';
                        
                        imagesLoaded++;
                        setLayoutIfReady();
                    };
                    
                    wrapper2.appendChild(img2);
                    container2.appendChild(name2);
                    container2.appendChild(columns2);
                    container2.appendChild(wrapper2);
                    
                    imagePair.appendChild(container1);
                    imagePair.appendChild(container2);
                    imagesGrid.appendChild(imagePair);
                });
            }

            // Find Blank Space functionality
            let currentWorkbook = null;
            let currentSheetType = null;
            let currentSheetFile = null;
            let currentSheetValue = null;
            let blankCells = [];

            const blankSpaceDropdown = document.getElementById('blank-space-sheet-type');
            const blankSpaceInput = document.getElementById('blank-space-input');
            const blankSpaceValueInput = document.getElementById('blank-space-value');
            const blankSpaceLabel = document.getElementById('blank-space-label');
            
            blankSpaceDropdown.addEventListener('change', function() {
                if (this.value) {
                    blankSpaceInput.classList.add('active');
                    if (this.value === 'excel-csv') {
                        blankSpaceValueInput.type = 'file';
                        blankSpaceValueInput.accept = '.xlsx,.xls,.csv';
                        blankSpaceValueInput.placeholder = '';
                        blankSpaceLabel.textContent = 'Select file';
                    } else if (this.value === 'gsheet') {
                        blankSpaceValueInput.type = 'text';
                        blankSpaceValueInput.placeholder = 'Enter GSheet URL';
                        blankSpaceLabel.textContent = 'Enter GSheet URL';
                    }
                } else {
                    blankSpaceInput.classList.remove('active');
                    blankSpaceValueInput.value = '';
                    blankSpaceValueInput.type = 'text';
                }
            });

            // Find Blank Space button functionality
            const findBlankSpaceButton = document.getElementById('find-blank-space-btn');
            const blankSpaceResultsSection = document.getElementById('blank-space-results-section');
            const blankSpaceLoadingMessage = document.getElementById('blank-space-loading-message');
            const blankSpaceErrorMessage = document.getElementById('blank-space-error-message');
            const blankSpaceNoResults = document.getElementById('blank-space-no-results');
            const blankSpaceResults = document.getElementById('blank-space-results');
            const blankSpaceResultsCount = document.getElementById('blank-space-results-count');
            const blankSpaceDownloadContainer = document.getElementById('blank-space-download-container');
            const downloadHighlightedFileBtn = document.getElementById('download-highlighted-file-btn');

            findBlankSpaceButton.addEventListener('click', async function() {
                // Reset UI
                blankSpaceResultsSection.classList.remove('active');
                blankSpaceLoadingMessage.style.display = 'none';
                blankSpaceErrorMessage.style.display = 'none';
                blankSpaceNoResults.style.display = 'none';
                blankSpaceResults.innerHTML = '';
                blankSpaceResultsCount.textContent = '';
                blankSpaceDownloadContainer.style.display = 'none';
                downloadHighlightedFileBtn.style.display = 'none';
                currentWorkbook = null;
                blankCells = [];

                // Validate inputs
                const sheetType = blankSpaceDropdown.value;
                const sheetValue = blankSpaceValueInput.value;
                const sheetFile = blankSpaceValueInput.files && blankSpaceValueInput.files[0];

                if (!sheetType) {
                    showBlankSpaceError('Please select a sheet type.');
                    return;
                }

                if ((sheetType === 'gsheet' && !sheetValue) || (sheetType === 'excel-csv' && !sheetFile)) {
                    showBlankSpaceError('Please provide a value for the sheet.');
                    return;
                }

                // Show loading and results section
                blankSpaceResultsSection.classList.add('active');
                blankSpaceLoadingMessage.style.display = 'block';
                findBlankSpaceButton.disabled = true;

                try {
                    if (sheetType === 'excel-csv') {
                        // Read Excel/CSV file
                        const result = await readExcelFileWithWorkbook(sheetFile);
                        currentSheetFile = sheetFile;
                        currentWorkbook = result.workbook;
                        currentSheetType = sheetType;

                        // Process all sheets in the workbook (similar to GSheet)
                        const allSheetNames = currentWorkbook.SheetNames;
                        
                        if (allSheetNames.length > 1) {
                            // Process all sheets independently
                            console.log(`Processing ${allSheetNames.length} sheets independently:`, allSheetNames);
                            
                            let allBlankSpaces = [];
                            let totalBlankCells = 0;
                            const sheetResults = [];

                            // Process each sheet separately
                            for (const sheetName of allSheetNames) {
                                try {
                                    console.log(`Reading sheet: ${sheetName}`);
                                    
                                    // Read this specific sheet
                                    const worksheet = currentWorkbook.Sheets[sheetName];
                                    const sheetData = XLSX.utils.sheet_to_json(worksheet, { header: 1, defval: null });
                                    
                                    // Find blank spaces in this sheet
                                    const sheetBlankSpaces = findBlankSpaces(sheetData);
                                    
                                    // Extract individual blank cells from the blankSpaces structure
                                    const sheetBlankCells = [];
                                    sheetBlankSpaces.forEach(space => {
                                        space.blankCells.forEach(cell => {
                                            sheetBlankCells.push({
                                                ...cell,
                                                sheetName: sheetName,
                                                sheetId: allSheetNames.indexOf(sheetName) // Use index as sheetId
                                            });
                                        });
                                    });
                                    
                                    if (sheetBlankCells.length > 0) {
                                        sheetResults.push({
                                            sheetName: sheetName,
                                            sheetId: allSheetNames.indexOf(sheetName),
                                            blankSpaces: sheetBlankSpaces,
                                            blankCells: sheetBlankCells,
                                            data: sheetData
                                        });
                                        totalBlankCells += sheetBlankCells.length;
                                        allBlankSpaces = allBlankSpaces.concat(sheetBlankCells);
                                        console.log(`  â†’ Stored ${sheetBlankCells.length} blank cells for "${sheetName}"`);
                                    } else {
                                        console.log(`  â†’ No blank cells found in "${sheetName}"`);
                                    }
                                    
                                    console.log(`âœ“ Completed reading sheet "${sheetName}": Found ${sheetBlankCells.length} blank cells`);
                                } catch (sheetError) {
                                    console.error(`Error processing sheet "${sheetName}":`, sheetError);
                                    // Continue with other sheets
                                }
                            }

                            // Store blank cells for highlighting
                            blankCells = allBlankSpaces;
                            
                            // Display combined results
                            blankSpaceLoadingMessage.style.display = 'none';
                            
                            if (totalBlankCells === 0) {
                                const noResults = document.getElementById('blank-space-no-results');
                                if (noResults) {
                                    noResults.style.display = 'block';
                                    noResults.textContent = `No blank spaces found across ${allSheetNames.length} sheet(s).`;
                                }
                            } else {
                                // Display summary of all sheets (using a dummy spreadsheetId for Excel files)
                                displayBlankSpaceResultsForAllSheets(sheetResults, 'excel-file');
                            }
                            
                            // Show download button for local files
                            if (blankCells.length > 0) {
                                blankSpaceDownloadContainer.style.display = 'block';
                                downloadHighlightedFileBtn.style.display = 'inline-block';
                            }
                        } else {
                            // Single sheet - process normally
                            const blankSpaces = findBlankSpaces(result.data);

                            // Convert to JSON for display
                            const sheetName = currentWorkbook.SheetNames[0];
                            const worksheet = currentWorkbook.Sheets[sheetName];
                            const jsonData = XLSX.utils.sheet_to_json(worksheet);

                            // Display results
                            blankSpaceLoadingMessage.style.display = 'none';
                            displayBlankSpaceResults(blankSpaces, jsonData, sheetType);
                            
                            // Show download button for local files
                            blankSpaceDownloadContainer.style.display = 'block';
                            downloadHighlightedFileBtn.style.display = 'inline-block';
                        }
                    } else if (sheetType === 'gsheet') {
                        // Read Google Sheet
                        const result = await readGoogleSheetWithWorkbook(sheetValue);
                        currentSheetValue = sheetValue;
                        currentSheetType = sheetType;
                        const spreadsheetId = result.sheetId;
                        const processAllSheets = result.processAllSheets === true;

                        if (processAllSheets) {
                            // Process all sheets independently
                            const allSheets = await getAllSheets(spreadsheetId);
                            if (allSheets.length === 0) {
                                throw new Error('Could not retrieve sheet list. Please specify a specific sheet in the URL (add #gid=XXX to the URL).');
                            }

                            console.log(`Processing ${allSheets.length} sheets independently:`, allSheets.map(s => s.title));
                            
                            let allBlankSpaces = [];
                            let totalBlankCells = 0;
                            const sheetResults = [];

                            // Process each sheet separately
                            for (const sheet of allSheets) {
                                try {
                                    console.log(`Reading sheet: ${sheet.title} (gid: ${sheet.sheetId})`);
                                    
                                    // Read this specific sheet
                                    const sheetUrl = `https://docs.google.com/spreadsheets/d/${spreadsheetId}/export?format=csv&gid=${sheet.sheetId}`;
                                    const sheetResult = await readGoogleSheetCSV(sheetUrl);
                                    
                                    // Find blank spaces in this sheet
                                    const sheetBlankSpaces = findBlankSpaces(sheetResult.data);
                                    
                                    // Extract individual blank cells from the blankSpaces structure
                                    const sheetBlankCells = [];
                                    sheetBlankSpaces.forEach(space => {
                                        space.blankCells.forEach(cell => {
                                            sheetBlankCells.push({
                                                ...cell,
                                                sheetName: sheet.title,
                                                sheetId: parseInt(sheet.sheetId) // Store as integer for matching
                                            });
                                        });
                                    });
                                    
                                    if (sheetBlankCells.length > 0) {
                                        sheetResults.push({
                                            sheetName: sheet.title,
                                            sheetId: sheet.sheetId,
                                            blankSpaces: sheetBlankSpaces,
                                            blankCells: sheetBlankCells,
                                            data: sheetResult.data
                                        });
                                        totalBlankCells += sheetBlankCells.length;
                                        allBlankSpaces = allBlankSpaces.concat(sheetBlankCells);
                                        console.log(`  â†’ Stored ${sheetBlankCells.length} blank cells for "${sheet.title}" with sheetId: ${parseInt(sheet.sheetId)}`);
                                    } else {
                                        console.log(`  â†’ No blank cells found in "${sheet.title}"`);
                                    }
                                    
                                    console.log(`âœ“ Completed reading sheet "${sheet.title}": Found ${sheetBlankCells.length} blank cells`);
                                } catch (sheetError) {
                                    console.error(`Error processing sheet "${sheet.title}":`, sheetError);
                                    // Continue with other sheets
                                }
                            }

                            // Store blank cells for highlighting (will be used per sheet)
                            blankCells = allBlankSpaces;
                            
                            // Log summary of blank cells found per sheet
                            console.log(`\n=== Summary of Blank Cells Found ===`);
                            console.log(`Total sheets processed: ${allSheets.length}`);
                            console.log(`Total blank cells found: ${blankCells.length}`);
                            const blankCellsBySheet = {};
                            blankCells.forEach(cell => {
                                const sid = cell.sheetId;
                                if (!blankCellsBySheet[sid]) {
                                    blankCellsBySheet[sid] = { count: 0, sheetName: cell.sheetName };
                                }
                                blankCellsBySheet[sid].count++;
                            });
                            Object.keys(blankCellsBySheet).forEach(sid => {
                                const info = blankCellsBySheet[sid];
                                console.log(`  Sheet "${info.sheetName}" (gid: ${sid}): ${info.count} blank cells`);
                            });
                            console.log(`=====================================\n`);
                            
                            // Display combined results
                            blankSpaceLoadingMessage.style.display = 'none';
                            
                            if (totalBlankCells === 0) {
                                const noResults = document.getElementById('blank-space-no-results');
                                if (noResults) {
                                    noResults.style.display = 'block';
                                    noResults.textContent = `No blank spaces found across ${allSheets.length} sheet(s).`;
                                }
                            } else {
                                // Display summary of all sheets
                                displayBlankSpaceResultsForAllSheets(sheetResults, spreadsheetId);
                            }
                            
                            // Show button to highlight all sheets
                            if (blankCells.length > 0) {
                                blankSpaceDownloadContainer.style.display = 'block';
                                showGSheetHighlightButton();
                            }
                        } else {
                            // Process single sheet (existing behavior)
                            currentWorkbook = result.workbook;
                            
                            // Find blank spaces (using raw data array)
                            // Note: findBlankSpaces also sets the global blankCells array
                            const blankSpaces = findBlankSpaces(result.data);
                            
                            console.log(`Single sheet: Found ${blankCells.length} blank cells`);

                            // Convert to JSON for display
                            const sheetName = currentWorkbook.SheetNames[0];
                            const worksheet = currentWorkbook.Sheets[sheetName];
                            const jsonData = XLSX.utils.sheet_to_json(worksheet);

                            // Display results
                            blankSpaceLoadingMessage.style.display = 'none';
                            displayBlankSpaceResults(blankSpaces, jsonData, sheetType);
                            
                            // For GSheet, show button to highlight in Google Sheets
                            if (blankCells.length > 0) {
                                blankSpaceDownloadContainer.style.display = 'block';
                                showGSheetHighlightButton();
                            }
                        }
                    }
                } catch (error) {
                    blankSpaceLoadingMessage.style.display = 'none';
                    showBlankSpaceError('Error processing sheet: ' + error.message);
                    console.error('Error:', error);
                } finally {
                    findBlankSpaceButton.disabled = false;
                }
            });

            // Download highlighted file
            downloadHighlightedFileBtn.addEventListener('click', async function() {
                if (!blankCells || blankCells.length === 0) {
                    showBlankSpaceError('No blank cells found to highlight.');
                    return;
                }

                if (typeof ExcelJS === 'undefined') {
                    showBlankSpaceError('ExcelJS library not loaded. Please refresh the page.');
                    return;
                }

                downloadHighlightedFileBtn.disabled = true;
                downloadHighlightedFileBtn.textContent = 'Generating...';

                try {
                    let excelWorkbook = new ExcelJS.Workbook();
                    
                    // Check if we're processing multiple sheets (blankCells have sheetId property)
                    const hasMultipleSheets = blankCells.length > 0 && blankCells[0].sheetId !== undefined;
                    const allSheetNames = currentWorkbook ? currentWorkbook.SheetNames : [];
                    
                    // If it's a local Excel file (.xlsx), read it directly with ExcelJS
                    if (currentSheetType === 'excel-csv' && currentSheetFile) {
                        const fileName = currentSheetFile.name.toLowerCase();
                        if (fileName.endsWith('.xlsx')) {
                            try {
                                const arrayBuffer = await currentSheetFile.arrayBuffer();
                                await excelWorkbook.xlsx.load(arrayBuffer);
                            } catch (err) {
                                // If loading fails, create from data
                                console.warn('Could not load file with ExcelJS, creating from data:', err);
                                
                                // Create all sheets from workbook data
                                allSheetNames.forEach((sheetName, sheetIndex) => {
                                    const worksheet = currentWorkbook.Sheets[sheetName];
                                    const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, defval: '' });
                                    
                                    const excelWorksheet = excelWorkbook.addWorksheet(sheetName);
                                    
                                    jsonData.forEach((row, rowIndex) => {
                                        const excelRow = excelWorksheet.getRow(rowIndex + 1);
                                        row.forEach((cellValue, colIndex) => {
                                            const cell = excelRow.getCell(colIndex + 1);
                                            if (cellValue !== null && cellValue !== undefined && cellValue !== '') {
                                                cell.value = cellValue;
                                            }
                                        });
                                    });
                                });
                            }
                        } else {
                            // For CSV files, create new workbook from data (CSV only has one sheet)
                            const sheetName = currentWorkbook.SheetNames[0];
                            const worksheet = currentWorkbook.Sheets[sheetName];
                            const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, defval: '' });
                            
                            const excelWorksheet = excelWorkbook.addWorksheet(sheetName);
                            
                            // Add data to worksheet - explicitly set all cells including blanks
                            jsonData.forEach((row, rowIndex) => {
                                const excelRow = excelWorksheet.getRow(rowIndex + 1);
                                row.forEach((cellValue, colIndex) => {
                                    const cell = excelRow.getCell(colIndex + 1);
                                    // Explicitly set value, even if empty
                                    if (cellValue !== null && cellValue !== undefined && cellValue !== '') {
                                        cell.value = cellValue;
                                    } else {
                                        cell.value = ''; // Explicitly set empty string for blank cells
                                    }
                                });
                            });
                        }
                    } else {
                        // For Google Sheets, create new workbook from data
                        // Process all sheets if multiple sheets exist
                        allSheetNames.forEach((sheetName) => {
                            const worksheet = currentWorkbook.Sheets[sheetName];
                            const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, defval: '' });
                            
                            const excelWorksheet = excelWorkbook.addWorksheet(sheetName);
                            
                            // Add data to worksheet - explicitly set all cells including blanks
                            jsonData.forEach((row, rowIndex) => {
                                const excelRow = excelWorksheet.getRow(rowIndex + 1);
                                row.forEach((cellValue, colIndex) => {
                                    const cell = excelRow.getCell(colIndex + 1);
                                    // Explicitly set value, even if empty
                                    if (cellValue !== null && cellValue !== undefined && cellValue !== '') {
                                        cell.value = cellValue;
                                    } else {
                                        cell.value = ''; // Explicitly set empty string for blank cells
                                    }
                                });
                            });
                        });
                    }
                    
                    // Apply yellow highlight to blank cells
                    console.log(`Highlighting ${blankCells.length} blank cells`);
                    
                    if (hasMultipleSheets && allSheetNames.length > 1) {
                        // Process each sheet separately
                        allSheetNames.forEach((sheetName, sheetIndex) => {
                            const excelWorksheet = excelWorkbook.getWorksheet(sheetName) || excelWorkbook.worksheets[sheetIndex];
                            if (!excelWorksheet) return;
                            
                            // Filter blank cells for this specific sheet
                            const sheetBlankCells = blankCells.filter(cell => cell.sheetId === sheetIndex);
                            
                            console.log(`Processing sheet "${sheetName}": ${sheetBlankCells.length} blank cells`);
                            
                            sheetBlankCells.forEach(cell => {
                                try {
                                    const row = excelWorksheet.getRow(cell.row);
                                    const excelCell = row.getCell(cell.col + 1);
                                    
                                    // Ensure cell exists and is initialized
                                    if (!excelCell.value && excelCell.value !== 0) {
                                        excelCell.value = '';
                                    }
                                    
                                    // Check if cell is actually blank (null, undefined, or empty string)
                                    const cellValue = excelCell.value;
                                    const isBlank = cellValue === null || cellValue === undefined || cellValue === '';
                                    
                                    if (isBlank) {
                                        // Set fill with yellow background - using ARGB format like the reference code
                                        excelCell.fill = {
                                            type: 'pattern',
                                            pattern: 'solid',
                                            fgColor: { argb: 'FFFFFF00' } // Yellow: FF (alpha) FFFF00 (yellow RGB)
                                        };
                                        
                                        // Ensure cell value is explicitly set to empty string
                                        excelCell.value = '';
                                        
                                        console.log(`Highlighted blank cell at row ${cell.row}, col ${cell.col + 1} in "${sheetName}"`);
                                    }
                                } catch (err) {
                                    console.error(`Could not highlight cell at row ${cell.row}, col ${cell.col + 1} in "${sheetName}":`, err);
                                }
                            });
                        });
                    } else {
                        // Single sheet processing
                        const excelWorksheet = excelWorkbook.worksheets[0];
                        
                        blankCells.forEach(cell => {
                            try {
                                const row = excelWorksheet.getRow(cell.row);
                                const excelCell = row.getCell(cell.col + 1);
                                
                                // Ensure cell exists and is initialized
                                if (!excelCell.value && excelCell.value !== 0) {
                                    excelCell.value = '';
                                }
                                
                                // Check if cell is actually blank (null, undefined, or empty string)
                                const cellValue = excelCell.value;
                                const isBlank = cellValue === null || cellValue === undefined || cellValue === '';
                                
                                if (isBlank) {
                                    // Set fill with yellow background - using ARGB format like the reference code
                                    excelCell.fill = {
                                        type: 'pattern',
                                        pattern: 'solid',
                                        fgColor: { argb: 'FFFFFF00' } // Yellow: FF (alpha) FFFF00 (yellow RGB)
                                    };
                                    
                                    // Ensure cell value is explicitly set to empty string
                                    excelCell.value = '';
                                    
                                    console.log(`Highlighted blank cell at row ${cell.row}, col ${cell.col + 1}, value: "${excelCell.value}"`);
                                } else {
                                    console.log(`Cell at row ${cell.row}, col ${cell.col + 1} is not blank, value: "${cellValue}"`);
                                }
                            } catch (err) {
                                console.error(`Could not highlight cell at row ${cell.row}, col ${cell.col + 1}:`, err);
                            }
                        });
                    }
                    
                    // Generate file
                    const buffer = await excelWorkbook.xlsx.writeBuffer();
                    const blob = new Blob([buffer], { 
                        type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' 
                    });
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = currentSheetType === 'excel-csv' 
                        ? currentSheetFile.name.replace(/\.(xlsx|xls|csv)$/i, '_highlighted.xlsx')
                        : 'highlighted_sheet.xlsx';
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    URL.revokeObjectURL(url);
                } catch (error) {
                    showBlankSpaceError('Error downloading file: ' + error.message);
                    console.error('Error:', error);
                } finally {
                    downloadHighlightedFileBtn.disabled = false;
                    downloadHighlightedFileBtn.textContent = 'Download Highlighted File';
                }
            });

            function showBlankSpaceError(message) {
                blankSpaceResultsSection.classList.add('active');
                blankSpaceErrorMessage.textContent = message;
                blankSpaceErrorMessage.style.display = 'block';
            }

            function findBlankSpaces(data) {
                const blankSpaces = [];
                const localBlankCells = []; // Use local variable to avoid global state issues
                
                if (!data || data.length === 0) {
                    return blankSpaces;
                }

                // First row contains headers
                const headers = data[0] || [];
                let totalCellsChecked = 0;
                let blankCellsFound = 0;
                
                // Check each row (skip header row)
                for (let rowIndex = 1; rowIndex < data.length; rowIndex++) {
                    const row = data[rowIndex] || [];
                    const blankCellsInRow = [];
                    
                    // Check each column
                    for (let colIndex = 0; colIndex < Math.max(headers.length, row.length); colIndex++) {
                        totalCellsChecked++;
                        const cellValue = row[colIndex];
                        
                        // Check if cell is truly blank (null, undefined, or empty string - ignore whitespace)
                        // Also check if it's a string with only whitespace
                        let isBlank = false;
                        if (cellValue === null || cellValue === undefined) {
                            isBlank = true;
                        } else if (typeof cellValue === 'string') {
                            // Empty string or only whitespace
                            isBlank = cellValue.trim() === '';
                        } else if (cellValue === '') {
                            isBlank = true;
                        }
                        
                        if (isBlank) {
                            blankCellsFound++;
                            const columnName = headers[colIndex] || `Column${colIndex + 1}`;
                            blankCellsInRow.push({
                                column: columnName,
                                row: rowIndex + 1, // +1 because we're 0-based but Excel is 1-based
                                col: colIndex
                            });
                            localBlankCells.push({
                                column: columnName,
                                row: rowIndex + 1,
                                col: colIndex
                            });
                        }
                    }
                    
                    if (blankCellsInRow.length > 0) {
                        blankSpaces.push({
                            row: rowIndex + 1,
                            blankCells: blankCellsInRow
                        });
                    }
                }

                console.log(`findBlankSpaces: Checked ${totalCellsChecked} cells, found ${blankCellsFound} blank cells`);
                
                // Update global blankCells array
                blankCells = localBlankCells;
                
                return blankSpaces;
            }

            async function readExcelFileWithWorkbook(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        try {
                            const data = new Uint8Array(e.target.result);
                            const workbook = XLSX.read(data, { type: 'array' });
                            const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
                            const jsonData = XLSX.utils.sheet_to_json(firstSheet, { header: 1, defval: null });
                            resolve({ data: jsonData, workbook: workbook });
                        } catch (error) {
                            reject(new Error('Failed to parse Excel/CSV file: ' + error.message));
                        }
                    };
                    reader.onerror = () => reject(new Error('Failed to read file'));
                    reader.readAsArrayBuffer(file);
                });
            }

            async function readGoogleSheetWithWorkbook(url) {
                try {
                    // Clean and validate URL
                    url = url.trim();
                    
                    // Extract sheet ID and gid (tab ID) from URL
                    let sheetId = null;
                    let gid = null; // Will be set if found in URL, null means process all sheets
                    
                    // Extract gid from URL (can be in query string, hash, or as a path parameter)
                    // Try multiple patterns to catch different URL formats
                    const gidPatterns = [
                        /[?&#]gid=(\d+)/,  // Standard: ?gid=123 or #gid=123
                        /\/gid\/(\d+)/,     // Alternative: /gid/123
                        /[?&]tab=(\d+)/     // Some formats use tab= instead of gid=
                    ];
                    
                    for (const pattern of gidPatterns) {
                        const match = url.match(pattern);
                        if (match) {
                            gid = match[1];
                            break;
                        }
                    }
                    
                    // Check if URL is already a CSV export URL
                    if (url.includes('/export?format=csv')) {
                        // Extract gid from existing export URL
                        const exportGidMatch = url.match(/[?&]gid=(\d+)/);
                        if (exportGidMatch) {
                            gid = exportGidMatch[1];
                        }
                        // Extract sheet ID from export URL
                        const exportSheetMatch = url.match(/\/spreadsheets\/d\/([a-zA-Z0-9-_]+)/);
                        if (exportSheetMatch) {
                            sheetId = exportSheetMatch[1];
                            var csvUrl = url;
                        }
                    } else {
                        // Extract sheet ID from various Google Sheets URL formats
                        // Format 1: https://docs.google.com/spreadsheets/d/SHEET_ID/edit
                        const match1 = url.match(/\/spreadsheets\/d\/([a-zA-Z0-9-_]+)/);
                        if (match1) {
                            sheetId = match1[1];
                        }
                        
                        // Format 2: https://docs.google.com/spreadsheets/d/SHEET_ID/edit#gid=0
                        if (!sheetId) {
                            const match2 = url.match(/\/d\/([a-zA-Z0-9-_]+)/);
                            if (match2) {
                                sheetId = match2[1];
                            }
                        }
                        
                        // Format 3: Just the sheet ID
                        if (!sheetId && /^[a-zA-Z0-9-_]+$/.test(url)) {
                            sheetId = url;
                        }
                        
                        // Format 4: Try to extract from share URL format
                        if (!sheetId) {
                            const match3 = url.match(/\/spreadsheets\/d\/([a-zA-Z0-9-_]{44})/);
                            if (match3) {
                                sheetId = match3[1];
                            }
                        }
                        
                        if (!sheetId) {
                            throw new Error('Invalid Google Sheets URL. Please provide a valid Google Sheets URL or Sheet ID. Make sure to copy the full URL from the address bar or use the "Share" link.');
                        }
                        
                        // If no gid specified, we'll need to get all sheets
                        // For now, construct CSV export URL - if gid is null, default to first sheet for initial read
                        const gidForUrl = gid || '0';
                        csvUrl = `https://docs.google.com/spreadsheets/d/${sheetId}/export?format=csv&gid=${gidForUrl}`;
                        console.log('Constructed CSV URL:', csvUrl);
                        console.log('Sheet ID:', sheetId, 'GID:', gid || 'ALL SHEETS (will process all)');
                    }
                    
                    // Store gid for later use in highlighting (null means process all sheets)
                    window.currentGSheetId = sheetId;
                    window.currentGSheetGid = gid;
                    window.currentGSheetProcessAll = gid === null;
                    window.currentGSheetUrl = url;
                    
                    console.log('Fetching Google Sheet from:', csvUrl);
                    console.log('Sheet ID:', sheetId, 'GID:', gid);
                    
                    // Try to fetch directly first
                    let response;
                    let csvText;
                    
                    try {
                        // Create a timeout promise (30 seconds)
                        const timeoutPromise = new Promise((_, reject) => 
                            setTimeout(() => reject(new Error('Request timeout after 30 seconds')), 30000)
                        );
                        
                        // Race between fetch and timeout
                        response = await Promise.race([
                            fetch(csvUrl, {
                                method: 'GET',
                                mode: 'cors',
                                headers: {
                                    'Accept': 'text/csv'
                                }
                            }),
                            timeoutPromise
                        ]);
                        
                        if (!response.ok) {
                            if (response.status === 403) {
                                throw new Error('Access denied. Please make sure the Google Sheet is shared with "Anyone with the link" can view. Go to Share â†’ Change to "Anyone with the link" â†’ Viewer.');
                            } else if (response.status === 404) {
                                throw new Error('Google Sheet not found. Please check the URL or Sheet ID. Make sure you copied the complete URL.');
                            } else {
                                throw new Error(`Failed to fetch Google Sheet (Status: ${response.status}). Make sure the sheet is publicly accessible.`);
                            }
                        }
                        
                        csvText = await response.text();
                        
                        // Check if we got HTML instead of CSV (common when sheet is not public)
                        if (csvText.includes('<!DOCTYPE') || csvText.includes('<html') || csvText.includes('Sign in')) {
                            throw new Error('Received HTML instead of CSV. The sheet may not be publicly accessible. Please ensure it is shared with "Anyone with the link" can view.');
                        }
                    } catch (fetchError) {
                        // If direct fetch fails (likely CORS), try using CORS proxies
                        console.log('Direct fetch failed, trying CORS proxies...', fetchError);
                        
                        // List of CORS proxy services to try
                        const proxies = [
                            `https://api.allorigins.win/raw?url=${encodeURIComponent(csvUrl)}`,
                            `https://corsproxy.io/?${encodeURIComponent(csvUrl)}`,
                            `https://api.codetabs.com/v1/proxy?quest=${encodeURIComponent(csvUrl)}`
                        ];
                        
                        let lastError = fetchError;
                        let success = false;
                        
                        // Try each proxy in sequence
                        for (let i = 0; i < proxies.length; i++) {
                            try {
                                console.log(`Trying proxy ${i + 1}/${proxies.length}...`);
                                
                                // Create timeout for proxy request
                                const proxyTimeout = new Promise((_, reject) => 
                                    setTimeout(() => reject(new Error('Proxy request timeout')), 30000)
                                );
                                
                                response = await Promise.race([
                                    fetch(proxies[i], {
                                        method: 'GET',
                                        mode: 'cors',
                                        headers: {
                                            'Accept': 'text/csv'
                                        }
                                    }),
                                    proxyTimeout
                                ]);
                                
                                if (!response.ok) {
                                    throw new Error(`Proxy ${i + 1} failed with status ${response.status}`);
                                }
                                
                                csvText = await response.text();
                                
                                // Validate that we got CSV data
                                if (csvText && csvText.trim().length > 0 && !csvText.includes('<!DOCTYPE') && !csvText.includes('<html') && !csvText.includes('Sign in')) {
                                    console.log(`Successfully fetched via proxy ${i + 1}`);
                                    success = true;
                                    break;
                                } else {
                                    throw new Error('Proxy returned invalid data (HTML instead of CSV). Sheet may not be publicly accessible.');
                                }
                            } catch (proxyError) {
                                console.log(`Proxy ${i + 1} failed:`, proxyError.message);
                                lastError = proxyError;
                                // Continue to next proxy
                            }
                        }
                        
                        if (!success) {
                            // All proxies failed, provide detailed error message
                            const errorDetails = lastError.message || fetchError.message;
                            throw new Error(`Failed to fetch Google Sheet after trying multiple methods. Error: ${errorDetails}. Please ensure: 1) The sheet is shared with "Anyone with the link" can view, 2) You are using a valid Google Sheets URL (try copying the "Share" link), 3) As an alternative, download the sheet as CSV manually and upload it as a file instead.`);
                        }
                    }
                    
                    if (!csvText || csvText.trim().length === 0) {
                        throw new Error('Google Sheet appears to be empty or could not be read.');
                    }
                    
                    const workbook = XLSX.read(csvText, { type: 'string' });
                    const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
                    const jsonData = XLSX.utils.sheet_to_json(firstSheet, { header: 1, defval: null });
                    return { 
                        data: jsonData, 
                        workbook: workbook,
                        sheetId: sheetId,
                        gid: gid,
                        url: url,
                        processAllSheets: gid === null
                    };
                } catch (error) {
                    // Provide more helpful error messages
                    if (error.message.includes('Failed to fetch') || error.message.includes('CORS') || error.message.includes('network')) {
                        throw new Error('Failed to fetch Google Sheet. This might be due to CORS restrictions or network issues. Please ensure: 1) The sheet is shared with "Anyone with the link" can view, 2) You are using a valid Google Sheets URL, 3) Try copying the "Share" link from Google Sheets, 4) As an alternative, download the sheet as CSV manually and upload it as a file instead.');
                    }
                    throw new Error('Failed to read Google Sheet: ' + error.message);
                }
            }

            function highlightBlankCells(workbook, blankCells) {
                if (!workbook || !workbook.SheetNames || workbook.SheetNames.length === 0) {
                    return;
                }

                const sheetName = workbook.SheetNames[0];
                const worksheet = workbook.Sheets[sheetName];

                // Initialize styles array if it doesn't exist
                if (!workbook.Styles) {
                    workbook.Styles = {
                        fills: [
                            { fgColor: { rgb: 'FFFFFFFF' } }, // Default fill (white)
                            { fgColor: { rgb: 'FFFF00' } }   // Yellow fill (index 1)
                        ],
                        fonts: [],
                        borders: [],
                        alignment: []
                    };
                } else if (!workbook.Styles.fills) {
                    workbook.Styles.fills = [
                        { fgColor: { rgb: 'FFFFFFFF' } }, // Default fill (white)
                        { fgColor: { rgb: 'FFFF00' } }   // Yellow fill (index 1)
                    ];
                } else {
                    // Check if yellow fill already exists
                    const yellowExists = workbook.Styles.fills.some(fill => 
                        fill.fgColor && fill.fgColor.rgb === 'FFFF00'
                    );
                    if (!yellowExists) {
                        workbook.Styles.fills.push({ fgColor: { rgb: 'FFFF00' } });
                    }
                }

                // Find yellow fill index
                let yellowFillIndex = workbook.Styles.fills.findIndex(fill => 
                    fill.fgColor && fill.fgColor.rgb === 'FFFF00'
                );
                if (yellowFillIndex === -1) {
                    yellowFillIndex = workbook.Styles.fills.length;
                    workbook.Styles.fills.push({ fgColor: { rgb: 'FFFF00' } });
                }

                // Apply yellow background to blank cells
                blankCells.forEach(cell => {
                    const cellAddress = XLSX.utils.encode_cell({ r: cell.row - 1, c: cell.col });
                    
                    if (!worksheet[cellAddress]) {
                        worksheet[cellAddress] = { t: 's', v: '' };
                    }
                    
                    if (!worksheet[cellAddress].s) {
                        worksheet[cellAddress].s = {};
                    }
                    
                    // Set fill using fill index
                    worksheet[cellAddress].s.fill = {
                        fgColor: { rgb: 'FFFF00' },
                        patternType: 'solid'
                    };
                });
            }

            function displayBlankSpaceResults(blankSpaces, jsonData, sheetType) {
                if (blankSpaces.length === 0) {
                    blankSpaceNoResults.style.display = 'block';
                    return;
                }

                const totalBlankCells = blankSpaces.reduce((sum, space) => sum + space.blankCells.length, 0);
                blankSpaceResultsCount.textContent = `Found ${blankSpaces.length} row${blankSpaces.length !== 1 ? 's' : ''} with blank spaces (${totalBlankCells} blank cell${totalBlankCells !== 1 ? 's' : ''})`;

                // Create a table to display results
                const table = document.createElement('table');
                table.style.width = '100%';
                table.style.borderCollapse = 'collapse';
                table.style.marginTop = '20px';
                table.style.backgroundColor = '#fff';
                table.style.borderRadius = '6px';
                table.style.overflow = 'hidden';
                table.style.boxShadow = '0 2px 4px rgba(0, 0, 0, 0.1)';

                // Table header
                const thead = document.createElement('thead');
                thead.style.backgroundColor = '#5612BD';
                thead.style.color = '#fff';
                const headerRow = document.createElement('tr');
                ['Row', 'Column'].forEach(headerText => {
                    const th = document.createElement('th');
                    th.textContent = headerText;
                    th.style.padding = '12px';
                    th.style.textAlign = 'left';
                    th.style.fontWeight = '600';
                    headerRow.appendChild(th);
                });
                thead.appendChild(headerRow);
                table.appendChild(thead);

                // Table body
                const tbody = document.createElement('tbody');
                blankSpaces.forEach(space => {
                    space.blankCells.forEach(cell => {
                        const tr = document.createElement('tr');
                        tr.style.borderBottom = '1px solid #eee';
                        
                        const rowTd = document.createElement('td');
                        rowTd.textContent = space.row;
                        rowTd.style.padding = '10px 12px';
                        tr.appendChild(rowTd);
                        
                        const colTd = document.createElement('td');
                        colTd.textContent = cell.column || getColumnLetter(cell.col);
                        colTd.style.padding = '10px 12px';
                        tr.appendChild(colTd);
                        
                        tbody.appendChild(tr);
                    });
                });
                table.appendChild(tbody);

                blankSpaceResults.appendChild(table);
            }

            function displayBlankSpaceResultsForAllSheets(sheetResults, spreadsheetId) {
                const blankSpaceResults = document.getElementById('blank-space-results');
                blankSpaceResults.innerHTML = '';

                // Calculate totals - count actual blank cells, not rows
                const totalSheets = sheetResults.length;
                const totalBlankCells = sheetResults.reduce((sum, sheet) => {
                    // Count individual blank cells, not rows
                    const cellCount = sheet.blankCells ? sheet.blankCells.length : 
                                    sheet.blankSpaces.reduce((s, space) => s + space.blankCells.length, 0);
                    return sum + cellCount;
                }, 0);
                
                blankSpaceResultsCount.textContent = `Found blank spaces in ${totalSheets} sheet(s): ${totalBlankCells} blank cell${totalBlankCells !== 1 ? 's' : ''} total`;

                // Create summary section
                const summaryDiv = document.createElement('div');
                summaryDiv.style.cssText = 'margin-bottom: 30px; padding: 20px; background: linear-gradient(135deg, rgba(86, 18, 189, 0.1) 0%, rgba(146, 80, 242, 0.1) 100%); border-radius: 12px; border-left: 4px solid #5612BD;';
                summaryDiv.innerHTML = `
                    <h3 style="margin: 0 0 15px 0; color: #250651; font-size: 1.3rem;">Summary</h3>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                        ${sheetResults.map(sheet => {
                            // Count actual blank cells for this sheet
                            const cellCount = sheet.blankCells ? sheet.blankCells.length : 
                                            sheet.blankSpaces.reduce((sum, space) => sum + space.blankCells.length, 0);
                            return `
                            <div style="background: white; padding: 15px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                                <div style="font-weight: 600; color: #5612BD; margin-bottom: 5px;">${sheet.sheetName}</div>
                                <div style="color: #666; font-size: 0.9rem;">${cellCount} blank cell${cellCount !== 1 ? 's' : ''}</div>
                            </div>
                            `;
                        }).join('')}
                    </div>
                `;
                blankSpaceResults.appendChild(summaryDiv);

                // Create a table for all blank cells
                const table = document.createElement('table');
                table.style.width = '100%';
                table.style.borderCollapse = 'collapse';
                table.style.marginTop = '20px';
                table.style.backgroundColor = '#fff';
                table.style.borderRadius = '6px';
                table.style.overflow = 'hidden';
                table.style.boxShadow = '0 2px 4px rgba(0, 0, 0, 0.1)';

                // Table header
                const thead = document.createElement('thead');
                thead.style.backgroundColor = '#5612BD';
                thead.style.color = '#fff';
                const headerRow = document.createElement('tr');
                ['Sheet', 'Row', 'Column'].forEach(headerText => {
                    const th = document.createElement('th');
                    th.textContent = headerText;
                    th.style.padding = '12px';
                    th.style.textAlign = 'left';
                    th.style.fontWeight = '600';
                    headerRow.appendChild(th);
                });
                thead.appendChild(headerRow);
                table.appendChild(thead);

                // Table body - use blankCells which has the column names
                const tbody = document.createElement('tbody');
                sheetResults.forEach(sheetResult => {
                    // Use blankCells if available (preferred), otherwise iterate through blankSpaces
                    if (sheetResult.blankCells && sheetResult.blankCells.length > 0) {
                        // Use blankCells array directly
                        sheetResult.blankCells.forEach(cell => {
                            const tr = document.createElement('tr');
                            tr.style.borderBottom = '1px solid #eee';
                            
                            const sheetTd = document.createElement('td');
                            sheetTd.textContent = sheetResult.sheetName;
                            sheetTd.style.padding = '10px 12px';
                            sheetTd.style.fontWeight = '600';
                            sheetTd.style.color = '#5612BD';
                            tr.appendChild(sheetTd);
                            
                            const rowTd = document.createElement('td');
                            rowTd.textContent = cell.row;
                            rowTd.style.padding = '10px 12px';
                            tr.appendChild(rowTd);
                            
                            const colTd = document.createElement('td');
                            // Use column name from cell, fallback to column letter if not available
                            colTd.textContent = cell.column || getColumnLetter(cell.col);
                            colTd.style.padding = '10px 12px';
                            tr.appendChild(colTd);
                            
                            tbody.appendChild(tr);
                        });
                    } else if (sheetResult.blankSpaces) {
                        // Fallback: iterate through blankSpaces structure
                        sheetResult.blankSpaces.forEach(space => {
                            space.blankCells.forEach(cell => {
                                const tr = document.createElement('tr');
                                tr.style.borderBottom = '1px solid #eee';
                                
                                const sheetTd = document.createElement('td');
                                sheetTd.textContent = sheetResult.sheetName;
                                sheetTd.style.padding = '10px 12px';
                                sheetTd.style.fontWeight = '600';
                                sheetTd.style.color = '#5612BD';
                                tr.appendChild(sheetTd);
                                
                                const rowTd = document.createElement('td');
                                rowTd.textContent = space.row;
                                rowTd.style.padding = '10px 12px';
                                tr.appendChild(rowTd);
                                
                                const colTd = document.createElement('td');
                                // Use column name from cell, fallback to column letter if not available
                                colTd.textContent = cell.column || getColumnLetter(cell.col);
                                colTd.style.padding = '10px 12px';
                                tr.appendChild(colTd);
                                
                                tbody.appendChild(tr);
                            });
                        });
                    }
                });
                table.appendChild(tbody);

                blankSpaceResults.appendChild(table);
            }

            function showGSheetHighlightButton() {
                // Remove existing highlight button if any
                const existingBtn = document.getElementById('highlight-gsheet-btn');
                if (existingBtn) {
                    existingBtn.remove();
                }

                const highlightBtn = document.createElement('button');
                highlightBtn.id = 'highlight-gsheet-btn';
                highlightBtn.className = 'compare-button';
                highlightBtn.textContent = 'Highlight Cells in Google Sheet';
                highlightBtn.style.marginTop = '10px';
                
                highlightBtn.addEventListener('click', function() {
                    highlightGSheetCells();
                });

                blankSpaceDownloadContainer.innerHTML = '';
                blankSpaceDownloadContainer.appendChild(highlightBtn);
            }

            async function highlightGSheetCells() {
                if (!blankCells || blankCells.length === 0) {
                    showBlankSpaceError('No blank cells to highlight.');
                    return;
                }

                if (!window.currentGSheetId) {
                    showBlankSpaceError('Google Sheet information not available.');
                    return;
                }

                const highlightBtn = document.getElementById('highlight-gsheet-btn');
                if (highlightBtn) {
                    highlightBtn.disabled = true;
                    highlightBtn.textContent = 'Highlighting cells...';
                }

                try {
                    const sheetId = window.currentGSheetId;
                    const processAllSheets = window.currentGSheetProcessAll === true;
                    
                    // Validate required data
                    if (!sheetId) {
                        throw new Error('Spreadsheet ID not available');
                    }
                    if (!blankCells || blankCells.length === 0) {
                        throw new Error('No blank cells to highlight');
                    }

                    // If processing all sheets, get the list of all sheets
                    let sheetsToProcess = [];
                    if (processAllSheets) {
                        const allSheets = await getAllSheets(sheetId);
                        if (allSheets.length === 0) {
                            throw new Error('Could not retrieve sheet list. Please specify a specific sheet in the URL (add #gid=XXX to the URL).');
                        }
                        sheetsToProcess = allSheets;
                        console.log(`Processing ${allSheets.length} sheets:`, allSheets.map(s => s.title));
                    } else {
                        const gid = parseInt(window.currentGSheetGid);
                        if (isNaN(gid)) {
                            throw new Error('Sheet ID (gid) not available');
                        }
                        sheetsToProcess = [{ sheetId: gid, title: 'Sheet' }];
                    }
                    
                    // Determine server URL (use localhost if running from file://, otherwise use current origin)
                    const serverUrl = window.location.protocol === 'file:' 
                        ? 'http://localhost:3000' 
                        : window.location.origin;

                    console.log(`Using server URL: ${serverUrl}`);

                    // Process each sheet
                    let totalUpdated = 0;
                    let processedCount = 0;
                    const errors = [];

                    for (let sheetIndex = 0; sheetIndex < sheetsToProcess.length; sheetIndex++) {
                        const sheet = sheetsToProcess[sheetIndex];
                        try {
                            // Ensure gid is a number
                            const gid = parseInt(sheet.sheetId);
                            console.log(`[${sheetIndex + 1}/${sheetsToProcess.length}] Processing sheet: "${sheet.title}" (gid: ${gid}, type: ${typeof gid})`);

                            // Filter blank cells for this specific sheet
                            let sheetBlankCells = blankCells;
                            if (processAllSheets) {
                                // If processing all sheets, filter by sheetId
                                console.log(`  â†’ Filtering blank cells for sheet "${sheet.title}" (gid: ${gid})`);
                                console.log(`  â†’ Total blankCells available: ${blankCells.length}`);
                                
                                // Show unique sheetIds in blankCells
                                const uniqueSheetIds = [...new Set(blankCells.map(c => parseInt(c.sheetId)))];
                                console.log(`  â†’ Unique sheetIds in blankCells:`, uniqueSheetIds);
                                console.log(`  â†’ Looking for gid: ${gid} (type: ${typeof gid})`);
                                
                                sheetBlankCells = blankCells.filter(cell => {
                                    const cellSheetId = parseInt(cell.sheetId);
                                    const matches = cellSheetId === gid;
                                    if (matches) {
                                        console.log(`    âœ“ Match found: cell at row ${cell.row}, col ${cell.col} has sheetId ${cellSheetId}`);
                                    }
                                    return matches;
                                });
                                
                                console.log(`  â†’ Filtered ${sheetBlankCells.length} blank cells for "${sheet.title}" (gid: ${gid}) from total ${blankCells.length} cells`);
                                
                                if (sheetBlankCells.length === 0 && blankCells.length > 0) {
                                    console.warn(`  â†’ âš ï¸  WARNING: No blank cells found for sheet "${sheet.title}" (gid: ${gid}), but ${blankCells.length} total blank cells exist.`);
                                    console.warn(`  â†’ This might indicate a sheetId mismatch. Check if gid ${gid} matches any sheetId in blankCells.`);
                                }
                            }

                            if (sheetBlankCells.length === 0) {
                                console.log(`  â†’ No blank cells found in "${sheet.title}", skipping...`);
                                continue;
                            }

                            // Prepare cell data for this sheet - only blank cells
                            const cellsToHighlight = sheetBlankCells.map(cell => ({
                                rowIndex: cell.row - 1,
                                colIndex: cell.col
                            }));
                            
                            console.log(`  â†’ Highlighting ${cellsToHighlight.length} blank cells in "${sheet.title}"`);
                            if (cellsToHighlight.length > 0) {
                                console.log(`  â†’ Sample cells (first 3):`, cellsToHighlight.slice(0, 3));
                            }
                            
                            if (cellsToHighlight.length === 0) {
                                console.log(`  â†’ No blank cells to highlight in "${sheet.title}"`);
                                continue;
                            }
                            
                            // Validate: Make sure we're not sending too many cells (sanity check)
                            if (cellsToHighlight.length > 10000) {
                                console.warn(`  â†’ Warning: Attempting to highlight ${cellsToHighlight.length} cells. This seems unusually high.`);
                            }

                            // Call Node.js server API for this sheet
                            const requestBody = {
                                spreadsheetId: sheetId,
                                sheetId: gid, // Send as integer
                                cells: cellsToHighlight
                            };
                            
                            console.log(`  â†’ Sending request for "${sheet.title}":`, {
                                spreadsheetId: sheetId,
                                sheetId: gid,
                                cellsCount: cellsToHighlight.length
                            });

                            const response = await fetch(`${serverUrl}/api/highlight-cells`, {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json'
                                },
                                body: JSON.stringify(requestBody)
                            });

                            // Check if response is HTML (error page) instead of JSON
                            const responseText = await response.text();
                            let data;
                            
                            try {
                                // Check if response is HTML (error page)
                                if (responseText.trim().startsWith('<!DOCTYPE') || 
                                    responseText.trim().startsWith('<html') ||
                                    responseText.includes('<!DOCTYPE') ||
                                    responseText.includes('<html')) {
                                    console.error(`  â†’ âŒ Server returned HTML for "${sheet.title}"`);
                                    console.error(`  â†’ Response status: ${response.status}`);
                                    console.error(`  â†’ Response text (first 500 chars):`, responseText.substring(0, 500));
                                    
                                    // Try to extract error message from HTML
                                    const errorMatch = responseText.match(/<title>(.*?)<\/title>/i) || 
                                                      responseText.match(/<h1>(.*?)<\/h1>/i) ||
                                                      responseText.match(/Error[:\s]+(.*?)(?:<|$)/i);
                                    const errorMsg = errorMatch ? errorMatch[1] : 'Unknown server error';
                                    
                                    throw new Error(`Server returned HTML error page: ${errorMsg}. Make sure the Node.js server is running and the /api/highlight-cells endpoint is working.`);
                                }
                                
                                // Try to parse as JSON
                                data = JSON.parse(responseText);
                            } catch (parseError) {
                                console.error(`  â†’ âŒ Failed to parse response for "${sheet.title}":`, parseError);
                                console.error(`  â†’ Response status: ${response.status}`);
                                console.error(`  â†’ Response text (first 500 chars):`, responseText.substring(0, 500));
                                
                                if (parseError.message.includes('HTML')) {
                                    throw parseError; // Re-throw HTML error
                                } else {
                                    throw new Error(`Server returned invalid JSON: ${parseError.message}. Status: ${response.status}. Response: ${responseText.substring(0, 200)}...`);
                                }
                            }
                            
                            console.log(`  â†’ Response for "${sheet.title}":`, {
                                ok: response.ok,
                                status: response.status,
                                updatedCells: data.updatedCells,
                                error: data.error
                            });

                            if (!response.ok) {
                                // Check if authentication is needed
                                if (response.status === 401 && data.authUrl) {
                                    const errorMsg = `Sheet "${sheet.title}": Authentication required`;
                                    console.error(`  â†’ âŒ ${errorMsg}`);
                                    errors.push(errorMsg);
                                } else {
                                    const errorMsg = `Sheet "${sheet.title}": ${data.error || 'Failed to highlight cells'}`;
                                    console.error(`  â†’ âŒ ${errorMsg}`);
                                    errors.push(errorMsg);
                                }
                            } else {
                                // Success for this sheet
                                const updatedCount = data.updatedCells || cellsToHighlight.length;
                                totalUpdated += updatedCount;
                                processedCount++;
                                console.log(`  â†’ âœ“ Successfully highlighted ${updatedCount} cells in "${sheet.title}"`);
                            }
                        } catch (sheetError) {
                            console.error(`  â†’ âŒ Error processing sheet "${sheet.title}":`, sheetError);
                            errors.push(`Sheet "${sheet.title}": ${sheetError.message}`);
                        }
                        
                        // Add a small delay between requests to avoid rate limiting (except for last sheet)
                        if (sheetIndex < sheetsToProcess.length - 1) {
                            await new Promise(resolve => setTimeout(resolve, 500)); // 500ms delay
                        }
                    }

                    // Show results
                    if (processedCount > 0) {
                        showHighlightSuccess(totalUpdated);
                        if (processAllSheets && processedCount > 1) {
                            // Add additional message for multiple sheets
                            const multiSheetMsg = document.createElement('div');
                            multiSheetMsg.style.cssText = 'margin-top: 10px; padding: 15px; background: rgba(86, 18, 189, 0.1); border-radius: 8px; color: #5612BD;';
                            multiSheetMsg.textContent = `âœ“ Processed ${processedCount} sheet(s) in the Google Sheet`;
                            const blankSpaceResults = document.getElementById('blank-space-results-section');
                            if (blankSpaceResults) {
                                blankSpaceResults.appendChild(multiSheetMsg);
                            }
                        }
                    }

                    if (errors.length > 0) {
                        console.warn('Some sheets had errors:', errors);
                        if (processedCount === 0) {
                            // All sheets failed
                            if (errors[0].includes('Authentication required')) {
                                showBlankSpaceError('Authentication required. Please visit ' + serverUrl + '/auth to authorize.');
                            } else {
                                showBlankSpaceError(errors[0] || 'Failed to highlight cells in all sheets');
                            }
                        } else {
                            // Some succeeded, some failed
                            showBlankSpaceError(`Some sheets had errors: ${errors.join('; ')}`);
                        }
                    }
                    
                    if (highlightBtn) {
                        highlightBtn.disabled = false;
                        highlightBtn.textContent = 'Highlight Cells in Google Sheet';
                    }
                } catch (error) {
                    console.error('Error:', error);
                    
                    // Check if server is running
                    if (error.message.includes('Failed to fetch') || error.message.includes('NetworkError')) {
                        showBlankSpaceError('Cannot connect to server. Make sure the Node.js server is running on http://localhost:3000');
                    } else {
                        showBlankSpaceError('Error highlighting cells: ' + error.message);
                    }
                    
                    if (highlightBtn) {
                        highlightBtn.disabled = false;
                        highlightBtn.textContent = 'Highlight Cells in Google Sheet';
                    }
                }
            }

            // HTTP/HTTPS Verification functionality
            const httpHttpsDropdown = document.getElementById('http-https-sheet-type');
            const httpHttpsInput = document.getElementById('http-https-input');
            const httpHttpsValueInput = document.getElementById('http-https-value');
            const httpHttpsLabel = document.getElementById('http-https-label');
            
            httpHttpsDropdown.addEventListener('change', function() {
                if (this.value) {
                    httpHttpsInput.classList.add('active');
                    if (this.value === 'excel-csv') {
                        httpHttpsValueInput.type = 'file';
                        httpHttpsValueInput.accept = '.xlsx,.xls,.csv';
                        httpHttpsValueInput.placeholder = '';
                        httpHttpsLabel.textContent = 'Select file';
                    } else if (this.value === 'gsheet') {
                        httpHttpsValueInput.type = 'text';
                        httpHttpsValueInput.accept = '';
                        httpHttpsValueInput.placeholder = 'Enter GSheet URL';
                        httpHttpsLabel.textContent = 'Enter GSheet URL';
                    }
                } else {
                    httpHttpsInput.classList.remove('active');
                }
            });

            // HTTP/HTTPS Verification button functionality
            const httpHttpsVerificationButton = document.getElementById('http-https-verification-btn');
            const httpHttpsResultsSection = document.getElementById('http-https-results-section');
            const httpHttpsLoadingMessage = document.getElementById('http-https-loading-message');
            const httpHttpsErrorMessage = document.getElementById('http-https-error-message');
            const httpHttpsNoResults = document.getElementById('http-https-no-results');
            const httpHttpsResults = document.getElementById('http-https-results');
            const httpHttpsResultsCount = document.getElementById('http-https-results-count');

            let httpHttpsCurrentWorkbook = null;
            let httpHttpsCurrentSheetId = null;
            let httpHttpsCurrentGid = null;
            let httpHttpsCurrentSheetUrl = null;

            function showHttpHttpsError(message) {
                // Show results section
                httpHttpsResultsSection.classList.add('active');
                httpHttpsErrorMessage.textContent = message;
                httpHttpsErrorMessage.style.display = 'block';
                httpHttpsLoadingMessage.style.display = 'none';
                httpHttpsNoResults.style.display = 'none';
            }

            function clearHttpHttpsResults() {
                httpHttpsResults.innerHTML = '';
                httpHttpsErrorMessage.style.display = 'none';
                httpHttpsNoResults.style.display = 'none';
                httpHttpsResultsCount.textContent = '';
            }

            httpHttpsVerificationButton.addEventListener('click', async function() {
                const sheetType = httpHttpsDropdown.value;
                const sheetValue = httpHttpsValueInput.value;

                if (!sheetType) {
                    showHttpHttpsError('Please select a sheet type');
                    return;
                }

                if (!sheetValue) {
                    showHttpHttpsError('Please provide a sheet URL or file');
                    return;
                }

                clearHttpHttpsResults();
                // Show results section
                httpHttpsResultsSection.classList.add('active');
                httpHttpsLoadingMessage.style.display = 'block';
                httpHttpsVerificationButton.disabled = true;
                httpHttpsVerificationButton.textContent = 'Processing...';

                try {
                    let data = [];
                    let workbook = null;
                    
                    if (sheetType === 'gsheet') {
                        // Read Google Sheet with workbook info
                        const result = await readGoogleSheetWithWorkbook(sheetValue);
                        httpHttpsCurrentSheetId = result.sheetId;
                        httpHttpsCurrentGid = result.gid;
                        httpHttpsCurrentSheetUrl = result.url || sheetValue;
                        const spreadsheetId = result.sheetId;
                        const processAllSheets = result.processAllSheets === true;

                        if (processAllSheets) {
                            // Process all sheets independently
                            const allSheets = await getAllSheets(spreadsheetId);
                            if (allSheets.length === 0) {
                                throw new Error('Could not retrieve sheet list. Please specify a specific sheet in the URL (add #gid=XXX to the URL).');
                            }

                            console.log(`Processing ${allSheets.length} sheets for HTTP/HTTPS verification:`, allSheets.map(s => s.title));
                            
                            let allUrlCells = [];
                            const sheetResults = [];

                            // Process each sheet separately
                            for (const sheet of allSheets) {
                                try {
                                    console.log(`Reading sheet: ${sheet.title} (gid: ${sheet.sheetId})`);
                                    
                                    // Read this specific sheet
                                    const sheetUrl = `https://docs.google.com/spreadsheets/d/${spreadsheetId}/export?format=csv&gid=${sheet.sheetId}`;
                                    const sheetResult = await readGoogleSheetCSV(sheetUrl);
                                    
                                    // Find URL cells in this sheet
                                    const sheetUrlCells = findUrlCells(sheetResult.data);
                                    
                                    // Add sheetId to each cell
                                    sheetUrlCells.forEach(cell => {
                                        cell.sheetId = parseInt(sheet.sheetId);
                                        cell.sheetName = sheet.title;
                                    });
                                    
                                    if (sheetUrlCells.length > 0) {
                                        sheetResults.push({
                                            sheetName: sheet.title,
                                            sheetId: sheet.sheetId,
                                            urlCells: sheetUrlCells
                                        });
                                        allUrlCells = allUrlCells.concat(sheetUrlCells);
                                    }
                                    
                                    console.log(`Found ${sheetUrlCells.length} URL cells in "${sheet.title}"`);
                                } catch (sheetError) {
                                    console.error(`Error processing sheet "${sheet.title}":`, sheetError);
                                    // Continue with other sheets
                                }
                            }

                            // Store URL cells for highlighting
                            const urlCells = allUrlCells;
                            
                            httpHttpsLoadingMessage.style.display = 'none';
                            httpHttpsVerificationButton.disabled = false;
                            httpHttpsVerificationButton.textContent = 'Verify HTTP/HTTPS';

                            if (urlCells.length === 0) {
                                httpHttpsNoResults.style.display = 'block';
                                httpHttpsResultsCount.textContent = `0 URLs found across ${allSheets.length} sheet(s)`;
                            } else {
                                // Highlight cells in all sheets
                                await highlightHttpHttpsInGSheetAllSheets(urlCells, spreadsheetId, allSheets);
                                
                                const httpCount = urlCells.filter(c => c.isHttp).length;
                                if (httpCount === 0) {
                                    httpHttpsNoResults.style.display = 'block';
                                    httpHttpsResultsCount.textContent = `0 HTTP URLs found across ${allSheets.length} sheet(s). All URLs are HTTPS.`;
                                } else {
                                    displayHttpHttpsResultsForAllSheets(sheetResults);
                                    httpHttpsResultsCount.textContent = `${httpCount} HTTP URL${httpCount !== 1 ? 's' : ''} found across ${sheetResults.length} sheet(s) (showing HTTP only)`;
                                }
                            }
                        } else {
                            // Process single sheet (existing behavior)
                            data = result.data;
                            workbook = result.workbook;
                            
                            console.log('HTTP/HTTPS Verification - Sheet info:', {
                                sheetId: httpHttpsCurrentSheetId,
                                gid: httpHttpsCurrentGid,
                                url: httpHttpsCurrentSheetUrl
                            });

                            // Find cells with URLs and categorize by HTTP/HTTPS
                            const urlCells = findUrlCells(data);
                            
                            httpHttpsLoadingMessage.style.display = 'none';
                            httpHttpsVerificationButton.disabled = false;
                            httpHttpsVerificationButton.textContent = 'Verify HTTP/HTTPS';

                            if (urlCells.length === 0) {
                                httpHttpsNoResults.style.display = 'block';
                                httpHttpsResultsCount.textContent = '0 URLs found';
                            } else {
                                // Highlight cells based on protocol
                                await highlightHttpHttpsInGSheet(urlCells);
                                
                                const httpCount = urlCells.filter(c => c.isHttp).length;
                                if (httpCount === 0) {
                                    httpHttpsNoResults.style.display = 'block';
                                    httpHttpsResultsCount.textContent = '0 HTTP URLs found. All URLs are HTTPS.';
                                } else {
                                    displayHttpHttpsResults(urlCells);
                                    httpHttpsResultsCount.textContent = `${httpCount} HTTP URL${httpCount !== 1 ? 's' : ''} found and highlighted (showing HTTP only)`;
                                }
                            }
                        }
                    } else if (sheetType === 'excel-csv') {
                        // Read Excel/CSV file
                        const file = httpHttpsValueInput.files[0];
                        if (!file) {
                            throw new Error('Please select a file');
                        }
                        const result = await readExcelFileWithWorkbook(file);
                        workbook = result.workbook;
                        httpHttpsCurrentWorkbook = workbook;
                        
                        // Process all sheets in the workbook (similar to GSheet)
                        const allSheetNames = workbook.SheetNames;
                        
                        if (allSheetNames.length > 1) {
                            // Process all sheets independently
                            console.log(`Processing ${allSheetNames.length} sheets for HTTP/HTTPS:`, allSheetNames);
                            
                            let allUrlCells = [];
                            const sheetResults = [];

                            // Process each sheet separately
                            for (const sheetName of allSheetNames) {
                                try {
                                    console.log(`Reading sheet: ${sheetName}`);
                                    
                                    // Read this specific sheet
                                    const worksheet = workbook.Sheets[sheetName];
                                    const sheetData = XLSX.utils.sheet_to_json(worksheet, { header: 1, defval: null });
                                    
                                    // Find URL cells in this sheet
                                    const sheetUrlCells = findUrlCells(sheetData);
                                    
                                    // Add sheetId and sheetName to each cell
                                    sheetUrlCells.forEach(cell => {
                                        cell.sheetId = allSheetNames.indexOf(sheetName);
                                        cell.sheetName = sheetName;
                                    });
                                    
                                    if (sheetUrlCells.length > 0) {
                                        sheetResults.push({
                                            sheetName: sheetName,
                                            sheetId: allSheetNames.indexOf(sheetName),
                                            urlCells: sheetUrlCells
                                        });
                                        allUrlCells = allUrlCells.concat(sheetUrlCells);
                                    }
                                    
                                    console.log(`Found ${sheetUrlCells.length} URL cells in "${sheetName}"`);
                                } catch (sheetError) {
                                    console.error(`Error processing sheet "${sheetName}":`, sheetError);
                                    // Continue with other sheets
                                }
                            }

                            // Store URL cells for highlighting
                            const urlCells = allUrlCells;
                            
                            httpHttpsLoadingMessage.style.display = 'none';
                            httpHttpsVerificationButton.disabled = false;
                            httpHttpsVerificationButton.textContent = 'Verify HTTP/HTTPS';

                            if (urlCells.length === 0) {
                                httpHttpsNoResults.style.display = 'block';
                                httpHttpsResultsCount.textContent = `0 URLs found across ${allSheetNames.length} sheet(s)`;
                            } else {
                                // Highlight cells in all sheets
                                await highlightHttpHttpsInExcelAllSheets(urlCells, file, allSheetNames);
                                
                                const httpCount = urlCells.filter(c => c.isHttp).length;
                                if (httpCount === 0) {
                                    httpHttpsNoResults.style.display = 'block';
                                    httpHttpsResultsCount.textContent = `0 HTTP URLs found across ${allSheetNames.length} sheet(s). All URLs are HTTPS.`;
                                } else {
                                    displayHttpHttpsResultsForAllSheets(sheetResults);
                                    httpHttpsResultsCount.textContent = `${httpCount} HTTP URL${httpCount !== 1 ? 's' : ''} found across ${sheetResults.length} sheet(s) (showing HTTP only)`;
                                }
                            }
                        } else {
                            // Single sheet - process normally
                            data = result.data;

                            // Find cells with URLs and categorize by HTTP/HTTPS
                            const urlCells = findUrlCells(data);
                            
                            httpHttpsLoadingMessage.style.display = 'none';
                            httpHttpsVerificationButton.disabled = false;
                            httpHttpsVerificationButton.textContent = 'Verify HTTP/HTTPS';

                            if (urlCells.length === 0) {
                                httpHttpsNoResults.style.display = 'block';
                                httpHttpsResultsCount.textContent = '0 URLs found';
                            } else {
                                // Highlight cells based on protocol
                                await highlightHttpHttpsInExcel(urlCells, file);
                                
                                const httpCount = urlCells.filter(c => c.isHttp).length;
                                if (httpCount === 0) {
                                    httpHttpsNoResults.style.display = 'block';
                                    httpHttpsResultsCount.textContent = '0 HTTP URLs found. All URLs are HTTPS.';
                                } else {
                                    displayHttpHttpsResults(urlCells);
                                    httpHttpsResultsCount.textContent = `${httpCount} HTTP URL${httpCount !== 1 ? 's' : ''} found and highlighted (showing HTTP only)`;
                                }
                            }
                        }
                    }
                } catch (error) {
                    console.error('Error:', error);
                    showHttpHttpsError('Error: ' + error.message);
                    httpHttpsVerificationButton.disabled = false;
                    httpHttpsVerificationButton.textContent = 'Verify HTTP/HTTPS';
                }
            });

            // Find cells with URLs and categorize by HTTP/HTTPS
            function findUrlCells(data) {
                const urlCells = [];
                const urlRegex = /(https?:\/\/[^\s,<>"']+)/gi;
                
                // Handle both 2D array format and JSON object format
                let rows = [];
                let headers = [];
                let skippedHeaderRow = false;
                if (Array.isArray(data) && data.length > 0) {
                    if (Array.isArray(data[0])) {
                        // 2D array format - first row is headers
                        headers = data[0] || [];
                        rows = data.slice(1); // Skip header row
                        skippedHeaderRow = true;
                    } else {
                        // JSON object format - convert to 2D array
                        const allKeys = new Set();
                        data.forEach(obj => {
                            Object.keys(obj).forEach(key => allKeys.add(key));
                        });
                        headers = Array.from(allKeys);
                        
                        rows = data.map(obj => {
                            return headers.map(key => obj[key] || '');
                        });
                        skippedHeaderRow = false;
                    }
                }
                
                rows.forEach((row, rowIndex) => {
                    if (Array.isArray(row)) {
                        row.forEach((cell, colIndex) => {
                            if (cell && typeof cell === 'string') {
                                const matches = cell.match(urlRegex);
                                if (matches && matches.length > 0) {
                                    // Check if any URL in the cell is HTTP or HTTPS
                                    const hasHttps = matches.some(url => url.trim().toLowerCase().startsWith('https://'));
                                    const hasHttp = matches.some(url => url.trim().toLowerCase().startsWith('http://'));
                                    
                                    if (hasHttps || hasHttp) {
                                        const columnName = headers[colIndex] || `Column${colIndex + 1}`;
                                        // Row number: +2 if we skipped header row, +1 if we didn't (1-based for display)
                                        const rowNumber = skippedHeaderRow ? rowIndex + 2 : rowIndex + 1;
                                        urlCells.push({
                                            row: rowNumber,
                                            col: colIndex, // 0-based for API
                                            column: columnName,
                                            cellValue: cell,
                                            isHttps: hasHttps,
                                            isHttp: hasHttp && !hasHttps, // Only HTTP if no HTTPS
                                            url: matches[0].trim()
                                        });
                                    }
                                }
                            }
                        });
                    }
                });
                
                return urlCells;
            }

            // Highlight HTTP/HTTPS cells in Google Sheet
            async function highlightHttpHttpsInGSheet(urlCells) {
                // Use local variables first, fallback to window variables
                const sheetId = httpHttpsCurrentSheetId || window.currentGSheetId;
                const gid = httpHttpsCurrentGid !== null && httpHttpsCurrentGid !== undefined 
                    ? httpHttpsCurrentGid 
                    : (window.currentGSheetGid || '0');
                
                if (!sheetId) {
                    throw new Error('Google Sheet information not available. Please make sure you selected a valid Google Sheet.');
                }
                
                console.log('Highlighting HTTP/HTTPS in GSheet:', { sheetId, gid, urlCellsCount: urlCells.length });

                const highlightBtn = httpHttpsVerificationButton;
                if (highlightBtn) {
                    highlightBtn.disabled = true;
                    highlightBtn.textContent = 'Highlighting cells...';
                }

                try {
                    const parsedGid = parseInt(gid);
                    
                    if (urlCells.length === 0) {
                        return;
                    }

                    // Determine server URL
                    const serverUrl = window.location.protocol === 'file:' 
                        ? 'http://localhost:3000' 
                        : window.location.origin;

                    // Prepare cells with color information
                    const cellsToHighlight = urlCells.map(cell => {
                        const isHttps = Boolean(cell.isHttps === true);
                        const isHttp = Boolean(cell.isHttp === true);
                        return {
                            rowIndex: cell.row - 1,
                            colIndex: cell.col,
                            isHttps: isHttps,
                            isHttp: isHttp
                        };
                    });
                    
                    // Log detailed info for first few cells
                    console.log('URL Cells found:', urlCells.slice(0, 3).map(c => ({
                        row: c.row,
                        col: c.col,
                        isHttps: c.isHttps,
                        isHttp: c.isHttp,
                        url: c.url
                    })));
                    console.log('Sending cells to highlight:', cellsToHighlight.slice(0, 3).map(c => ({
                        row: c.rowIndex + 1,
                        col: c.colIndex,
                        isHttps: c.isHttps,
                        isHttp: c.isHttp,
                        isHttpsType: typeof c.isHttps
                    })));
                    
                    // Call Node.js server API with color information
                    const response = await fetch(`${serverUrl}/api/highlight-cells`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            spreadsheetId: sheetId,
                            sheetId: parsedGid,
                            cells: cellsToHighlight
                        })
                    });

                    const data = await response.json();

                    if (!response.ok) {
                        throw new Error(data.error || 'Failed to highlight cells');
                    }

                    // Show success message
                    const successMsg = document.createElement('div');
                    successMsg.style.cssText = 'margin-top: 20px; padding: 15px; background: #d4edda; border-radius: 6px; border-left: 4px solid #28a745; color: #155724;';
                    successMsg.innerHTML = 'âœ… Cells highlighted in Google Sheet! Green = HTTPS, Red = HTTP';
                    httpHttpsResultsSection.appendChild(successMsg);
                    setTimeout(() => successMsg.remove(), 5000);

                    if (highlightBtn) {
                        highlightBtn.disabled = false;
                        highlightBtn.textContent = 'Verify HTTP/HTTPS';
                    }
                } catch (error) {
                    console.error('Error highlighting in GSheet:', error);
                    if (highlightBtn) {
                        highlightBtn.disabled = false;
                        highlightBtn.textContent = 'Verify HTTP/HTTPS';
                    }
                    throw error;
                }
            }

            // Highlight HTTP/HTTPS cells in all sheets
            async function highlightHttpHttpsInGSheetAllSheets(urlCells, spreadsheetId, allSheets) {
                if (!spreadsheetId || !allSheets || allSheets.length === 0) {
                    throw new Error('Invalid sheet information for highlighting');
                }

                console.log(`Highlighting HTTP/HTTPS in ${allSheets.length} sheets...`);
                
                const highlightBtn = httpHttpsVerificationButton;
                if (highlightBtn) {
                    highlightBtn.disabled = true;
                    highlightBtn.textContent = 'Highlighting cells...';
                }

                try {
                    // Determine server URL
                    const serverUrl = window.location.protocol === 'file:' 
                        ? 'http://localhost:3000' 
                        : window.location.origin;

                    let totalUpdated = 0;
                    let processedCount = 0;
                    const errors = [];

                    // Process each sheet
                    for (const sheet of allSheets) {
                        try {
                            const gid = parseInt(sheet.sheetId);
                            const normalizedGid = isNaN(gid) ? 0 : gid;
                            
                            console.log(`Processing sheet: ${sheet.title} (gid: ${gid})`);
                            
                            // Filter URL cells for this specific sheet
                            const sheetUrlCells = urlCells.filter(cell => {
                                const cellSheetId = cell.sheetId !== undefined ? parseInt(cell.sheetId) : null;
                                return cellSheetId === normalizedGid;
                            });
                            
                            console.log(`  â†’ Filtered ${sheetUrlCells.length} URL cells for "${sheet.title}" (gid: ${normalizedGid}) from total ${urlCells.length} cells`);
                            
                            if (sheetUrlCells.length === 0) {
                                console.log(`  â†’ No URL cells found in "${sheet.title}", skipping...`);
                                continue;
                            }

                            // Prepare cell data for this sheet
                            const cellsToHighlight = sheetUrlCells.map(cell => {
                                const isHttps = Boolean(cell.isHttps === true);
                                const isHttp = Boolean(cell.isHttp === true);
                                return {
                                    rowIndex: cell.row - 1,
                                    colIndex: cell.col,
                                    isHttps: isHttps,
                                    isHttp: isHttp
                                };
                            });
                            
                            console.log(`  â†’ Highlighting ${cellsToHighlight.length} URL cells in "${sheet.title}"`);
                            
                            // Send request to backend
                            const requestBody = {
                                spreadsheetId: spreadsheetId,
                                sheetId: normalizedGid,
                                cells: cellsToHighlight
                            };
                            
                            const response = await fetch(`${serverUrl}/api/highlight-cells`, {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json'
                                },
                                body: JSON.stringify(requestBody)
                            });

                            // Check if response is HTML (error page) instead of JSON
                            const responseText = await response.text();
                            let data;
                            
                            try {
                                if (responseText.trim().startsWith('<!DOCTYPE') || 
                                    responseText.trim().startsWith('<html') ||
                                    responseText.includes('<!DOCTYPE')) {
                                    throw new Error('Server returned HTML instead of JSON');
                                }
                                data = JSON.parse(responseText);
                            } catch (parseError) {
                                console.error(`  â†’ âŒ Failed to parse response for "${sheet.title}":`, parseError);
                                throw new Error(`Server returned invalid response: ${parseError.message}`);
                            }

                            if (!response.ok) {
                                throw new Error(data.error || `Failed to highlight cells in "${sheet.title}"`);
                            }

                            const updatedCount = data.updatedCells || cellsToHighlight.length;
                            totalUpdated += updatedCount;
                            processedCount++;
                            
                            console.log(`  â†’ âœ… Successfully highlighted ${updatedCount} cells in "${sheet.title}"`);
                            
                            // Small delay to prevent rate limiting
                            if (processedCount < allSheets.length) {
                                await new Promise(resolve => setTimeout(resolve, 500));
                            }
                        } catch (sheetError) {
                            console.error(`  â†’ âŒ Error processing sheet "${sheet.title}":`, sheetError);
                            errors.push({ sheet: sheet.title, error: sheetError.message });
                        }
                    }

                    // Show summary
                    if (processedCount > 0) {
                        const successMsg = document.createElement('div');
                        successMsg.style.cssText = 'margin-top: 20px; padding: 15px; background: #d4edda; border-radius: 6px; border-left: 4px solid #28a745; color: #155724;';
                        successMsg.innerHTML = `âœ… Highlighted ${totalUpdated} cells across ${processedCount} sheet(s)! Green = HTTPS, Red = HTTP`;
                        httpHttpsResultsSection.appendChild(successMsg);
                        setTimeout(() => successMsg.remove(), 5000);
                    }

                    if (errors.length > 0) {
                        const errorMsg = document.createElement('div');
                        errorMsg.style.cssText = 'margin-top: 10px; padding: 15px; background: #f8d7da; border-radius: 6px; border-left: 4px solid #dc3545; color: #721c24;';
                        errorMsg.innerHTML = `âš ï¸ Some sheets had errors: ${errors.map(e => `${e.sheet}: ${e.error}`).join(', ')}`;
                        httpHttpsResultsSection.appendChild(errorMsg);
                    }

                    if (highlightBtn) {
                        highlightBtn.disabled = false;
                        highlightBtn.textContent = 'Verify HTTP/HTTPS';
                    }
                } catch (error) {
                    console.error('Error highlighting in GSheets:', error);
                    if (highlightBtn) {
                        highlightBtn.disabled = false;
                        highlightBtn.textContent = 'Verify HTTP/HTTPS';
                    }
                    throw error;
                }
            }

            // Highlight HTTP/HTTPS cells in Excel file
            async function highlightHttpHttpsInExcel(urlCells, file) {
                if (typeof ExcelJS === 'undefined') {
                    throw new Error('ExcelJS library not loaded. Please refresh the page.');
                }

                try {
                    if (!file) {
                        throw new Error('File not available');
                    }

                    const fileName = file.name.toLowerCase();
                    const isCSV = fileName.endsWith('.csv');
                    const isXLS = fileName.endsWith('.xls');
                    const isXLSX = fileName.endsWith('.xlsx');

                    // Read the file with ExcelJS
                    const excelWorkbook = new ExcelJS.Workbook();
                    
                    if (isCSV) {
                        // Handle CSV files - read as text and parse
                        const text = await file.text();
                        const worksheet = excelWorkbook.addWorksheet('Sheet1');
                        
                        // Parse CSV (handle quoted values and commas within quotes)
                        const lines = text.split(/\r?\n/).filter(line => line.trim());
                        const parsedRows = [];
                        
                        lines.forEach((line) => {
                            const values = [];
                            let current = '';
                            let inQuotes = false;
                            
                            for (let i = 0; i < line.length; i++) {
                                const char = line[i];
                                if (char === '"') {
                                    inQuotes = !inQuotes;
                                } else if (char === ',' && !inQuotes) {
                                    values.push(current.trim());
                                    current = '';
                                } else {
                                    current += char;
                                }
                            }
                            values.push(current.trim()); // Add last value
                            parsedRows.push(values);
                        });
                        
                        // Add rows to worksheet
                        parsedRows.forEach((values, rowIndex) => {
                            const row = worksheet.addRow(values);
                            
                            // Highlight cells with URLs
                            urlCells.forEach(cell => {
                                if (cell.row === rowIndex + 1 && cell.col < values.length) {
                                    const excelCell = row.getCell(cell.col + 1);
                                    excelCell.fill = {
                                        type: 'pattern',
                                        pattern: 'solid',
                                        fgColor: cell.isHttps 
                                            ? { argb: 'FF00FF00' } // Green for HTTPS
                                            : { argb: 'FFFF0000' } // Red for HTTP
                                    };
                                }
                            });
                        });
                    } else {
                        // Handle Excel files (.xlsx, .xls)
                        const arrayBuffer = await file.arrayBuffer();
                        
                        try {
                            if (isXLSX) {
                                await excelWorkbook.xlsx.load(arrayBuffer);
                            } else if (isXLS) {
                                // XLS format - ExcelJS might not support it well
                                throw new Error('XLS format (.xls) is not fully supported. Please convert to XLSX format or use CSV.');
                            } else {
                                throw new Error('Unsupported file format. Please use .xlsx, .xls, or .csv');
                            }
                        } catch (loadError) {
                            if (loadError.message.includes('not fully supported') || loadError.message.includes('Unsupported')) {
                                throw loadError;
                            }
                            throw new Error('Failed to read Excel file. The file may be corrupted or in an unsupported format: ' + loadError.message);
                        }
                        
                        const worksheet = excelWorkbook.worksheets[0];
                        
                        urlCells.forEach(cell => {
                            const excelRow = worksheet.getRow(cell.row);
                            const excelCell = excelRow.getCell(cell.col + 1); // ExcelJS uses 1-based columns
                            
                            // Set background color
                            excelCell.fill = {
                                type: 'pattern',
                                pattern: 'solid',
                                fgColor: cell.isHttps 
                                    ? { argb: 'FF00FF00' } // Green for HTTPS
                                    : { argb: 'FFFF0000' } // Red for HTTP
                            };
                        });
                    }

                    // Generate download
                    const buffer = await excelWorkbook.xlsx.writeBuffer();
                    const downloadFileName = isCSV ? 'http-https-verified.xlsx' : file.name.replace(/\.(xlsx|xls|csv)$/i, '_verified.xlsx');
                    const blob = new Blob([buffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = downloadFileName;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    
                    // Show success message
                    const successMsg = document.createElement('div');
                    successMsg.style.cssText = 'margin-top: 20px; padding: 15px; background: #d4edda; border-radius: 6px; border-left: 4px solid #28a745; color: #155724;';
                    successMsg.innerHTML = 'âœ… File downloaded with highlighted cells! Green = HTTPS, Red = HTTP';
                    httpHttpsResultsSection.appendChild(successMsg);
                    setTimeout(() => successMsg.remove(), 5000);
                } catch (error) {
                    console.error('Error highlighting in Excel:', error);
                    throw new Error('Failed to highlight Excel file: ' + error.message);
                }
            }

            // Highlight HTTP/HTTPS cells in all sheets of Excel file
            async function highlightHttpHttpsInExcelAllSheets(urlCells, file, allSheetNames) {
                if (typeof ExcelJS === 'undefined') {
                    throw new Error('ExcelJS library not loaded. Please refresh the page.');
                }

                try {
                    if (!file) {
                        throw new Error('File not available');
                    }

                    const fileName = file.name.toLowerCase();
                    const isCSV = fileName.endsWith('.csv');
                    const isXLS = fileName.endsWith('.xls');
                    const isXLSX = fileName.endsWith('.xlsx');

                    // Read the file with ExcelJS
                    const excelWorkbook = new ExcelJS.Workbook();
                    
                    if (isCSV) {
                        // CSV files only have one sheet, so process normally
                        const text = await file.text();
                        const worksheet = excelWorkbook.addWorksheet('Sheet1');
                        
                        const lines = text.split(/\r?\n/).filter(line => line.trim());
                        const parsedRows = [];
                        
                        lines.forEach((line) => {
                            const values = [];
                            let current = '';
                            let inQuotes = false;
                            
                            for (let i = 0; i < line.length; i++) {
                                const char = line[i];
                                if (char === '"') {
                                    inQuotes = !inQuotes;
                                } else if (char === ',' && !inQuotes) {
                                    values.push(current.trim());
                                    current = '';
                                } else {
                                    current += char;
                                }
                            }
                            values.push(current.trim());
                            parsedRows.push(values);
                        });
                        
                        parsedRows.forEach((values, rowIndex) => {
                            const row = worksheet.addRow(values);
                            
                            // Highlight cells with URLs (CSV only has one sheet, so sheetId is 0)
                            urlCells.filter(c => c.sheetId === 0).forEach(cell => {
                                if (cell.row === rowIndex + 1 && cell.col < values.length) {
                                    const excelCell = row.getCell(cell.col + 1);
                                    excelCell.fill = {
                                        type: 'pattern',
                                        pattern: 'solid',
                                        fgColor: cell.isHttps 
                                            ? { argb: 'FF00FF00' } // Green for HTTPS
                                            : { argb: 'FFFF0000' } // Red for HTTP
                                    };
                                }
                            });
                        });
                    } else {
                        // Handle Excel files (.xlsx, .xls)
                        const arrayBuffer = await file.arrayBuffer();
                        
                        try {
                            if (isXLSX) {
                                await excelWorkbook.xlsx.load(arrayBuffer);
                            } else if (isXLS) {
                                throw new Error('XLS format (.xls) is not fully supported. Please convert to XLSX format or use CSV.');
                            } else {
                                throw new Error('Unsupported file format. Please use .xlsx, .xls, or .csv');
                            }
                        } catch (loadError) {
                            if (loadError.message.includes('not fully supported') || loadError.message.includes('Unsupported')) {
                                throw loadError;
                            }
                            throw new Error('Failed to read Excel file. The file may be corrupted or in an unsupported format: ' + loadError.message);
                        }
                        
                        // Process each sheet
                        allSheetNames.forEach((sheetName, sheetIndex) => {
                            const worksheet = excelWorkbook.getWorksheet(sheetName) || excelWorkbook.worksheets[sheetIndex];
                            if (!worksheet) return;
                            
                            // Filter URL cells for this specific sheet
                            const sheetUrlCells = urlCells.filter(cell => cell.sheetId === sheetIndex);
                            
                            // Highlight cells in this sheet
                            sheetUrlCells.forEach(cell => {
                                const excelRow = worksheet.getRow(cell.row);
                                const excelCell = excelRow.getCell(cell.col + 1); // ExcelJS uses 1-based columns
                                
                                // Set background color
                                excelCell.fill = {
                                    type: 'pattern',
                                    pattern: 'solid',
                                    fgColor: cell.isHttps 
                                        ? { argb: 'FF00FF00' } // Green for HTTPS
                                        : { argb: 'FFFF0000' } // Red for HTTP
                                };
                            });
                        });
                    }

                    // Generate download
                    const buffer = await excelWorkbook.xlsx.writeBuffer();
                    const downloadFileName = isCSV ? 'http-https-verified.xlsx' : file.name.replace(/\.(xlsx|xls|csv)$/i, '_verified.xlsx');
                    const blob = new Blob([buffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = downloadFileName;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    
                    // Show success message
                    const successMsg = document.createElement('div');
                    successMsg.style.cssText = 'margin-top: 20px; padding: 15px; background: #d4edda; border-radius: 6px; border-left: 4px solid #28a745; color: #155724;';
                    successMsg.innerHTML = `âœ… File downloaded with highlighted cells across ${allSheetNames.length} sheet(s)! Green = HTTPS, Red = HTTP`;
                    httpHttpsResultsSection.appendChild(successMsg);
                    setTimeout(() => successMsg.remove(), 5000);
                } catch (error) {
                    console.error('Error highlighting in Excel:', error);
                    throw new Error('Failed to highlight Excel file: ' + error.message);
                }
            }

            // Display HTTP/HTTPS verification results
            function displayHttpHttpsResults(results) {
                httpHttpsResults.innerHTML = '';

                const httpsCount = results.filter(r => r.isHttps).length;
                const httpCount = results.filter(r => r.isHttp).length;
                const totalCount = results.length;

                // Create summary section with table
                const summaryDiv = document.createElement('div');
                summaryDiv.style.cssText = 'margin-bottom: 30px; padding: 20px; background: linear-gradient(135deg, rgba(86, 18, 189, 0.1) 0%, rgba(146, 80, 242, 0.1) 100%); border-radius: 12px; border-left: 4px solid #5612BD;';
                summaryDiv.innerHTML = `
                    <h3 style="margin: 0 0 15px 0; color: #250651; font-size: 1.3rem;">Summary</h3>
                    <table style="width: 100%; border-collapse: collapse; background: white; border-radius: 8px; overflow: hidden; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                        <thead>
                            <tr style="background-color: #5612BD; color: #fff;">
                                <th style="padding: 12px; text-align: left; font-weight: 600;">Protocol</th>
                                <th style="padding: 12px; text-align: left; font-weight: 600;">Count</th>
                                <th style="padding: 12px; text-align: left; font-weight: 600;">Color</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr style="border-bottom: 1px solid #eee;">
                                <td style="padding: 12px;"><span style="color: #28a745; font-weight: 600;">HTTPS</span></td>
                                <td style="padding: 12px; font-weight: 600;">${httpsCount}</td>
                                <td style="padding: 12px;"><span style="color: #28a745; font-weight: 600;">Green</span></td>
                            </tr>
                            <tr style="border-bottom: 1px solid #eee;">
                                <td style="padding: 12px;"><span style="color: #dc3545; font-weight: 600;">HTTP</span></td>
                                <td style="padding: 12px; font-weight: 600;">${httpCount}</td>
                                <td style="padding: 12px;"><span style="color: #dc3545; font-weight: 600;">Red</span></td>
                            </tr>
                            <tr style="background-color: #f8f9fa;">
                                <td style="padding: 12px; font-weight: 600;">Total</td>
                                <td style="padding: 12px; font-weight: 600;">${totalCount}</td>
                                <td style="padding: 12px;">-</td>
                            </tr>
                        </tbody>
                    </table>
                `;
                httpHttpsResults.appendChild(summaryDiv);

                const table = document.createElement('table');
                table.className = 'results-table';
                table.innerHTML = `
                    <thead>
                        <tr>
                            <th>Row</th>
                            <th>Column</th>
                            <th>Value</th>
                            <th>Protocol</th>
                            <th>Color</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                `;

                const tbody = table.querySelector('tbody');
                
                // Filter to show only HTTP URLs (not HTTPS)
                const httpOnlyResults = results.filter(result => result.isHttp === true);
                
                if (httpOnlyResults.length === 0) {
                    const noResultsRow = document.createElement('tr');
                    noResultsRow.innerHTML = `
                        <td colspan="5" style="padding: 20px; text-align: center; color: #666;">
                            No HTTP URLs found. All URLs are HTTPS.
                        </td>
                    `;
                    tbody.appendChild(noResultsRow);
                } else {
                    httpOnlyResults.forEach(result => {
                        const row = document.createElement('tr');
                        const protocol = 'HTTP';
                        const colorName = 'Red';
                        const colorCode = '#dc3545';
                        const columnName = result.column || getColumnLetter(result.col);
                        const cellValue = result.cellValue || result.url || '';
                        
                        row.innerHTML = `
                            <td>${result.row}</td>
                            <td>${columnName}</td>
                            <td>${cellValue}</td>
                            <td><span style="color: ${colorCode}; font-weight: 600;">${protocol}</span></td>
                            <td><span style="color: ${colorCode}; font-weight: 600;">${colorName}</span></td>
                        `;
                        
                        tbody.appendChild(row);
                    });
                }

                httpHttpsResults.appendChild(table);
            }

            function displayHttpHttpsResultsForAllSheets(sheetResults) {
                httpHttpsResults.innerHTML = '';

                // Calculate totals
                const totalSheets = sheetResults.length;
                let totalUrls = 0;
                let totalHttps = 0;
                let totalHttp = 0;
                
                sheetResults.forEach(sheet => {
                    totalUrls += sheet.urlCells.length;
                    totalHttps += sheet.urlCells.filter(c => c.isHttps).length;
                    totalHttp += sheet.urlCells.filter(c => c.isHttp).length;
                });

                // Create summary section with table
                const summaryDiv = document.createElement('div');
                summaryDiv.style.cssText = 'margin-bottom: 30px; padding: 20px; background: linear-gradient(135deg, rgba(86, 18, 189, 0.1) 0%, rgba(146, 80, 242, 0.1) 100%); border-radius: 12px; border-left: 4px solid #5612BD;';
                summaryDiv.innerHTML = `
                    <h3 style="margin: 0 0 15px 0; color: #250651; font-size: 1.3rem;">Summary</h3>
                    <table style="width: 100%; border-collapse: collapse; background: white; border-radius: 8px; overflow: hidden; box-shadow: 0 2px 4px rgba(0,0,0,0.1); margin-bottom: 20px;">
                        <thead>
                            <tr style="background-color: #5612BD; color: #fff;">
                                <th style="padding: 12px; text-align: left; font-weight: 600;">Sheet</th>
                                <th style="padding: 12px; text-align: left; font-weight: 600;">Total URLs</th>
                                <th style="padding: 12px; text-align: left; font-weight: 600;">HTTPS</th>
                                <th style="padding: 12px; text-align: left; font-weight: 600;">HTTP</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${sheetResults.map(sheet => {
                                const sheetHttps = sheet.urlCells.filter(c => c.isHttps).length;
                                const sheetHttp = sheet.urlCells.filter(c => c.isHttp).length;
                                return `
                                <tr style="border-bottom: 1px solid #eee;">
                                    <td style="padding: 12px; font-weight: 600; color: #5612BD;">${sheet.sheetName}</td>
                                    <td style="padding: 12px;">${sheet.urlCells.length}</td>
                                    <td style="padding: 12px;"><span style="color: #28a745; font-weight: 600;">${sheetHttps}</span></td>
                                    <td style="padding: 12px;"><span style="color: #dc3545; font-weight: 600;">${sheetHttp}</span></td>
                                </tr>
                                `;
                            }).join('')}
                            <tr style="background-color: #f8f9fa; font-weight: 600;">
                                <td style="padding: 12px;">Total</td>
                                <td style="padding: 12px;">${totalUrls}</td>
                                <td style="padding: 12px;"><span style="color: #28a745;">${totalHttps}</span></td>
                                <td style="padding: 12px;"><span style="color: #dc3545;">${totalHttp}</span></td>
                            </tr>
                        </tbody>
                    </table>
                `;
                httpHttpsResults.appendChild(summaryDiv);

                // Create a table for all URL cells
                const table = document.createElement('table');
                table.className = 'results-table';
                table.style.width = '100%';
                table.style.borderCollapse = 'collapse';
                table.style.marginTop = '20px';
                table.style.backgroundColor = '#fff';
                table.style.borderRadius = '6px';
                table.style.overflow = 'hidden';
                table.style.boxShadow = '0 2px 4px rgba(0, 0, 0, 0.1)';
                table.innerHTML = `
                    <thead>
                        <tr style="background-color: #5612BD; color: #fff;">
                            <th style="padding: 12px; text-align: left; font-weight: 600;">Sheet</th>
                            <th style="padding: 12px; text-align: left; font-weight: 600;">Row</th>
                            <th style="padding: 12px; text-align: left; font-weight: 600;">Column</th>
                            <th style="padding: 12px; text-align: left; font-weight: 600;">Value</th>
                            <th style="padding: 12px; text-align: left; font-weight: 600;">Protocol</th>
                            <th style="padding: 12px; text-align: left; font-weight: 600;">Color</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                `;

                const tbody = table.querySelector('tbody');
                
                let hasHttpUrls = false;
                sheetResults.forEach(sheet => {
                    // Filter to show only HTTP URLs (not HTTPS)
                    const httpOnlyCells = sheet.urlCells.filter(result => result.isHttp === true);
                    
                    if (httpOnlyCells.length > 0) {
                        hasHttpUrls = true;
                        httpOnlyCells.forEach(result => {
                            const row = document.createElement('tr');
                            const protocol = 'HTTP';
                            const colorName = 'Red';
                            const colorCode = '#dc3545';
                            const columnName = result.column || getColumnLetter(result.col);
                            const cellValue = result.cellValue || result.url || '';
                            
                            row.innerHTML = `
                                <td style="padding: 10px; border-bottom: 1px solid #eee;">${sheet.sheetName}</td>
                                <td style="padding: 10px; border-bottom: 1px solid #eee;">${result.row}</td>
                                <td style="padding: 10px; border-bottom: 1px solid #eee;">${columnName}</td>
                                <td style="padding: 10px; border-bottom: 1px solid #eee;">${cellValue}</td>
                                <td style="padding: 10px; border-bottom: 1px solid #eee;"><span style="color: ${colorCode}; font-weight: 600;">${protocol}</span></td>
                                <td style="padding: 10px; border-bottom: 1px solid #eee;"><span style="color: ${colorCode}; font-weight: 600;">${colorName}</span></td>
                            `;
                            
                            tbody.appendChild(row);
                        });
                    }
                });
                
                if (!hasHttpUrls) {
                    const noResultsRow = document.createElement('tr');
                    noResultsRow.innerHTML = `
                        <td colspan="6" style="padding: 20px; text-align: center; color: #666;">
                            No HTTP URLs found. All URLs are HTTPS.
                        </td>
                    `;
                    tbody.appendChild(noResultsRow);
                }

                httpHttpsResults.appendChild(table);
            }

            // Model Names functionality
            const modelNamesDropdown = document.getElementById('model-names-sheet-type');
            const modelNamesInput = document.getElementById('model-names-input');
            const modelNamesValueInput = document.getElementById('model-names-value');
            const modelNamesLabel = document.getElementById('model-names-label');
            
            if (modelNamesDropdown && modelNamesInput && modelNamesValueInput && modelNamesLabel) {
            modelNamesDropdown.addEventListener('change', function() {
                if (this.value) {
                    modelNamesInput.classList.add('active');
                    if (this.value === 'excel-csv') {
                        modelNamesValueInput.type = 'file';
                        modelNamesValueInput.accept = '.xlsx,.xls,.csv';
                        modelNamesValueInput.placeholder = '';
                        modelNamesLabel.textContent = 'Select file';
                    } else if (this.value === 'gsheet') {
                        modelNamesValueInput.type = 'text';
                        modelNamesValueInput.accept = '';
                        modelNamesValueInput.placeholder = 'Enter GSheet URL';
                        modelNamesLabel.textContent = 'Enter GSheet URL';
                    }
                } else {
                    modelNamesInput.classList.remove('active');
                }
            });
            }

            // Model Names button functionality
            const modelNamesButton = document.getElementById('model-names-btn');
            const modelNamesResultsSection = document.getElementById('model-names-results-section');
            const modelNamesLoadingMessage = document.getElementById('model-names-loading-message');
            const modelNamesErrorMessage = document.getElementById('model-names-error-message');
            const modelNamesNoResults = document.getElementById('model-names-no-results');
            const modelNamesResults = document.getElementById('model-names-results');
            const modelNamesResultsCount = document.getElementById('model-names-results-count');

            function showModelNamesError(message) {
                if (!modelNamesResultsSection || !modelNamesErrorMessage || !modelNamesLoadingMessage || !modelNamesNoResults) return;
                // Show results section
                modelNamesResultsSection.classList.add('active');
                modelNamesErrorMessage.textContent = message;
                modelNamesErrorMessage.style.display = 'block';
                modelNamesLoadingMessage.style.display = 'none';
                modelNamesNoResults.style.display = 'none';
            }

            function clearModelNamesResults() {
                if (!modelNamesResults || !modelNamesErrorMessage || !modelNamesNoResults || !modelNamesResultsCount) return;
                modelNamesResults.innerHTML = '';
                modelNamesErrorMessage.style.display = 'none';
                modelNamesNoResults.style.display = 'none';
                modelNamesResultsCount.textContent = '';
            }

            // Valid model names (exact format)
            const validModelNames = [
                'MAZDA6e',
                'MAZDA CX-60',
                'MAZDA3',
                'MAZDA CX-30',
                'MAZDA2 HYBRID',
                'MAZDA CX-80',
                'MAZDA MX-5',
                'MAZDA CX-5',
                'MAZDA MX-30'
            ];

            // Check if a cell value matches a valid model name
            function isValidModelName(cellValue) {
                if (!cellValue || typeof cellValue !== 'string') {
                    return false;
                }
                
                // Remove HTML tags and trim whitespace
                const withoutHtml = cellValue.replace(/<[^>]*>/g, ' ').replace(/\s+/g, ' ').trim();
                const trimmed = cellValue.trim();
                
                // First check for exact match (case-sensitive except for MAZDA6e where 'e' can be lowercase)
                for (const validName of validModelNames) {
                    if (validName === 'MAZDA6e') {
                        // Special case: MAZDA6 followed by 'e' (case-insensitive for the 'e')
                        // Check both with and without HTML
                        if (trimmed === 'MAZDA6e' || trimmed === 'MAZDA6E' || 
                            withoutHtml === 'MAZDA6e' || withoutHtml === 'MAZDA6E' ||
                            trimmed.match(/^MAZDA6[eE]$/i)) {
                            return true;
                        }
                    } else {
                        // Exact match for other model names (case-sensitive)
                        if (trimmed === validName || withoutHtml === validName) {
                            return true;
                        }
                    }
                }
                
                // If no exact match, check if any model name appears anywhere in the text
                // This handles cases like "VOTRE MAZDA CX-30<br>VOUS ATTEND" containing "MAZDA CX-30"
                const normalizedText = withoutHtml.toUpperCase();
                
                for (const validName of validModelNames) {
                    if (validName === 'MAZDA6e') {
                        // Special case: Check for MAZDA6 followed by 'e' or 'E' (case-insensitive for the 'e')
                        if (normalizedText.includes('MAZDA6E') || normalizedText.includes('MAZDA6 E')) {
                            return true;
                        }
                    } else {
                        // Check if the model name appears anywhere in the text (case-insensitive)
                        const normalizedName = validName.toUpperCase();
                        if (normalizedText.includes(normalizedName)) {
                            return true;
                        }
                    }
                }
                
                return false;
            }

            // Find all cells with model names
            function findModelNameCells(data) {
                const cells = [];
                // URL regex pattern to detect URLs in cells
                const urlRegex = /(https?:\/\/[^\s,<>"']+)/gi;
                
                // Handle both 2D array format and JSON object format
                let rows = [];
                let headers = [];
                let skippedHeaderRow = false;
                if (Array.isArray(data) && data.length > 0) {
                    if (Array.isArray(data[0])) {
                        // 2D array format - first row is headers
                        headers = data[0] || [];
                        rows = data.slice(1); // Skip header row
                        skippedHeaderRow = true;
                    } else {
                        // JSON object format - convert to 2D array
                        const allKeys = new Set();
                        data.forEach(obj => {
                            Object.keys(obj).forEach(key => allKeys.add(key));
                        });
                        headers = Array.from(allKeys);
                        
                        rows = data.map(obj => {
                            return headers.map(key => obj[key] || '');
                        });
                        skippedHeaderRow = false;
                    }
                }
                
                rows.forEach((row, rowIndex) => {
                    if (Array.isArray(row)) {
                        row.forEach((cell, colIndex) => {
                            if (cell !== null && cell !== undefined && cell !== '') {
                                const cellValue = String(cell);
                                
                                // Skip cells that contain URLs
                                if (cellValue.match(urlRegex)) {
                                    return; // Skip this cell
                                }
                                
                                const isValid = isValidModelName(cellValue);
                                const columnName = headers[colIndex] || `Column${colIndex + 1}`;
                                // Row number: +2 if we skipped header row, +1 if we didn't (1-based for display)
                                const rowNumber = skippedHeaderRow ? rowIndex + 2 : rowIndex + 1;
                                
                                cells.push({
                                    row: rowNumber,
                                    col: colIndex, // 0-based for API
                                    column: columnName,
                                    cellValue: cellValue,
                                    isValid: isValid
                                });
                            }
                        });
                    }
                });
                
                return cells;
            }

            let modelNamesCurrentSheetId = null;
            let modelNamesCurrentGid = null;
            let modelNamesCurrentSheetUrl = null;

            if (modelNamesButton && modelNamesDropdown && modelNamesValueInput) {
            modelNamesButton.addEventListener('click', async function() {
                const sheetType = modelNamesDropdown.value;
                const sheetValue = modelNamesValueInput.value;

                if (!sheetType) {
                    showModelNamesError('Please select a sheet type');
                    return;
                }

                if (!sheetValue) {
                    showModelNamesError('Please provide a sheet URL or file');
                    return;
                }

                clearModelNamesResults();
                // Show results section
                modelNamesResultsSection.classList.add('active');
                modelNamesLoadingMessage.style.display = 'block';
                modelNamesButton.disabled = true;
                modelNamesButton.textContent = 'Processing...';

                try {
                    let data = [];
                    let workbook = null;
                    
                    if (sheetType === 'gsheet') {
                        // Read Google Sheet with workbook info
                        const result = await readGoogleSheetWithWorkbook(sheetValue);
                        modelNamesCurrentSheetId = result.sheetId;
                        modelNamesCurrentGid = result.gid;
                        modelNamesCurrentSheetUrl = result.url || sheetValue;
                        const spreadsheetId = result.sheetId;
                        const processAllSheets = result.processAllSheets === true;

                        if (processAllSheets) {
                            // Process all sheets independently
                            const allSheets = await getAllSheets(spreadsheetId);
                            if (allSheets.length === 0) {
                                throw new Error('Could not retrieve sheet list. Please specify a specific sheet in the URL (add #gid=XXX to the URL).');
                            }

                            console.log(`Processing ${allSheets.length} sheets for Model Names:`, allSheets.map(s => s.title));
                            
                            let allModelCells = [];
                            const sheetResults = [];

                            // Process each sheet separately
                            for (const sheet of allSheets) {
                                try {
                                    console.log(`Reading sheet: ${sheet.title} (gid: ${sheet.sheetId})`);
                                    
                                    // Read this specific sheet
                                    const sheetUrl = `https://docs.google.com/spreadsheets/d/${spreadsheetId}/export?format=csv&gid=${sheet.sheetId}`;
                                    const sheetResult = await readGoogleSheetCSV(sheetUrl);
                                    
                                    // Find model name cells in this sheet
                                    const sheetModelCells = findModelNameCells(sheetResult.data);
                                    
                                    // Add sheetId to each cell
                                    sheetModelCells.forEach(cell => {
                                        cell.sheetId = parseInt(sheet.sheetId);
                                        cell.sheetName = sheet.title;
                                    });
                                    
                                    if (sheetModelCells.length > 0) {
                                        sheetResults.push({
                                            sheetName: sheet.title,
                                            sheetId: sheet.sheetId,
                                            modelCells: sheetModelCells
                                        });
                                        allModelCells = allModelCells.concat(sheetModelCells);
                                    }
                                    
                                    console.log(`Found ${sheetModelCells.length} model name cells in "${sheet.title}"`);
                                } catch (sheetError) {
                                    console.error(`Error processing sheet "${sheet.title}":`, sheetError);
                                    // Continue with other sheets
                                }
                            }

                            // Store model cells for highlighting
                            const modelCells = allModelCells;
                            
                            modelNamesLoadingMessage.style.display = 'none';
                            modelNamesButton.disabled = false;
                            modelNamesButton.textContent = 'Process Model Names';

                            if (modelCells.length === 0) {
                                modelNamesNoResults.style.display = 'block';
                                modelNamesResultsCount.textContent = `0 cells found across ${allSheets.length} sheet(s)`;
                            } else {
                                // Highlight cells in all sheets
                                await highlightModelNamesInGSheetAllSheets(modelCells, spreadsheetId, allSheets);
                                
                                displayModelNamesResultsForAllSheets(sheetResults);
                                const validCount = modelCells.filter(c => c.isValid).length;
                                const invalidCount = modelCells.filter(c => !c.isValid).length;
                                modelNamesResultsCount.textContent = `${modelCells.length} cells checked across ${sheetResults.length} sheet(s): ${validCount} valid (green), ${invalidCount} invalid (red)`;
                            }
                        } else {
                            // Process single sheet (existing behavior)
                            data = result.data;
                            workbook = result.workbook;

                            // Find and validate model name cells
                            const modelCells = findModelNameCells(data);
                            
                            modelNamesLoadingMessage.style.display = 'none';
                            modelNamesButton.disabled = false;
                            modelNamesButton.textContent = 'Process Model Names';

                            if (modelCells.length === 0) {
                                modelNamesNoResults.style.display = 'block';
                                modelNamesResultsCount.textContent = '0 cells found';
                            } else {
                                // Highlight cells based on validation
                                await highlightModelNamesInGSheet(modelCells);
                                
                                displayModelNamesResults(modelCells);
                                const validCount = modelCells.filter(c => c.isValid).length;
                                const invalidCount = modelCells.filter(c => !c.isValid).length;
                                modelNamesResultsCount.textContent = `${modelCells.length} cells checked: ${validCount} valid (green), ${invalidCount} invalid (red)`;
                            }
                        }
                    } else if (sheetType === 'excel-csv') {
                        // Read Excel/CSV file
                        const file = modelNamesValueInput.files[0];
                        if (!file) {
                            throw new Error('Please select a file');
                        }
                        const result = await readExcelFileWithWorkbook(file);
                        workbook = result.workbook;
                        
                        // Process all sheets in the workbook (similar to GSheet)
                        const allSheetNames = workbook.SheetNames;
                        
                        if (allSheetNames.length > 1) {
                            // Process all sheets independently
                            console.log(`Processing ${allSheetNames.length} sheets for Model Names:`, allSheetNames);
                            
                            let allModelCells = [];
                            const sheetResults = [];

                            // Process each sheet separately
                            for (const sheetName of allSheetNames) {
                                try {
                                    console.log(`Reading sheet: ${sheetName}`);
                                    
                                    // Read this specific sheet
                                    const worksheet = workbook.Sheets[sheetName];
                                    const sheetData = XLSX.utils.sheet_to_json(worksheet, { header: 1, defval: null });
                                    
                                    // Find model name cells in this sheet
                                    const sheetModelCells = findModelNameCells(sheetData);
                                    
                                    // Add sheetId and sheetName to each cell
                                    sheetModelCells.forEach(cell => {
                                        cell.sheetId = allSheetNames.indexOf(sheetName);
                                        cell.sheetName = sheetName;
                                    });
                                    
                                    if (sheetModelCells.length > 0) {
                                        sheetResults.push({
                                            sheetName: sheetName,
                                            sheetId: allSheetNames.indexOf(sheetName),
                                            modelCells: sheetModelCells
                                        });
                                        allModelCells = allModelCells.concat(sheetModelCells);
                                    }
                                    
                                    console.log(`Found ${sheetModelCells.length} model name cells in "${sheetName}"`);
                                } catch (sheetError) {
                                    console.error(`Error processing sheet "${sheetName}":`, sheetError);
                                    // Continue with other sheets
                                }
                            }

                            // Store model cells for highlighting
                            const modelCells = allModelCells;
                            
                            modelNamesLoadingMessage.style.display = 'none';
                            modelNamesButton.disabled = false;
                            modelNamesButton.textContent = 'Process Model Names';

                            if (modelCells.length === 0) {
                                modelNamesNoResults.style.display = 'block';
                                modelNamesResultsCount.textContent = `0 cells found across ${allSheetNames.length} sheet(s)`;
                            } else {
                                // Highlight cells in all sheets
                                await highlightModelNamesInExcelAllSheets(modelCells, file, allSheetNames);
                                
                                displayModelNamesResultsForAllSheets(sheetResults);
                                const validCount = modelCells.filter(c => c.isValid).length;
                                const invalidCount = modelCells.filter(c => !c.isValid).length;
                                modelNamesResultsCount.textContent = `${modelCells.length} cells checked across ${sheetResults.length} sheet(s): ${validCount} valid (green), ${invalidCount} invalid (red)`;
                            }
                        } else {
                            // Single sheet - process normally
                            data = result.data;

                            // Find and validate model name cells
                            const modelCells = findModelNameCells(data);
                            
                            modelNamesLoadingMessage.style.display = 'none';
                            modelNamesButton.disabled = false;
                            modelNamesButton.textContent = 'Process Model Names';

                            if (modelCells.length === 0) {
                                modelNamesNoResults.style.display = 'block';
                                modelNamesResultsCount.textContent = '0 cells found';
                            } else {
                                // Highlight cells based on validation
                                await highlightModelNamesInExcel(modelCells, file);
                                
                                displayModelNamesResults(modelCells);
                                const validCount = modelCells.filter(c => c.isValid).length;
                                const invalidCount = modelCells.filter(c => !c.isValid).length;
                                modelNamesResultsCount.textContent = `${modelCells.length} cells checked: ${validCount} valid (green), ${invalidCount} invalid (red)`;
                            }
                        }
                    }
                } catch (error) {
                    console.error('Error:', error);
                    showModelNamesError('Error: ' + error.message);
                    if (modelNamesButton) {
                        modelNamesButton.disabled = false;
                        modelNamesButton.textContent = 'Process Model Names';
                    }
                }
            });
            }

            // Highlight model names in Google Sheet
            async function highlightModelNamesInGSheet(modelCells) {
                const sheetId = modelNamesCurrentSheetId || window.currentGSheetId;
                const gid = modelNamesCurrentGid !== null && modelNamesCurrentGid !== undefined 
                    ? modelNamesCurrentGid 
                    : (window.currentGSheetGid || '0');
                
                if (!sheetId) {
                    throw new Error('Google Sheet information not available. Please make sure you selected a valid Google Sheet.');
                }
                
                const highlightBtn = modelNamesButton;
                if (highlightBtn) {
                    highlightBtn.disabled = true;
                    highlightBtn.textContent = 'Highlighting cells...';
                }

                try {
                    const parsedGid = parseInt(gid);
                    
                    if (modelCells.length === 0) {
                        return;
                    }

                    // Determine server URL
                    const serverUrl = window.location.protocol === 'file:' 
                        ? 'http://localhost:3000' 
                        : window.location.origin;

                    // Prepare cells with validation info
                    const cellsToHighlight = modelCells.map(cell => {
                        // Ensure isValid is a proper boolean
                        const isValid = cell.isValid === true;
                        return {
                            rowIndex: cell.row - 1,
                            colIndex: cell.col,
                            isValid: isValid // true for valid, false for invalid
                        };
                    });
                    
                    // Log what we're sending
                    console.log('Model cells found:', modelCells.slice(0, 5).map(c => ({
                        row: c.row,
                        col: c.col,
                        value: c.cellValue,
                        isValid: c.isValid,
                        isValidType: typeof c.isValid
                    })));
                    console.log('Sending to server:', cellsToHighlight.slice(0, 5).map(c => ({
                        row: c.rowIndex + 1,
                        col: c.colIndex,
                        isValid: c.isValid,
                        isValidType: typeof c.isValid,
                        isValidJSON: JSON.stringify(c.isValid)
                    })));
                    
                    // Call Node.js server API
                    const response = await fetch(`${serverUrl}/api/highlight-cells`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            spreadsheetId: sheetId,
                            sheetId: parsedGid,
                            cells: cellsToHighlight
                        })
                    });

                    const data = await response.json();

                    if (!response.ok) {
                        throw new Error(data.error || 'Failed to highlight cells');
                    }

                    // Show success message
                    const successMsg = document.createElement('div');
                    successMsg.style.cssText = 'margin-top: 20px; padding: 15px; background: #d4edda; border-radius: 6px; border-left: 4px solid #28a745; color: #155724;';
                    successMsg.innerHTML = 'âœ… Cells highlighted in Google Sheet! Green = Valid, Red = Invalid';
                    modelNamesResultsSection.appendChild(successMsg);
                    setTimeout(() => successMsg.remove(), 5000);

                    if (highlightBtn) {
                        highlightBtn.disabled = false;
                        highlightBtn.textContent = 'Process Model Names';
                    }
                } catch (error) {
                    console.error('Error highlighting in GSheet:', error);
                    if (highlightBtn) {
                        highlightBtn.disabled = false;
                        highlightBtn.textContent = 'Process Model Names';
                    }
                    throw error;
                }
            }

            // Highlight model names in all sheets
            async function highlightModelNamesInGSheetAllSheets(modelCells, spreadsheetId, allSheets) {
                if (!spreadsheetId || !allSheets || allSheets.length === 0) {
                    throw new Error('Invalid sheet information for highlighting');
                }

                console.log(`Highlighting Model Names in ${allSheets.length} sheets...`);
                
                const highlightBtn = modelNamesButton;
                if (highlightBtn) {
                    highlightBtn.disabled = true;
                    highlightBtn.textContent = 'Highlighting cells...';
                }

                try {
                    // Determine server URL
                    const serverUrl = window.location.protocol === 'file:' 
                        ? 'http://localhost:3000' 
                        : window.location.origin;

                    let totalUpdated = 0;
                    let processedCount = 0;
                    const errors = [];

                    // Process each sheet
                    for (const sheet of allSheets) {
                        try {
                            const gid = parseInt(sheet.sheetId);
                            const normalizedGid = isNaN(gid) ? 0 : gid;
                            
                            console.log(`Processing sheet: ${sheet.title} (gid: ${gid})`);
                            
                            // Filter model cells for this specific sheet
                            const sheetModelCells = modelCells.filter(cell => {
                                const cellSheetId = cell.sheetId !== undefined ? parseInt(cell.sheetId) : null;
                                return cellSheetId === normalizedGid;
                            });
                            
                            console.log(`  â†’ Filtered ${sheetModelCells.length} model cells for "${sheet.title}" (gid: ${normalizedGid}) from total ${modelCells.length} cells`);
                            
                            if (sheetModelCells.length === 0) {
                                console.log(`  â†’ No model cells found in "${sheet.title}", skipping...`);
                                continue;
                            }

                            // Prepare cell data for this sheet
                            const cellsToHighlight = sheetModelCells.map(cell => {
                                const isValid = cell.isValid === true;
                                return {
                                    rowIndex: cell.row - 1,
                                    colIndex: cell.col,
                                    isValid: isValid
                                };
                            });
                            
                            console.log(`  â†’ Highlighting ${cellsToHighlight.length} model cells in "${sheet.title}"`);
                            
                            // Send request to backend
                            const requestBody = {
                                spreadsheetId: spreadsheetId,
                                sheetId: normalizedGid,
                                cells: cellsToHighlight
                            };
                            
                            const response = await fetch(`${serverUrl}/api/highlight-cells`, {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json'
                                },
                                body: JSON.stringify(requestBody)
                            });

                            // Check if response is HTML (error page) instead of JSON
                            const responseText = await response.text();
                            let data;
                            
                            try {
                                if (responseText.trim().startsWith('<!DOCTYPE') || 
                                    responseText.trim().startsWith('<html') ||
                                    responseText.includes('<!DOCTYPE')) {
                                    throw new Error('Server returned HTML instead of JSON');
                                }
                                data = JSON.parse(responseText);
                            } catch (parseError) {
                                console.error(`  â†’ âŒ Failed to parse response for "${sheet.title}":`, parseError);
                                throw new Error(`Server returned invalid response: ${parseError.message}`);
                            }

                            if (!response.ok) {
                                throw new Error(data.error || `Failed to highlight cells in "${sheet.title}"`);
                            }

                            const updatedCount = data.updatedCells || cellsToHighlight.length;
                            totalUpdated += updatedCount;
                            processedCount++;
                            
                            console.log(`  â†’ âœ… Successfully highlighted ${updatedCount} cells in "${sheet.title}"`);
                            
                            // Small delay to prevent rate limiting
                            if (processedCount < allSheets.length) {
                                await new Promise(resolve => setTimeout(resolve, 500));
                            }
                        } catch (sheetError) {
                            console.error(`  â†’ âŒ Error processing sheet "${sheet.title}":`, sheetError);
                            errors.push({ sheet: sheet.title, error: sheetError.message });
                        }
                    }

                    // Show summary
                    if (processedCount > 0) {
                        const successMsg = document.createElement('div');
                        successMsg.style.cssText = 'margin-top: 20px; padding: 15px; background: #d4edda; border-radius: 6px; border-left: 4px solid #28a745; color: #155724;';
                        successMsg.innerHTML = `âœ… Highlighted ${totalUpdated} cells across ${processedCount} sheet(s)! Green = Valid, Red = Invalid`;
                        modelNamesResultsSection.appendChild(successMsg);
                        setTimeout(() => successMsg.remove(), 5000);
                    }

                    if (errors.length > 0) {
                        const errorMsg = document.createElement('div');
                        errorMsg.style.cssText = 'margin-top: 10px; padding: 15px; background: #f8d7da; border-radius: 6px; border-left: 4px solid #dc3545; color: #721c24;';
                        errorMsg.innerHTML = `âš ï¸ Some sheets had errors: ${errors.map(e => `${e.sheet}: ${e.error}`).join(', ')}`;
                        modelNamesResultsSection.appendChild(errorMsg);
                    }

                    if (highlightBtn) {
                        highlightBtn.disabled = false;
                        highlightBtn.textContent = 'Process Model Names';
                    }
                } catch (error) {
                    console.error('Error highlighting in GSheets:', error);
                    if (highlightBtn) {
                        highlightBtn.disabled = false;
                        highlightBtn.textContent = 'Process Model Names';
                    }
                    throw error;
                }
            }

            // Highlight model names in Excel file
            async function highlightModelNamesInExcel(modelCells, file) {
                if (typeof ExcelJS === 'undefined') {
                    throw new Error('ExcelJS library not loaded. Please refresh the page.');
                }

                try {
                    if (!file) {
                        throw new Error('File not available');
                    }

                    const fileName = file.name.toLowerCase();
                    const isCSV = fileName.endsWith('.csv');

                    // Read the file with ExcelJS
                    const excelWorkbook = new ExcelJS.Workbook();
                    
                    if (isCSV) {
                        // Handle CSV files
                        const text = await file.text();
                        const worksheet = excelWorkbook.addWorksheet('Sheet1');
                        
                        // Parse CSV
                        const lines = text.split(/\r?\n/).filter(line => line.trim());
                        const parsedRows = [];
                        
                        lines.forEach((line) => {
                            const values = [];
                            let current = '';
                            let inQuotes = false;
                            
                            for (let i = 0; i < line.length; i++) {
                                const char = line[i];
                                if (char === '"') {
                                    inQuotes = !inQuotes;
                                } else if (char === ',' && !inQuotes) {
                                    values.push(current.trim());
                                    current = '';
                                } else {
                                    current += char;
                                }
                            }
                            values.push(current.trim());
                            parsedRows.push(values);
                        });
                        
                        // Add rows to worksheet
                        parsedRows.forEach((values, rowIndex) => {
                            const row = worksheet.addRow(values);
                            
                            // Highlight cells with model names
                            modelCells.forEach(cell => {
                                if (cell.row === rowIndex + 1 && cell.col < values.length) {
                                    const excelCell = row.getCell(cell.col + 1);
                                    excelCell.fill = {
                                        type: 'pattern',
                                        pattern: 'solid',
                                        fgColor: cell.isValid 
                                            ? { argb: 'FF00FF00' } // Green for valid
                                            : { argb: 'FFFF0000' } // Red for invalid
                                    };
                                }
                            });
                        });
                    } else {
                        // Handle Excel files (.xlsx, .xls)
                        const arrayBuffer = await file.arrayBuffer();
                        
                        try {
                            if (fileName.endsWith('.xlsx')) {
                                await excelWorkbook.xlsx.load(arrayBuffer);
                            } else if (fileName.endsWith('.xls')) {
                                throw new Error('XLS format (.xls) is not fully supported. Please convert to XLSX format or use CSV.');
                            } else {
                                throw new Error('Unsupported file format. Please use .xlsx, .xls, or .csv');
                            }
                        } catch (loadError) {
                            if (loadError.message.includes('not fully supported') || loadError.message.includes('Unsupported')) {
                                throw loadError;
                            }
                            throw new Error('Failed to read Excel file. The file may be corrupted or in an unsupported format: ' + loadError.message);
                        }
                        
                        const worksheet = excelWorkbook.worksheets[0];
                        
                        modelCells.forEach(cell => {
                            const excelRow = worksheet.getRow(cell.row);
                            const excelCell = excelRow.getCell(cell.col + 1);
                            
                            excelCell.fill = {
                                type: 'pattern',
                                pattern: 'solid',
                                fgColor: cell.isValid 
                                    ? { argb: 'FF00FF00' } // Green for valid
                                    : { argb: 'FFFF0000' } // Red for invalid
                            };
                        });
                    }

                    // Generate download
                    const buffer = await excelWorkbook.xlsx.writeBuffer();
                    const downloadFileName = isCSV ? 'model-names-verified.xlsx' : file.name.replace(/\.(xlsx|xls|csv)$/i, '_verified.xlsx');
                    const blob = new Blob([buffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = downloadFileName;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    
                    // Show success message
                    const successMsg = document.createElement('div');
                    successMsg.style.cssText = 'margin-top: 20px; padding: 15px; background: #d4edda; border-radius: 6px; border-left: 4px solid #28a745; color: #155724;';
                    successMsg.innerHTML = 'âœ… File downloaded with highlighted cells! Green = Valid, Red = Invalid';
                    modelNamesResultsSection.appendChild(successMsg);
                    setTimeout(() => successMsg.remove(), 5000);
                } catch (error) {
                    console.error('Error highlighting in Excel:', error);
                    throw new Error('Failed to highlight Excel file: ' + error.message);
                }
            }

            // Highlight model names in all sheets of Excel file
            async function highlightModelNamesInExcelAllSheets(modelCells, file, allSheetNames) {
                if (typeof ExcelJS === 'undefined') {
                    throw new Error('ExcelJS library not loaded. Please refresh the page.');
                }

                try {
                    if (!file) {
                        throw new Error('File not available');
                    }

                    const fileName = file.name.toLowerCase();
                    const isCSV = fileName.endsWith('.csv');

                    // Read the file with ExcelJS
                    const excelWorkbook = new ExcelJS.Workbook();
                    
                    if (isCSV) {
                        // CSV files only have one sheet, so process normally
                        const text = await file.text();
                        const worksheet = excelWorkbook.addWorksheet('Sheet1');
                        
                        const lines = text.split(/\r?\n/).filter(line => line.trim());
                        const parsedRows = [];
                        
                        lines.forEach((line) => {
                            const values = [];
                            let current = '';
                            let inQuotes = false;
                            
                            for (let i = 0; i < line.length; i++) {
                                const char = line[i];
                                if (char === '"') {
                                    inQuotes = !inQuotes;
                                } else if (char === ',' && !inQuotes) {
                                    values.push(current.trim());
                                    current = '';
                                } else {
                                    current += char;
                                }
                            }
                            values.push(current.trim());
                            parsedRows.push(values);
                        });
                        
                        parsedRows.forEach((values, rowIndex) => {
                            const row = worksheet.addRow(values);
                            
                            // Highlight cells with model names (CSV only has one sheet, so sheetId is 0)
                            modelCells.filter(c => c.sheetId === 0).forEach(cell => {
                                if (cell.row === rowIndex + 1 && cell.col < values.length) {
                                    const excelCell = row.getCell(cell.col + 1);
                                    excelCell.fill = {
                                        type: 'pattern',
                                        pattern: 'solid',
                                        fgColor: cell.isValid 
                                            ? { argb: 'FF00FF00' } // Green for valid
                                            : { argb: 'FFFF0000' } // Red for invalid
                                    };
                                }
                            });
                        });
                    } else {
                        // Handle Excel files (.xlsx, .xls)
                        const arrayBuffer = await file.arrayBuffer();
                        
                        try {
                            if (fileName.endsWith('.xlsx')) {
                                await excelWorkbook.xlsx.load(arrayBuffer);
                            } else if (fileName.endsWith('.xls')) {
                                throw new Error('XLS format (.xls) is not fully supported. Please convert to XLSX format or use CSV.');
                            } else {
                                throw new Error('Unsupported file format. Please use .xlsx, .xls, or .csv');
                            }
                        } catch (loadError) {
                            if (loadError.message.includes('not fully supported') || loadError.message.includes('Unsupported')) {
                                throw loadError;
                            }
                            throw new Error('Failed to read Excel file. The file may be corrupted or in an unsupported format: ' + loadError.message);
                        }
                        
                        // Process each sheet
                        allSheetNames.forEach((sheetName, sheetIndex) => {
                            const worksheet = excelWorkbook.getWorksheet(sheetName) || excelWorkbook.worksheets[sheetIndex];
                            if (!worksheet) return;
                            
                            // Filter model cells for this specific sheet
                            const sheetModelCells = modelCells.filter(cell => cell.sheetId === sheetIndex);
                            
                            // Highlight cells in this sheet
                            sheetModelCells.forEach(cell => {
                                const excelRow = worksheet.getRow(cell.row);
                                const excelCell = excelRow.getCell(cell.col + 1);
                                
                                excelCell.fill = {
                                    type: 'pattern',
                                    pattern: 'solid',
                                    fgColor: cell.isValid 
                                        ? { argb: 'FF00FF00' } // Green for valid
                                        : { argb: 'FFFF0000' } // Red for invalid
                                };
                            });
                        });
                    }

                    // Generate download
                    const buffer = await excelWorkbook.xlsx.writeBuffer();
                    const downloadFileName = isCSV ? 'model-names-verified.xlsx' : file.name.replace(/\.(xlsx|xls|csv)$/i, '_verified.xlsx');
                    const blob = new Blob([buffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = downloadFileName;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    
                    // Show success message
                    const successMsg = document.createElement('div');
                    successMsg.style.cssText = 'margin-top: 20px; padding: 15px; background: #d4edda; border-radius: 6px; border-left: 4px solid #28a745; color: #155724;';
                    successMsg.innerHTML = `âœ… File downloaded with highlighted cells across ${allSheetNames.length} sheet(s)! Green = Valid, Red = Invalid`;
                    modelNamesResultsSection.appendChild(successMsg);
                    setTimeout(() => successMsg.remove(), 5000);
                } catch (error) {
                    console.error('Error highlighting in Excel:', error);
                    throw new Error('Failed to highlight Excel file: ' + error.message);
                }
            }

            // Display model names results
            function displayModelNamesResults(results) {
                modelNamesResults.innerHTML = '';

                const validCount = results.filter(r => r.isValid).length;
                const invalidCount = results.filter(r => !r.isValid).length;
                const totalCount = results.length;

                // Create summary section with table
                const summaryDiv = document.createElement('div');
                summaryDiv.style.cssText = 'margin-bottom: 30px; padding: 20px; background: linear-gradient(135deg, rgba(86, 18, 189, 0.1) 0%, rgba(146, 80, 242, 0.1) 100%); border-radius: 12px; border-left: 4px solid #5612BD;';
                summaryDiv.innerHTML = `
                    <h3 style="margin: 0 0 15px 0; color: #250651; font-size: 1.3rem;">Summary</h3>
                    <table style="width: 100%; border-collapse: collapse; background: white; border-radius: 8px; overflow: hidden; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                        <thead>
                            <tr style="background-color: #5612BD; color: #fff;">
                                <th style="padding: 12px; text-align: left; font-weight: 600;">Status</th>
                                <th style="padding: 12px; text-align: left; font-weight: 600;">Count</th>
                                <th style="padding: 12px; text-align: left; font-weight: 600;">Color</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr style="border-bottom: 1px solid #eee;">
                                <td style="padding: 12px;"><span style="color: #28a745; font-weight: 600;">Valid</span></td>
                                <td style="padding: 12px; font-weight: 600;">${validCount}</td>
                                <td style="padding: 12px;"><span style="color: #28a745; font-weight: 600;">Green</span></td>
                            </tr>
                            <tr style="border-bottom: 1px solid #eee;">
                                <td style="padding: 12px;"><span style="color: #dc3545; font-weight: 600;">Invalid</span></td>
                                <td style="padding: 12px; font-weight: 600;">${invalidCount}</td>
                                <td style="padding: 12px;"><span style="color: #dc3545; font-weight: 600;">Red</span></td>
                            </tr>
                            <tr style="background-color: #f8f9fa;">
                                <td style="padding: 12px; font-weight: 600;">Total</td>
                                <td style="padding: 12px; font-weight: 600;">${totalCount}</td>
                                <td style="padding: 12px;">-</td>
                            </tr>
                        </tbody>
                    </table>
                `;
                modelNamesResults.appendChild(summaryDiv);

                const table = document.createElement('table');
                table.className = 'results-table';
                table.innerHTML = `
                    <thead>
                        <tr>
                            <th>Row</th>
                            <th>Column</th>
                            <th>Value</th>
                            <th>Status</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                `;

                const tbody = table.querySelector('tbody');
                
                results.forEach(result => {
                    const row = document.createElement('tr');
                    const statusClass = result.isValid ? 'success' : 'error';
                    const statusText = result.isValid ? 'âœ“ Valid' : 'âœ— Invalid';
                    const colorCode = result.isValid ? '#28a745' : '#dc3545';
                    const columnName = result.column || getColumnLetter(result.col);
                    
                    row.innerHTML = `
                        <td>${result.row}</td>
                        <td>${columnName}</td>
                        <td>${result.cellValue}</td>
                        <td><span style="color: ${colorCode}; font-weight: 600;">${statusText}</span></td>
                    `;
                    
                    tbody.appendChild(row);
                });

                modelNamesResults.appendChild(table);
            }

            function displayModelNamesResultsForAllSheets(sheetResults) {
                modelNamesResults.innerHTML = '';

                // Calculate totals
                const totalSheets = sheetResults.length;
                let totalCells = 0;
                let totalValid = 0;
                let totalInvalid = 0;
                
                sheetResults.forEach(sheet => {
                    totalCells += sheet.modelCells.length;
                    totalValid += sheet.modelCells.filter(c => c.isValid).length;
                    totalInvalid += sheet.modelCells.filter(c => !c.isValid).length;
                });

                // Create summary section with table
                const summaryDiv = document.createElement('div');
                summaryDiv.style.cssText = 'margin-bottom: 30px; padding: 20px; background: linear-gradient(135deg, rgba(86, 18, 189, 0.1) 0%, rgba(146, 80, 242, 0.1) 100%); border-radius: 12px; border-left: 4px solid #5612BD;';
                summaryDiv.innerHTML = `
                    <h3 style="margin: 0 0 15px 0; color: #250651; font-size: 1.3rem;">Summary</h3>
                    <table style="width: 100%; border-collapse: collapse; background: white; border-radius: 8px; overflow: hidden; box-shadow: 0 2px 4px rgba(0,0,0,0.1); margin-bottom: 20px;">
                        <thead>
                            <tr style="background-color: #5612BD; color: #fff;">
                                <th style="padding: 12px; text-align: left; font-weight: 600;">Sheet</th>
                                <th style="padding: 12px; text-align: left; font-weight: 600;">Total Cells</th>
                                <th style="padding: 12px; text-align: left; font-weight: 600;">Valid</th>
                                <th style="padding: 12px; text-align: left; font-weight: 600;">Invalid</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${sheetResults.map(sheet => {
                                const sheetValid = sheet.modelCells.filter(c => c.isValid).length;
                                const sheetInvalid = sheet.modelCells.filter(c => !c.isValid).length;
                                return `
                                <tr style="border-bottom: 1px solid #eee;">
                                    <td style="padding: 12px; font-weight: 600; color: #5612BD;">${sheet.sheetName}</td>
                                    <td style="padding: 12px;">${sheet.modelCells.length}</td>
                                    <td style="padding: 12px;"><span style="color: #28a745; font-weight: 600;">${sheetValid}</span></td>
                                    <td style="padding: 12px;"><span style="color: #dc3545; font-weight: 600;">${sheetInvalid}</span></td>
                                </tr>
                                `;
                            }).join('')}
                            <tr style="background-color: #f8f9fa; font-weight: 600;">
                                <td style="padding: 12px;">Total</td>
                                <td style="padding: 12px;">${totalCells}</td>
                                <td style="padding: 12px;"><span style="color: #28a745;">${totalValid}</span></td>
                                <td style="padding: 12px;"><span style="color: #dc3545;">${totalInvalid}</span></td>
                            </tr>
                        </tbody>
                    </table>
                `;
                modelNamesResults.appendChild(summaryDiv);

                // Create a table for all model cells
                const table = document.createElement('table');
                table.className = 'results-table';
                table.style.width = '100%';
                table.style.borderCollapse = 'collapse';
                table.style.marginTop = '20px';
                table.style.backgroundColor = '#fff';
                table.style.borderRadius = '6px';
                table.style.overflow = 'hidden';
                table.style.boxShadow = '0 2px 4px rgba(0, 0, 0, 0.1)';
                table.innerHTML = `
                    <thead>
                        <tr style="background-color: #5612BD; color: #fff;">
                            <th style="padding: 12px; text-align: left; font-weight: 600;">Sheet</th>
                            <th style="padding: 12px; text-align: left; font-weight: 600;">Row</th>
                            <th style="padding: 12px; text-align: left; font-weight: 600;">Column</th>
                            <th style="padding: 12px; text-align: left; font-weight: 600;">Value</th>
                            <th style="padding: 12px; text-align: left; font-weight: 600;">Status</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                `;

                const tbody = table.querySelector('tbody');
                
                sheetResults.forEach(sheet => {
                    sheet.modelCells.forEach(result => {
                        const row = document.createElement('tr');
                        const statusText = result.isValid ? 'âœ“ Valid' : 'âœ— Invalid';
                        const colorCode = result.isValid ? '#28a745' : '#dc3545';
                        const columnName = result.column || getColumnLetter(result.col);
                        
                        row.innerHTML = `
                            <td style="padding: 10px; border-bottom: 1px solid #eee;">${sheet.sheetName}</td>
                            <td style="padding: 10px; border-bottom: 1px solid #eee;">${result.row}</td>
                            <td style="padding: 10px; border-bottom: 1px solid #eee;">${columnName}</td>
                            <td style="padding: 10px; border-bottom: 1px solid #eee;">${result.cellValue}</td>
                            <td style="padding: 10px; border-bottom: 1px solid #eee;"><span style="color: ${colorCode}; font-weight: 600;">${statusText}</span></td>
                        `;
                        
                        tbody.appendChild(row);
                    });
                });

                modelNamesResults.appendChild(table);
            }

            // Logo Color functionality
            const logoColorDropdown = document.getElementById('logo-color-sheet-type');
            const logoColorInput = document.getElementById('logo-color-input');
            const logoColorValueInput = document.getElementById('logo-color-value');
            const logoColorLabel = document.getElementById('logo-color-label');
            
            logoColorDropdown.addEventListener('change', function() {
                if (this.value) {
                    logoColorInput.classList.add('active');
                    if (this.value === 'excel-csv') {
                        logoColorValueInput.type = 'file';
                        logoColorValueInput.accept = '.xlsx,.xls,.csv';
                        logoColorValueInput.placeholder = '';
                        logoColorLabel.textContent = 'Select file';
                    } else if (this.value === 'gsheet') {
                        logoColorValueInput.type = 'text';
                        logoColorValueInput.accept = '';
                        logoColorValueInput.placeholder = 'Enter GSheet URL';
                        logoColorLabel.textContent = 'Enter GSheet URL';
                    }
                } else {
                    logoColorInput.classList.remove('active');
                }
            });

            // Logo Color button functionality
            const logoColorButton = document.getElementById('logo-color-btn');
            const logoColorResultsSection = document.getElementById('logo-color-results-section');
            const logoColorLoadingMessage = document.getElementById('logo-color-loading-message');
            const logoColorErrorMessage = document.getElementById('logo-color-error-message');
            const logoColorNoResults = document.getElementById('logo-color-no-results');
            const logoColorResults = document.getElementById('logo-color-results');
            const logoColorResultsCount = document.getElementById('logo-color-results-count');

            function showLogoColorError(message) {
                // Show results section
                logoColorResultsSection.classList.add('active');
                logoColorErrorMessage.textContent = message;
                logoColorErrorMessage.style.display = 'block';
                logoColorLoadingMessage.style.display = 'none';
                logoColorNoResults.style.display = 'none';
            }

            function clearLogoColorResults() {
                logoColorResults.innerHTML = '';
                logoColorErrorMessage.style.display = 'none';
                logoColorNoResults.style.display = 'none';
                logoColorResultsCount.textContent = '';
            }

            let logoColorCurrentSheetId = null;
            let logoColorCurrentGid = null;
            let logoColorCurrentSheetUrl = null;
            let logoColorCurrentWorkbook = null;

            logoColorButton.addEventListener('click', async function() {
                const sheetType = logoColorDropdown.value;
                const sheetValue = logoColorValueInput.value;

                if (!sheetType) {
                    showLogoColorError('Please select a sheet type');
                    return;
                }

                if (!sheetValue) {
                    showLogoColorError('Please provide a sheet URL or file');
                    return;
                }

                clearLogoColorResults();
                // Show results section
                logoColorResultsSection.classList.add('active');
                logoColorLoadingMessage.style.display = 'block';
                logoColorButton.disabled = true;
                logoColorButton.textContent = 'Processing...';

                try {
                    let data = [];
                    let workbook = null;
                    
                    if (sheetType === 'gsheet') {
                        // Read Google Sheet with workbook info
                        const result = await readGoogleSheetWithWorkbook(sheetValue);
                        logoColorCurrentSheetId = result.sheetId;
                        logoColorCurrentGid = result.gid;
                        logoColorCurrentSheetUrl = result.url || sheetValue;
                        const spreadsheetId = result.sheetId;
                        const processAllSheets = result.processAllSheets === true;

                        if (processAllSheets) {
                            // Process all sheets independently
                            const allSheets = await getAllSheets(spreadsheetId);
                            if (allSheets.length === 0) {
                                throw new Error('Could not retrieve sheet list. Please specify a specific sheet in the URL (add #gid=XXX to the URL).');
                            }

                            console.log(`Processing ${allSheets.length} sheets for Logo Color:`, allSheets.map(s => s.title));
                            
                            let allLogoColorCells = [];
                            const sheetResults = [];

                            // Process each sheet separately
                            for (const sheet of allSheets) {
                                try {
                                    console.log(`Reading sheet: ${sheet.title} (gid: ${sheet.sheetId})`);
                                    
                                    // Read this specific sheet
                                    const sheetUrl = `https://docs.google.com/spreadsheets/d/${spreadsheetId}/export?format=csv&gid=${sheet.sheetId}`;
                                    const sheetResult = await readGoogleSheetCSV(sheetUrl);
                                    
                                    // Find logo color cells in this sheet
                                    let sheetLogoColorCells = [];
                                    try {
                                        sheetLogoColorCells = findLogoColorCells(sheetResult.data);
                                    } catch (logoError) {
                                        if (logoError.message.includes('version column is not present')) {
                                            alert(`version column is not present in sheet "${sheet.title}"`);
                                            continue; // Skip this sheet
                                        }
                                        throw logoError;
                                    }
                                    
                                    // Add sheetId to each cell
                                    sheetLogoColorCells.forEach(cell => {
                                        cell.sheetId = parseInt(sheet.sheetId);
                                        cell.sheetName = sheet.title;
                                    });
                                    
                                    if (sheetLogoColorCells.length > 0) {
                                        sheetResults.push({
                                            sheetName: sheet.title,
                                            sheetId: sheet.sheetId,
                                            logoColorCells: sheetLogoColorCells
                                        });
                                        allLogoColorCells = allLogoColorCells.concat(sheetLogoColorCells);
                                    }
                                    
                                    console.log(`Found ${sheetLogoColorCells.length} logo color cells in "${sheet.title}"`);
                                } catch (sheetError) {
                                    console.error(`Error processing sheet "${sheet.title}":`, sheetError);
                                    // Continue with other sheets
                                }
                            }

                            // Store logo color cells for highlighting
                            const logoColorCells = allLogoColorCells;
                            
                            logoColorLoadingMessage.style.display = 'none';
                            logoColorButton.disabled = false;
                            logoColorButton.textContent = 'Verify Logo Color';

                            if (logoColorCells.length === 0) {
                                logoColorNoResults.style.display = 'block';
                                logoColorResultsCount.textContent = `0 cells found across ${allSheets.length} sheet(s)`;
                            } else {
                                // Highlight cells in all sheets
                                await highlightLogoColorInGSheetAllSheets(logoColorCells, spreadsheetId, allSheets);
                                
                                displayLogoColorResultsForAllSheets(sheetResults);
                                const validCount = logoColorCells.filter(c => c.isValid).length;
                                const invalidCount = logoColorCells.filter(c => !c.isValid).length;
                                logoColorResultsCount.textContent = `${logoColorCells.length} cells checked across ${sheetResults.length} sheet(s): ${validCount} valid (green), ${invalidCount} invalid (red)`;
                            }
                        } else {
                            // Process single sheet (existing behavior)
                            data = result.data;
                            workbook = result.workbook;

                            // Find logo color cells
                            let logoColorCells = [];
                            try {
                                logoColorCells = findLogoColorCells(data);
                            } catch (logoError) {
                                if (logoError.message.includes('version column is not present')) {
                                    alert('version column is not present');
                                    logoColorLoadingMessage.style.display = 'none';
                                    logoColorButton.disabled = false;
                                    logoColorButton.textContent = 'Verify Logo Color';
                                    return;
                                }
                                throw logoError;
                            }
                            
                            logoColorLoadingMessage.style.display = 'none';
                            logoColorButton.disabled = false;
                            logoColorButton.textContent = 'Verify Logo Color';

                            if (logoColorCells.length === 0) {
                                logoColorNoResults.style.display = 'block';
                                logoColorResultsCount.textContent = '0 cells found';
                            } else {
                                // Highlight cells
                                await highlightLogoColorInGSheet(logoColorCells);
                                
                                displayLogoColorResults(logoColorCells);
                                const validCount = logoColorCells.filter(c => c.isValid).length;
                                const invalidCount = logoColorCells.filter(c => !c.isValid).length;
                                logoColorResultsCount.textContent = `${logoColorCells.length} cells checked: ${validCount} valid (green), ${invalidCount} invalid (red)`;
                            }
                        }
                    } else if (sheetType === 'excel-csv') {
                        // Read Excel/CSV file
                        const file = logoColorValueInput.files[0];
                        if (!file) {
                            throw new Error('Please select a file');
                        }
                        const result = await readExcelFileWithWorkbook(file);
                        workbook = result.workbook;
                        logoColorCurrentWorkbook = workbook;
                        
                        // Process all sheets in the workbook (similar to GSheet)
                        const allSheetNames = workbook.SheetNames;
                        
                        if (allSheetNames.length > 1) {
                            // Process all sheets independently
                            console.log(`Processing ${allSheetNames.length} sheets for Logo Color:`, allSheetNames);
                            
                            let allLogoColorCells = [];
                            const sheetResults = [];

                            // Process each sheet separately
                            for (const sheetName of allSheetNames) {
                                try {
                                    console.log(`Reading sheet: ${sheetName}`);
                                    
                                    // Read this specific sheet
                                    const worksheet = workbook.Sheets[sheetName];
                                    const sheetData = XLSX.utils.sheet_to_json(worksheet, { header: 1, defval: null });
                                    
                                    // Find logo color cells in this sheet
                                    let sheetLogoColorCells = [];
                                    try {
                                        sheetLogoColorCells = findLogoColorCells(sheetData);
                                    } catch (logoError) {
                                        if (logoError.message.includes('version column is not present')) {
                                            alert(`version column is not present in sheet "${sheetName}"`);
                                            continue; // Skip this sheet
                                        }
                                        throw logoError;
                                    }
                                    
                                    // Add sheetId and sheetName to each cell
                                    sheetLogoColorCells.forEach(cell => {
                                        cell.sheetId = allSheetNames.indexOf(sheetName);
                                        cell.sheetName = sheetName;
                                    });
                                    
                                    if (sheetLogoColorCells.length > 0) {
                                        sheetResults.push({
                                            sheetName: sheetName,
                                            sheetId: allSheetNames.indexOf(sheetName),
                                            logoColorCells: sheetLogoColorCells
                                        });
                                        allLogoColorCells = allLogoColorCells.concat(sheetLogoColorCells);
                                    }
                                    
                                    console.log(`Found ${sheetLogoColorCells.length} logo color cells in "${sheetName}"`);
                                } catch (sheetError) {
                                    console.error(`Error processing sheet "${sheetName}":`, sheetError);
                                    // Continue with other sheets
                                }
                            }

                            // Store logo color cells for highlighting
                            const logoColorCells = allLogoColorCells;
                            
                            logoColorLoadingMessage.style.display = 'none';
                            logoColorButton.disabled = false;
                            logoColorButton.textContent = 'Verify Logo Color';

                            if (logoColorCells.length === 0) {
                                logoColorNoResults.style.display = 'block';
                                logoColorResultsCount.textContent = `0 cells found across ${allSheetNames.length} sheet(s)`;
                            } else {
                                // Highlight cells in all sheets
                                await highlightLogoColorInExcelAllSheets(logoColorCells, file, allSheetNames);
                                
                                displayLogoColorResultsForAllSheets(sheetResults);
                                const validCount = logoColorCells.filter(c => c.isValid).length;
                                const invalidCount = logoColorCells.filter(c => !c.isValid).length;
                                logoColorResultsCount.textContent = `${logoColorCells.length} cells checked across ${sheetResults.length} sheet(s): ${validCount} valid (green), ${invalidCount} invalid (red)`;
                            }
                        } else {
                            // Single sheet - process normally
                            data = result.data;

                            // Find logo color cells
                            let logoColorCells = [];
                            try {
                                logoColorCells = findLogoColorCells(data);
                            } catch (logoError) {
                                if (logoError.message.includes('version column is not present')) {
                                    alert('version column is not present');
                                    logoColorLoadingMessage.style.display = 'none';
                                    logoColorButton.disabled = false;
                                    logoColorButton.textContent = 'Verify Logo Color';
                                    return;
                                }
                                throw logoError;
                            }
                            
                            logoColorLoadingMessage.style.display = 'none';
                            logoColorButton.disabled = false;
                            logoColorButton.textContent = 'Verify Logo Color';

                            if (logoColorCells.length === 0) {
                                logoColorNoResults.style.display = 'block';
                                logoColorResultsCount.textContent = '0 cells found';
                            } else {
                                // Highlight cells based on validation
                                await highlightLogoColorInExcel(logoColorCells, file);
                                
                                displayLogoColorResults(logoColorCells);
                                const validCount = logoColorCells.filter(c => c.isValid).length;
                                const invalidCount = logoColorCells.filter(c => !c.isValid).length;
                                logoColorResultsCount.textContent = `${logoColorCells.length} cells checked: ${validCount} valid (green), ${invalidCount} invalid (red)`;
                            }
                        }
                    }
                } catch (error) {
                    console.error('Error:', error);
                    showLogoColorError('Error: ' + error.message);
                    logoColorButton.disabled = false;
                    logoColorButton.textContent = 'Verify Logo Color';
                }
            });

            // Logo Color verification functions
            function findLogoColorCells(data) {
                const cells = [];
                
                // Logo columns to check (any one of these that exists will be validated)
                const logoColumns = [
                    'brand_logo',
                    'LOGO_250x600',
                    'LOGO_728x90',
                    'LOGO_120x600',
                    'LOGO_200x600',
                    'LOGO_160x600',
                    'LOGO_320x160',
                    'LOGO_320x320',
                    'LOGO_320x250',
                    'LOGO_300x250',
                    'LOGO_580x400',
                    'LOGO_980x600',
                    'LOGO_320x480',
                    'LOGO_320x100',
                    'LOGO_320x400',
                    'LOGO_640x320',
                    'LOGO_300x600',
                    'LOGO_980x240',
                    'LOGO_980x300',
                    'LOGO_930x180',
                    'LOGO_800x250',
                    'LOGO_970x250'
                ];
                
                // Handle both 2D array format and JSON object format
                let rows = [];
                let headers = [];
                let skippedHeaderRow = false;
                
                if (Array.isArray(data) && data.length > 0) {
                    if (Array.isArray(data[0])) {
                        // 2D array format - first row is headers
                        headers = data[0] || [];
                        rows = data.slice(1); // Skip header row
                        skippedHeaderRow = true;
                    } else {
                        // JSON object format - convert to 2D array
                        const allKeys = new Set();
                        data.forEach(obj => {
                            Object.keys(obj).forEach(key => allKeys.add(key));
                        });
                        headers = Array.from(allKeys);
                        
                        rows = data.map(obj => {
                            return headers.map(key => obj[key] || '');
                        });
                        skippedHeaderRow = false;
                    }
                }
                
                // Check if "version" column exists
                const versionColIndex = headers.findIndex(h => 
                    h && h.toString().toLowerCase().trim() === 'version'
                );
                
                if (versionColIndex === -1) {
                    throw new Error('version column is not present');
                }
                
                // Find logo column indices
                const logoColumnIndices = {};
                logoColumns.forEach(logoCol => {
                    const index = headers.findIndex(h => 
                        h && h.toString().trim() === logoCol
                    );
                    if (index !== -1) {
                        logoColumnIndices[logoCol] = index;
                    }
                });
                
                // Process each row
                rows.forEach((row, rowIndex) => {
                    if (Array.isArray(row)) {
                        // Get version value for this row
                        const versionValue = row[versionColIndex];
                        const versionStr = versionValue ? String(versionValue).trim() : '';
                        
                        // Skip rows without version value
                        if (!versionStr) {
                            return;
                        }
                        
                        // Determine expected color based on version (case-insensitive)
                        let expectedColor = null;
                        const versionLower = versionStr.toLowerCase();
                        if (versionLower === 'normal') {
                            expectedColor = 'white';
                        } else if (versionLower === 'cgi') {
                            expectedColor = 'black';
                        } else {
                            // Skip rows with other version values
                            return;
                        }
                        
                        // Check each logo column
                        Object.keys(logoColumnIndices).forEach(logoCol => {
                            const colIndex = logoColumnIndices[logoCol];
                            const cellValue = row[colIndex];
                            const cellValueStr = cellValue ? String(cellValue) : '';
                            
                            // Check if cell value contains the expected color (case-insensitive)
                            const containsExpectedColor = cellValueStr.toLowerCase().includes(expectedColor.toLowerCase());
                            
                            // Row number: +2 if we skipped header row, +1 if we didn't (1-based for display)
                            const rowNumber = skippedHeaderRow ? rowIndex + 2 : rowIndex + 1;
                            
                            cells.push({
                                row: rowNumber,
                                col: colIndex, // 0-based for API
                                column: logoCol,
                                cellValue: cellValueStr,
                                version: versionStr,
                                expectedColor: expectedColor,
                                isValid: containsExpectedColor,
                                actualValue: cellValueStr
                            });
                        });
                    }
                });
                
                return cells;
            }

            async function highlightLogoColorInGSheet(logoColorCells) {
                const sheetId = logoColorCurrentSheetId || window.currentGSheetId;
                const gid = logoColorCurrentGid !== null && logoColorCurrentGid !== undefined 
                    ? logoColorCurrentGid 
                    : (window.currentGSheetGid || '0');
                
                if (!sheetId) {
                    throw new Error('Google Sheet information not available. Please make sure you selected a valid Google Sheet.');
                }
                
                const highlightBtn = logoColorButton;
                if (highlightBtn) {
                    highlightBtn.disabled = true;
                    highlightBtn.textContent = 'Highlighting cells...';
                }

                try {
                    const parsedGid = parseInt(gid);
                    
                    if (logoColorCells.length === 0) {
                        return;
                    }

                    // Determine server URL
                    const serverUrl = window.location.protocol === 'file:' 
                        ? 'http://localhost:3000' 
                        : window.location.origin;

                    // Prepare cells with validation info
                    const cellsToHighlight = logoColorCells.map(cell => {
                        const isValid = cell.isValid === true;
                        return {
                            rowIndex: cell.row - 1,
                            colIndex: cell.col,
                            isValid: isValid // true for valid, false for invalid
                        };
                    });
                    
                    // Call Node.js server API
                    const response = await fetch(`${serverUrl}/api/highlight-cells`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            spreadsheetId: sheetId,
                            sheetId: parsedGid,
                            cells: cellsToHighlight
                        })
                    });

                    // Check if response is HTML (error page) instead of JSON
                    const responseText = await response.text();
                    let data;
                    
                    try {
                        if (responseText.trim().startsWith('<!DOCTYPE') || 
                            responseText.trim().startsWith('<html') ||
                            responseText.includes('<!DOCTYPE')) {
                            throw new Error('Server returned HTML instead of JSON');
                        }
                        data = JSON.parse(responseText);
                    } catch (parseError) {
                        console.error('Failed to parse response:', parseError);
                        throw new Error(`Server returned invalid response: ${parseError.message}`);
                    }

                    if (!response.ok) {
                        throw new Error(data.error || 'Failed to highlight cells');
                    }

                    // Show success message
                    const successMsg = document.createElement('div');
                    successMsg.style.cssText = 'margin-top: 20px; padding: 15px; background: #d4edda; border-radius: 6px; border-left: 4px solid #28a745; color: #155724;';
                    successMsg.innerHTML = 'âœ… Cells highlighted in Google Sheet! Green = Valid, Red = Invalid';
                    logoColorResultsSection.appendChild(successMsg);
                    setTimeout(() => successMsg.remove(), 5000);

                    if (highlightBtn) {
                        highlightBtn.disabled = false;
                        highlightBtn.textContent = 'Verify Logo Color';
                    }
                } catch (error) {
                    console.error('Error highlighting in GSheet:', error);
                    if (highlightBtn) {
                        highlightBtn.disabled = false;
                        highlightBtn.textContent = 'Verify Logo Color';
                    }
                    throw error;
                }
            }

            async function highlightLogoColorInGSheetAllSheets(logoColorCells, spreadsheetId, allSheets) {
                if (!spreadsheetId || !allSheets || allSheets.length === 0) {
                    throw new Error('Invalid sheet information for highlighting');
                }

                console.log(`Highlighting Logo Color in ${allSheets.length} sheets...`);
                
                const highlightBtn = logoColorButton;
                if (highlightBtn) {
                    highlightBtn.disabled = true;
                    highlightBtn.textContent = 'Highlighting cells...';
                }

                try {
                    // Determine server URL
                    const serverUrl = window.location.protocol === 'file:' 
                        ? 'http://localhost:3000' 
                        : window.location.origin;

                    let totalUpdated = 0;
                    let processedCount = 0;
                    const errors = [];

                    // Process each sheet
                    for (const sheet of allSheets) {
                        try {
                            const gid = parseInt(sheet.sheetId);
                            const normalizedGid = isNaN(gid) ? 0 : gid;
                            
                            console.log(`Processing sheet: ${sheet.title} (gid: ${gid})`);
                            
                            // Filter logo color cells for this specific sheet
                            const sheetLogoColorCells = logoColorCells.filter(cell => {
                                const cellSheetId = cell.sheetId !== undefined ? parseInt(cell.sheetId) : null;
                                return cellSheetId === normalizedGid;
                            });
                            
                            console.log(`  â†’ Filtered ${sheetLogoColorCells.length} logo color cells for "${sheet.title}" (gid: ${normalizedGid}) from total ${logoColorCells.length} cells`);
                            
                            if (sheetLogoColorCells.length === 0) {
                                console.log(`  â†’ No logo color cells found in "${sheet.title}", skipping...`);
                                continue;
                            }

                            // Prepare cell data for this sheet
                            const cellsToHighlight = sheetLogoColorCells.map(cell => {
                                const isValid = cell.isValid === true;
                                return {
                                    rowIndex: cell.row - 1,
                                    colIndex: cell.col,
                                    isValid: isValid
                                };
                            });
                            
                            console.log(`  â†’ Highlighting ${cellsToHighlight.length} logo color cells in "${sheet.title}"`);
                            
                            // Send request to backend
                            const requestBody = {
                                spreadsheetId: spreadsheetId,
                                sheetId: normalizedGid,
                                cells: cellsToHighlight
                            };
                            
                            const response = await fetch(`${serverUrl}/api/highlight-cells`, {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json'
                                },
                                body: JSON.stringify(requestBody)
                            });

                            // Check if response is HTML (error page) instead of JSON
                            const responseText = await response.text();
                            let data;
                            
                            try {
                                if (responseText.trim().startsWith('<!DOCTYPE') || 
                                    responseText.trim().startsWith('<html') ||
                                    responseText.includes('<!DOCTYPE')) {
                                    throw new Error('Server returned HTML instead of JSON');
                                }
                                data = JSON.parse(responseText);
                            } catch (parseError) {
                                console.error(`  â†’ âŒ Failed to parse response for "${sheet.title}":`, parseError);
                                throw new Error(`Server returned invalid response: ${parseError.message}`);
                            }

                            if (!response.ok) {
                                throw new Error(data.error || `Failed to highlight cells in "${sheet.title}"`);
                            }

                            const updatedCount = data.updatedCells || cellsToHighlight.length;
                            totalUpdated += updatedCount;
                            processedCount++;
                            
                            console.log(`  â†’ âœ… Successfully highlighted ${updatedCount} cells in "${sheet.title}"`);
                            
                            // Small delay to prevent rate limiting
                            if (processedCount < allSheets.length) {
                                await new Promise(resolve => setTimeout(resolve, 500));
                            }
                        } catch (sheetError) {
                            console.error(`  â†’ âŒ Error processing sheet "${sheet.title}":`, sheetError);
                            errors.push({ sheet: sheet.title, error: sheetError.message });
                        }
                    }

                    // Show summary
                    if (processedCount > 0) {
                        const successMsg = document.createElement('div');
                        successMsg.style.cssText = 'margin-top: 20px; padding: 15px; background: #d4edda; border-radius: 6px; border-left: 4px solid #28a745; color: #155724;';
                        successMsg.innerHTML = `âœ… Highlighted ${totalUpdated} cells across ${processedCount} sheet(s)! Green = Valid, Red = Invalid`;
                        logoColorResultsSection.appendChild(successMsg);
                        setTimeout(() => successMsg.remove(), 5000);
                    }

                    if (errors.length > 0) {
                        const errorMsg = document.createElement('div');
                        errorMsg.style.cssText = 'margin-top: 10px; padding: 15px; background: #f8d7da; border-radius: 6px; border-left: 4px solid #dc3545; color: #721c24;';
                        errorMsg.innerHTML = `âš ï¸ Some sheets had errors: ${errors.map(e => `${e.sheet}: ${e.error}`).join(', ')}`;
                        logoColorResultsSection.appendChild(errorMsg);
                    }

                    if (highlightBtn) {
                        highlightBtn.disabled = false;
                        highlightBtn.textContent = 'Verify Logo Color';
                    }
                } catch (error) {
                    console.error('Error highlighting in GSheets:', error);
                    if (highlightBtn) {
                        highlightBtn.disabled = false;
                        highlightBtn.textContent = 'Verify Logo Color';
                    }
                    throw error;
                }
            }

            async function highlightLogoColorInExcel(logoColorCells, file) {
                if (typeof ExcelJS === 'undefined') {
                    throw new Error('ExcelJS library not loaded. Please refresh the page.');
                }

                try {
                    if (!file) {
                        throw new Error('File not available');
                    }

                    const fileName = file.name.toLowerCase();
                    const isCSV = fileName.endsWith('.csv');

                    // Read the file with ExcelJS
                    const excelWorkbook = new ExcelJS.Workbook();
                    
                    if (isCSV) {
                        // Handle CSV files
                        const text = await file.text();
                        const worksheet = excelWorkbook.addWorksheet('Sheet1');
                        
                        // Parse CSV
                        const lines = text.split(/\r?\n/).filter(line => line.trim());
                        const parsedRows = [];
                        
                        lines.forEach((line) => {
                            const values = [];
                            let current = '';
                            let inQuotes = false;
                            
                            for (let i = 0; i < line.length; i++) {
                                const char = line[i];
                                if (char === '"') {
                                    inQuotes = !inQuotes;
                                } else if (char === ',' && !inQuotes) {
                                    values.push(current.trim());
                                    current = '';
                                } else {
                                    current += char;
                                }
                            }
                            values.push(current.trim());
                            parsedRows.push(values);
                        });
                        
                        // Add rows to worksheet
                        parsedRows.forEach((values, rowIndex) => {
                            const row = worksheet.addRow(values);
                            
                            // Highlight cells with logo colors
                            logoColorCells.forEach(cell => {
                                if (cell.row === rowIndex + 1 && cell.col < values.length) {
                                    const excelCell = row.getCell(cell.col + 1);
                                    excelCell.fill = {
                                        type: 'pattern',
                                        pattern: 'solid',
                                        fgColor: cell.isValid 
                                            ? { argb: 'FF00FF00' } // Green for valid
                                            : { argb: 'FFFF0000' } // Red for invalid
                                    };
                                }
                            });
                        });
                    } else {
                        // Handle Excel files (.xlsx, .xls)
                        const arrayBuffer = await file.arrayBuffer();
                        
                        try {
                            if (fileName.endsWith('.xlsx')) {
                                await excelWorkbook.xlsx.load(arrayBuffer);
                            } else if (fileName.endsWith('.xls')) {
                                throw new Error('XLS format (.xls) is not fully supported. Please convert to XLSX format or use CSV.');
                            } else {
                                throw new Error('Unsupported file format. Please use .xlsx, .xls, or .csv');
                            }
                        } catch (loadError) {
                            if (loadError.message.includes('not fully supported') || loadError.message.includes('Unsupported')) {
                                throw loadError;
                            }
                            throw new Error('Failed to read Excel file. The file may be corrupted or in an unsupported format: ' + loadError.message);
                        }
                        
                        const worksheet = excelWorkbook.worksheets[0];
                        
                        logoColorCells.forEach(cell => {
                            const excelRow = worksheet.getRow(cell.row);
                            const excelCell = excelRow.getCell(cell.col + 1);
                            
                            excelCell.fill = {
                                type: 'pattern',
                                pattern: 'solid',
                                fgColor: cell.isValid 
                                    ? { argb: 'FF00FF00' } // Green for valid
                                    : { argb: 'FFFF0000' } // Red for invalid
                            };
                        });
                    }

                    // Generate download
                    const buffer = await excelWorkbook.xlsx.writeBuffer();
                    const downloadFileName = isCSV ? 'logo-color-verified.xlsx' : file.name.replace(/\.(xlsx|xls|csv)$/i, '_verified.xlsx');
                    const blob = new Blob([buffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = downloadFileName;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    
                    // Show success message
                    const successMsg = document.createElement('div');
                    successMsg.style.cssText = 'margin-top: 20px; padding: 15px; background: #d4edda; border-radius: 6px; border-left: 4px solid #28a745; color: #155724;';
                    successMsg.innerHTML = 'âœ… File downloaded with highlighted cells! Green = Valid, Red = Invalid';
                    logoColorResultsSection.appendChild(successMsg);
                    setTimeout(() => successMsg.remove(), 5000);
                } catch (error) {
                    console.error('Error highlighting in Excel:', error);
                    throw new Error('Failed to highlight Excel file: ' + error.message);
                }
            }

            async function highlightLogoColorInExcelAllSheets(logoColorCells, file, allSheetNames) {
                if (typeof ExcelJS === 'undefined') {
                    throw new Error('ExcelJS library not loaded. Please refresh the page.');
                }

                try {
                    if (!file) {
                        throw new Error('File not available');
                    }

                    const fileName = file.name.toLowerCase();
                    const isCSV = fileName.endsWith('.csv');

                    // Read the file with ExcelJS
                    const excelWorkbook = new ExcelJS.Workbook();
                    
                    if (isCSV) {
                        // CSV files only have one sheet, so process normally
                        const text = await file.text();
                        const worksheet = excelWorkbook.addWorksheet('Sheet1');
                        
                        const lines = text.split(/\r?\n/).filter(line => line.trim());
                        const parsedRows = [];
                        
                        lines.forEach((line) => {
                            const values = [];
                            let current = '';
                            let inQuotes = false;
                            
                            for (let i = 0; i < line.length; i++) {
                                const char = line[i];
                                if (char === '"') {
                                    inQuotes = !inQuotes;
                                } else if (char === ',' && !inQuotes) {
                                    values.push(current.trim());
                                    current = '';
                                } else {
                                    current += char;
                                }
                            }
                            values.push(current.trim());
                            parsedRows.push(values);
                        });
                        
                        parsedRows.forEach((values, rowIndex) => {
                            const row = worksheet.addRow(values);
                            
                            // Highlight cells with logo colors (CSV only has one sheet, so sheetId is 0)
                            logoColorCells.filter(c => c.sheetId === 0).forEach(cell => {
                                if (cell.row === rowIndex + 1 && cell.col < values.length) {
                                    const excelCell = row.getCell(cell.col + 1);
                                    excelCell.fill = {
                                        type: 'pattern',
                                        pattern: 'solid',
                                        fgColor: cell.isValid 
                                            ? { argb: 'FF00FF00' } // Green for valid
                                            : { argb: 'FFFF0000' } // Red for invalid
                                    };
                                }
                            });
                        });
                    } else {
                        // Handle Excel files (.xlsx, .xls)
                        const arrayBuffer = await file.arrayBuffer();
                        
                        try {
                            if (fileName.endsWith('.xlsx')) {
                                await excelWorkbook.xlsx.load(arrayBuffer);
                            } else if (fileName.endsWith('.xls')) {
                                throw new Error('XLS format (.xls) is not fully supported. Please convert to XLSX format or use CSV.');
                            } else {
                                throw new Error('Unsupported file format. Please use .xlsx, .xls, or .csv');
                            }
                        } catch (loadError) {
                            if (loadError.message.includes('not fully supported') || loadError.message.includes('Unsupported')) {
                                throw loadError;
                            }
                            throw new Error('Failed to read Excel file. The file may be corrupted or in an unsupported format: ' + loadError.message);
                        }
                        
                        // Process each sheet
                        allSheetNames.forEach((sheetName, sheetIndex) => {
                            const worksheet = excelWorkbook.getWorksheet(sheetName) || excelWorkbook.worksheets[sheetIndex];
                            if (!worksheet) return;
                            
                            // Filter logo color cells for this specific sheet
                            const sheetLogoColorCells = logoColorCells.filter(cell => cell.sheetId === sheetIndex);
                            
                            // Highlight cells in this sheet
                            sheetLogoColorCells.forEach(cell => {
                                const excelRow = worksheet.getRow(cell.row);
                                const excelCell = excelRow.getCell(cell.col + 1);
                                
                                excelCell.fill = {
                                    type: 'pattern',
                                    pattern: 'solid',
                                    fgColor: cell.isValid 
                                        ? { argb: 'FF00FF00' } // Green for valid
                                        : { argb: 'FFFF0000' } // Red for invalid
                                };
                            });
                        });
                    }

                    // Generate download
                    const buffer = await excelWorkbook.xlsx.writeBuffer();
                    const downloadFileName = isCSV ? 'logo-color-verified.xlsx' : file.name.replace(/\.(xlsx|xls|csv)$/i, '_verified.xlsx');
                    const blob = new Blob([buffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = downloadFileName;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    
                    // Show success message
                    const successMsg = document.createElement('div');
                    successMsg.style.cssText = 'margin-top: 20px; padding: 15px; background: #d4edda; border-radius: 6px; border-left: 4px solid #28a745; color: #155724;';
                    successMsg.innerHTML = `âœ… File downloaded with highlighted cells across ${allSheetNames.length} sheet(s)! Green = Valid, Red = Invalid`;
                    logoColorResultsSection.appendChild(successMsg);
                    setTimeout(() => successMsg.remove(), 5000);
                } catch (error) {
                    console.error('Error highlighting in Excel:', error);
                    throw new Error('Failed to highlight Excel file: ' + error.message);
                }
            }

            function displayLogoColorResults(results) {
                logoColorResults.innerHTML = '';

                const validCount = results.filter(r => r.isValid).length;
                const invalidCount = results.filter(r => !r.isValid).length;
                const totalCount = results.length;

                // Create summary section with table
                const summaryDiv = document.createElement('div');
                summaryDiv.style.cssText = 'margin-bottom: 30px; padding: 20px; background: linear-gradient(135deg, rgba(86, 18, 189, 0.1) 0%, rgba(146, 80, 242, 0.1) 100%); border-radius: 12px; border-left: 4px solid #5612BD;';
                summaryDiv.innerHTML = `
                    <h3 style="margin: 0 0 15px 0; color: #250651; font-size: 1.3rem;">Summary</h3>
                    <table style="width: 100%; border-collapse: collapse; background: white; border-radius: 8px; overflow: hidden; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                        <thead>
                            <tr style="background-color: #5612BD; color: #fff;">
                                <th style="padding: 12px; text-align: left; font-weight: 600;">Status</th>
                                <th style="padding: 12px; text-align: left; font-weight: 600;">Count</th>
                                <th style="padding: 12px; text-align: left; font-weight: 600;">Color</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr style="border-bottom: 1px solid #eee;">
                                <td style="padding: 12px;"><span style="color: #28a745; font-weight: 600;">Valid</span></td>
                                <td style="padding: 12px; font-weight: 600;">${validCount}</td>
                                <td style="padding: 12px;"><span style="color: #28a745; font-weight: 600;">Green</span></td>
                            </tr>
                            <tr style="border-bottom: 1px solid #eee;">
                                <td style="padding: 12px;"><span style="color: #dc3545; font-weight: 600;">Invalid</span></td>
                                <td style="padding: 12px; font-weight: 600;">${invalidCount}</td>
                                <td style="padding: 12px;"><span style="color: #dc3545; font-weight: 600;">Red</span></td>
                            </tr>
                            <tr style="background-color: #f8f9fa;">
                                <td style="padding: 12px; font-weight: 600;">Total</td>
                                <td style="padding: 12px; font-weight: 600;">${totalCount}</td>
                                <td style="padding: 12px;">-</td>
                            </tr>
                        </tbody>
                    </table>
                `;
                logoColorResults.appendChild(summaryDiv);

                const table = document.createElement('table');
                table.className = 'results-table';
                table.innerHTML = `
                    <thead>
                        <tr>
                            <th>Row</th>
                            <th>Column</th>
                            <th>Value</th>
                            <th>Version</th>
                            <th>Expected</th>
                            <th>Status</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                `;

                const tbody = table.querySelector('tbody');
                
                results.forEach(result => {
                    const row = document.createElement('tr');
                    const statusText = result.isValid ? 'âœ“ Valid' : 'âœ— Invalid';
                    const colorCode = result.isValid ? '#28a745' : '#dc3545';
                    const columnName = result.column || getColumnLetter(result.col);
                    
                    row.innerHTML = `
                        <td>${result.row}</td>
                        <td>${columnName}</td>
                        <td>${result.cellValue}</td>
                        <td>${result.version}</td>
                        <td>${result.expectedColor}</td>
                        <td><span style="color: ${colorCode}; font-weight: 600;">${statusText}</span></td>
                    `;
                    
                    tbody.appendChild(row);
                });

                logoColorResults.appendChild(table);
            }

            function displayLogoColorResultsForAllSheets(sheetResults) {
                logoColorResults.innerHTML = '';

                // Calculate totals
                const totalSheets = sheetResults.length;
                let totalCells = 0;
                let totalValid = 0;
                let totalInvalid = 0;
                
                sheetResults.forEach(sheet => {
                    totalCells += sheet.logoColorCells.length;
                    totalValid += sheet.logoColorCells.filter(c => c.isValid).length;
                    totalInvalid += sheet.logoColorCells.filter(c => !c.isValid).length;
                });

                // Create summary section with table
                const summaryDiv = document.createElement('div');
                summaryDiv.style.cssText = 'margin-bottom: 30px; padding: 20px; background: linear-gradient(135deg, rgba(86, 18, 189, 0.1) 0%, rgba(146, 80, 242, 0.1) 100%); border-radius: 12px; border-left: 4px solid #5612BD;';
                summaryDiv.innerHTML = `
                    <h3 style="margin: 0 0 15px 0; color: #250651; font-size: 1.3rem;">Summary</h3>
                    <table style="width: 100%; border-collapse: collapse; background: white; border-radius: 8px; overflow: hidden; box-shadow: 0 2px 4px rgba(0,0,0,0.1); margin-bottom: 20px;">
                        <thead>
                            <tr style="background-color: #5612BD; color: #fff;">
                                <th style="padding: 12px; text-align: left; font-weight: 600;">Sheet</th>
                                <th style="padding: 12px; text-align: left; font-weight: 600;">Total Cells</th>
                                <th style="padding: 12px; text-align: left; font-weight: 600;">Valid</th>
                                <th style="padding: 12px; text-align: left; font-weight: 600;">Invalid</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${sheetResults.map(sheet => {
                                const sheetValid = sheet.logoColorCells.filter(c => c.isValid).length;
                                const sheetInvalid = sheet.logoColorCells.filter(c => !c.isValid).length;
                                return `
                                <tr style="border-bottom: 1px solid #eee;">
                                    <td style="padding: 12px; font-weight: 600; color: #5612BD;">${sheet.sheetName}</td>
                                    <td style="padding: 12px;">${sheet.logoColorCells.length}</td>
                                    <td style="padding: 12px;"><span style="color: #28a745; font-weight: 600;">${sheetValid}</span></td>
                                    <td style="padding: 12px;"><span style="color: #dc3545; font-weight: 600;">${sheetInvalid}</span></td>
                                </tr>
                                `;
                            }).join('')}
                            <tr style="background-color: #f8f9fa; font-weight: 600;">
                                <td style="padding: 12px;">Total</td>
                                <td style="padding: 12px;">${totalCells}</td>
                                <td style="padding: 12px;"><span style="color: #28a745;">${totalValid}</span></td>
                                <td style="padding: 12px;"><span style="color: #dc3545;">${totalInvalid}</span></td>
                            </tr>
                        </tbody>
                    </table>
                `;
                logoColorResults.appendChild(summaryDiv);

                // Create a table for all logo color cells
                const table = document.createElement('table');
                table.className = 'results-table';
                table.style.width = '100%';
                table.style.borderCollapse = 'collapse';
                table.style.marginTop = '20px';
                table.style.backgroundColor = '#fff';
                table.style.borderRadius = '6px';
                table.style.overflow = 'hidden';
                table.style.boxShadow = '0 2px 4px rgba(0, 0, 0, 0.1)';
                table.innerHTML = `
                    <thead>
                        <tr style="background-color: #5612BD; color: #fff;">
                            <th style="padding: 12px; text-align: left; font-weight: 600;">Sheet</th>
                            <th style="padding: 12px; text-align: left; font-weight: 600;">Row</th>
                            <th style="padding: 12px; text-align: left; font-weight: 600;">Column</th>
                            <th style="padding: 12px; text-align: left; font-weight: 600;">Value</th>
                            <th style="padding: 12px; text-align: left; font-weight: 600;">Version</th>
                            <th style="padding: 12px; text-align: left; font-weight: 600;">Expected</th>
                            <th style="padding: 12px; text-align: left; font-weight: 600;">Status</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                `;

                const tbody = table.querySelector('tbody');
                
                sheetResults.forEach(sheet => {
                    sheet.logoColorCells.forEach(result => {
                        const row = document.createElement('tr');
                        const statusText = result.isValid ? 'âœ“ Valid' : 'âœ— Invalid';
                        const colorCode = result.isValid ? '#28a745' : '#dc3545';
                        const columnName = result.column || getColumnLetter(result.col);
                        
                        row.innerHTML = `
                            <td style="padding: 10px; border-bottom: 1px solid #eee;">${sheet.sheetName}</td>
                            <td style="padding: 10px; border-bottom: 1px solid #eee;">${result.row}</td>
                            <td style="padding: 10px; border-bottom: 1px solid #eee;">${columnName}</td>
                            <td style="padding: 10px; border-bottom: 1px solid #eee;">${result.cellValue}</td>
                            <td style="padding: 10px; border-bottom: 1px solid #eee;">${result.version}</td>
                            <td style="padding: 10px; border-bottom: 1px solid #eee;">${result.expectedColor}</td>
                            <td style="padding: 10px; border-bottom: 1px solid #eee;"><span style="color: ${colorCode}; font-weight: 600;">${statusText}</span></td>
                        `;
                        
                        tbody.appendChild(row);
                    });
                });

                logoColorResults.appendChild(table);
            }

            // Warranty Logo Orientation functionality
            const logoOrientationDropdown = document.getElementById('logo-orientation-sheet-type');
            const logoOrientationInput = document.getElementById('logo-orientation-input');
            const logoOrientationValueInput = document.getElementById('logo-orientation-value');
            const logoOrientationLabel = document.getElementById('logo-orientation-label');
            
            logoOrientationDropdown.addEventListener('change', function() {
                if (this.value) {
                    logoOrientationInput.classList.add('active');
                    if (this.value === 'excel-csv') {
                        logoOrientationValueInput.type = 'file';
                        logoOrientationValueInput.accept = '.xlsx,.xls,.csv';
                        logoOrientationValueInput.placeholder = '';
                        logoOrientationLabel.textContent = 'Select file';
                    } else if (this.value === 'gsheet') {
                        logoOrientationValueInput.type = 'text';
                        logoOrientationValueInput.accept = '';
                        logoOrientationValueInput.placeholder = 'Enter GSheet URL';
                        logoOrientationLabel.textContent = 'Enter GSheet URL';
                    }
                } else {
                    logoOrientationInput.classList.remove('active');
                }
            });

            // Warranty Logo Orientation button functionality
            const logoOrientationButton = document.getElementById('logo-orientation-btn');
            const logoOrientationResultsSection = document.getElementById('logo-orientation-results-section');
            const logoOrientationLoadingMessage = document.getElementById('logo-orientation-loading-message');
            const logoOrientationErrorMessage = document.getElementById('logo-orientation-error-message');
            const logoOrientationNoResults = document.getElementById('logo-orientation-no-results');
            const logoOrientationResults = document.getElementById('logo-orientation-results');
            const logoOrientationResultsCount = document.getElementById('logo-orientation-results-count');

            function showLogoOrientationError(message) {
                // Show results section
                logoOrientationResultsSection.classList.add('active');
                logoOrientationErrorMessage.textContent = message;
                logoOrientationErrorMessage.style.display = 'block';
                logoOrientationLoadingMessage.style.display = 'none';
                logoOrientationNoResults.style.display = 'none';
            }

            function clearLogoOrientationResults() {
                logoOrientationResults.innerHTML = '';
                logoOrientationErrorMessage.style.display = 'none';
                logoOrientationNoResults.style.display = 'none';
                logoOrientationResultsCount.textContent = '';
            }

            let logoOrientationCurrentSheetId = null;
            let logoOrientationCurrentGid = null;
            let logoOrientationCurrentSheetUrl = null;
            let logoOrientationCurrentWorkbook = null;

            logoOrientationButton.addEventListener('click', async function() {
                const sheetType = logoOrientationDropdown.value;
                const sheetValue = logoOrientationValueInput.value;

                if (!sheetType) {
                    showLogoOrientationError('Please select a sheet type');
                    return;
                }

                if (!sheetValue) {
                    showLogoOrientationError('Please provide a sheet URL or file');
                    return;
                }

                clearLogoOrientationResults();
                // Show results section
                logoOrientationResultsSection.classList.add('active');
                logoOrientationLoadingMessage.style.display = 'block';
                logoOrientationButton.disabled = true;
                logoOrientationButton.textContent = 'Processing...';

                try {
                    let data = [];
                    let workbook = null;
                    
                    if (sheetType === 'gsheet') {
                        // Read Google Sheet with workbook info
                        const result = await readGoogleSheetWithWorkbook(sheetValue);
                        logoOrientationCurrentSheetId = result.sheetId;
                        logoOrientationCurrentGid = result.gid;
                        logoOrientationCurrentSheetUrl = result.url || sheetValue;
                        const spreadsheetId = result.sheetId;
                        const processAllSheets = result.processAllSheets === true;

                        if (processAllSheets) {
                            // Process all sheets independently
                            const allSheets = await getAllSheets(spreadsheetId);
                            if (allSheets.length === 0) {
                                throw new Error('Could not retrieve sheet list. Please specify a specific sheet in the URL (add #gid=XXX to the URL).');
                            }

                            console.log(`Processing ${allSheets.length} sheets for Warranty Logo Orientation:`, allSheets.map(s => s.title));
                            
                            let allLogoOrientationCells = [];
                            const sheetResults = [];

                            // Process each sheet separately
                            for (const sheet of allSheets) {
                                try {
                                    console.log(`Reading sheet: ${sheet.title} (gid: ${sheet.sheetId})`);
                                    
                                    // Read this specific sheet
                                    const sheetUrl = `https://docs.google.com/spreadsheets/d/${spreadsheetId}/export?format=csv&gid=${sheet.sheetId}`;
                                    const sheetResult = await readGoogleSheetCSV(sheetUrl);
                                    
                                    // Find logo orientation cells in this sheet
                                    let sheetLogoOrientationCells = [];
                                    try {
                                        sheetLogoOrientationCells = findLogoOrientationCells(sheetResult.data);
                                    } catch (logoError) {
                                        if (logoError.message.includes('version column is not present')) {
                                            alert(`version column is not present in sheet "${sheet.title}"`);
                                            continue; // Skip this sheet
                                        }
                                        throw logoError;
                                    }
                                    
                                    // Add sheetId to each cell
                                    sheetLogoOrientationCells.forEach(cell => {
                                        cell.sheetId = parseInt(sheet.sheetId);
                                        cell.sheetName = sheet.title;
                                    });
                                    
                                    if (sheetLogoOrientationCells.length > 0) {
                                        sheetResults.push({
                                            sheetName: sheet.title,
                                            sheetId: sheet.sheetId,
                                            logoOrientationCells: sheetLogoOrientationCells
                                        });
                                        allLogoOrientationCells = allLogoOrientationCells.concat(sheetLogoOrientationCells);
                                    }
                                    
                                    console.log(`Found ${sheetLogoOrientationCells.length} logo orientation cells in "${sheet.title}"`);
                                } catch (sheetError) {
                                    console.error(`Error processing sheet "${sheet.title}":`, sheetError);
                                    // Continue with other sheets
                                }
                            }

                            // Store logo orientation cells for highlighting
                            const logoOrientationCells = allLogoOrientationCells;
                            
                            logoOrientationLoadingMessage.style.display = 'none';
                            logoOrientationButton.disabled = false;
                            logoOrientationButton.textContent = 'Verify Warranty Logo Orientation';

                            if (logoOrientationCells.length === 0) {
                                logoOrientationNoResults.style.display = 'block';
                                logoOrientationResultsCount.textContent = `0 cells found across ${allSheets.length} sheet(s)`;
                            } else {
                                // Highlight cells in all sheets
                                await highlightLogoOrientationInGSheetAllSheets(logoOrientationCells, spreadsheetId, allSheets);
                                
                                displayLogoOrientationResultsForAllSheets(sheetResults);
                                const validCount = logoOrientationCells.filter(c => c.isValid).length;
                                const invalidCount = logoOrientationCells.filter(c => !c.isValid).length;
                                logoOrientationResultsCount.textContent = `${logoOrientationCells.length} cells checked across ${sheetResults.length} sheet(s): ${validCount} valid (green), ${invalidCount} invalid (red)`;
                            }
                        } else {
                            // Process single sheet (existing behavior)
                            data = result.data;
                            workbook = result.workbook;

                            // Find logo orientation cells
                            let logoOrientationCells = [];
                            try {
                                logoOrientationCells = findLogoOrientationCells(data);
                            } catch (logoError) {
                                if (logoError.message.includes('version column is not present')) {
                                    alert('version column is not present');
                                    logoOrientationLoadingMessage.style.display = 'none';
                                    logoOrientationButton.disabled = false;
                                    logoOrientationButton.textContent = 'Verify Warranty Logo Orientation';
                                    return;
                                }
                                throw logoError;
                            }
                            
                            logoOrientationLoadingMessage.style.display = 'none';
                            logoOrientationButton.disabled = false;
                            logoOrientationButton.textContent = 'Verify Warranty Logo Orientation';

                            if (logoOrientationCells.length === 0) {
                                logoOrientationNoResults.style.display = 'block';
                                logoOrientationResultsCount.textContent = '0 cells found';
                            } else {
                                // Highlight cells
                                await highlightLogoOrientationInGSheet(logoOrientationCells);
                                
                                displayLogoOrientationResults(logoOrientationCells);
                                const validCount = logoOrientationCells.filter(c => c.isValid).length;
                                const invalidCount = logoOrientationCells.filter(c => !c.isValid).length;
                                logoOrientationResultsCount.textContent = `${logoOrientationCells.length} cells checked: ${validCount} valid (green), ${invalidCount} invalid (red)`;
                            }
                        }
                    } else if (sheetType === 'excel-csv') {
                        // Read Excel/CSV file
                        const file = logoOrientationValueInput.files[0];
                        if (!file) {
                            throw new Error('Please select a file');
                        }
                        const result = await readExcelFileWithWorkbook(file);
                        workbook = result.workbook;
                        logoOrientationCurrentWorkbook = workbook;
                        
                        // Process all sheets in the workbook (similar to GSheet)
                        const allSheetNames = workbook.SheetNames;
                        
                        if (allSheetNames.length > 1) {
                            // Process all sheets independently
                            console.log(`Processing ${allSheetNames.length} sheets for Warranty Logo Orientation:`, allSheetNames);
                            
                            let allLogoOrientationCells = [];
                            const sheetResults = [];

                            // Process each sheet separately
                            for (const sheetName of allSheetNames) {
                                try {
                                    console.log(`Reading sheet: ${sheetName}`);
                                    
                                    // Read this specific sheet
                                    const worksheet = workbook.Sheets[sheetName];
                                    const sheetData = XLSX.utils.sheet_to_json(worksheet, { header: 1, defval: null });
                                    
                                    // Find logo orientation cells in this sheet
                                    let sheetLogoOrientationCells = [];
                                    try {
                                        sheetLogoOrientationCells = findLogoOrientationCells(sheetData);
                                    } catch (logoError) {
                                        if (logoError.message.includes('version column is not present')) {
                                            alert(`version column is not present in sheet "${sheetName}"`);
                                            continue; // Skip this sheet
                                        }
                                        throw logoError;
                                    }
                                    
                                    // Add sheetId and sheetName to each cell
                                    sheetLogoOrientationCells.forEach(cell => {
                                        cell.sheetId = allSheetNames.indexOf(sheetName);
                                        cell.sheetName = sheetName;
                                    });
                                    
                                    if (sheetLogoOrientationCells.length > 0) {
                                        sheetResults.push({
                                            sheetName: sheetName,
                                            sheetId: allSheetNames.indexOf(sheetName),
                                            logoOrientationCells: sheetLogoOrientationCells
                                        });
                                        allLogoOrientationCells = allLogoOrientationCells.concat(sheetLogoOrientationCells);
                                    }
                                    
                                    console.log(`Found ${sheetLogoOrientationCells.length} logo orientation cells in "${sheetName}"`);
                                } catch (sheetError) {
                                    console.error(`Error processing sheet "${sheetName}":`, sheetError);
                                    // Continue with other sheets
                                }
                            }

                            // Store logo orientation cells for highlighting
                            const logoOrientationCells = allLogoOrientationCells;
                            
                            logoOrientationLoadingMessage.style.display = 'none';
                            logoOrientationButton.disabled = false;
                            logoOrientationButton.textContent = 'Verify Warranty Logo Orientation';

                            if (logoOrientationCells.length === 0) {
                                logoOrientationNoResults.style.display = 'block';
                                logoOrientationResultsCount.textContent = `0 cells found across ${allSheetNames.length} sheet(s)`;
                            } else {
                                // Highlight cells in all sheets
                                await highlightLogoOrientationInExcelAllSheets(logoOrientationCells, file, allSheetNames);
                                
                                displayLogoOrientationResultsForAllSheets(sheetResults);
                                const validCount = logoOrientationCells.filter(c => c.isValid).length;
                                const invalidCount = logoOrientationCells.filter(c => !c.isValid).length;
                                logoOrientationResultsCount.textContent = `${logoOrientationCells.length} cells checked across ${sheetResults.length} sheet(s): ${validCount} valid (green), ${invalidCount} invalid (red)`;
                            }
                        } else {
                            // Single sheet - process normally
                            data = result.data;

                            // Find logo orientation cells
                            let logoOrientationCells = [];
                            try {
                                logoOrientationCells = findLogoOrientationCells(data);
                            } catch (logoError) {
                                if (logoError.message.includes('version column is not present')) {
                                    alert('version column is not present');
                                    logoOrientationLoadingMessage.style.display = 'none';
                                    logoOrientationButton.disabled = false;
                                    logoOrientationButton.textContent = 'Verify Warranty Logo Orientation';
                                    return;
                                }
                                throw logoError;
                            }
                            
                            logoOrientationLoadingMessage.style.display = 'none';
                            logoOrientationButton.disabled = false;
                            logoOrientationButton.textContent = 'Verify Warranty Logo Orientation';

                            if (logoOrientationCells.length === 0) {
                                logoOrientationNoResults.style.display = 'block';
                                logoOrientationResultsCount.textContent = '0 cells found';
                            } else {
                                // Highlight cells based on validation
                                await highlightLogoOrientationInExcel(logoOrientationCells, file);
                                
                                displayLogoOrientationResults(logoOrientationCells);
                                const validCount = logoOrientationCells.filter(c => c.isValid).length;
                                const invalidCount = logoOrientationCells.filter(c => !c.isValid).length;
                                logoOrientationResultsCount.textContent = `${logoOrientationCells.length} cells checked: ${validCount} valid (green), ${invalidCount} invalid (red)`;
                            }
                        }
                    }
                } catch (error) {
                    console.error('Error:', error);
                    showLogoOrientationError('Error: ' + error.message);
                    logoOrientationButton.disabled = false;
                    logoOrientationButton.textContent = 'Verify Warranty Logo Orientation';
                }
            });

            // Warranty Logo Orientation verification functions
            function findLogoOrientationCells(data) {
                const cells = [];
                
                // Vertical orientation columns (should contain _VER_)
                const verticalColumns = [
                    'LOGO_320x160',
                    'LOGO_320x100',
                    'LOGO_980x240',
                    'LOGO_980x300',
                    'LOGO_930x180',
                    'LOGO_800x250',
                    'LOGO_970x250'
                ];
                
                // Horizontal orientation columns (should contain _HOR_)
                const horizontalColumns = [
                    'LOGO_250x600',
                    'LOGO_728x90',
                    'LOGO_120x600',
                    'LOGO_200x600',
                    'LOGO_160x600',
                    'LOGO_320x320',
                    'LOGO_320x250',
                    'LOGO_300x250',
                    'LOGO_580x400',
                    'LOGO_980x600',
                    'LOGO_320x480',
                    'LOGO_320x400',
                    'LOGO_640x320',
                    'LOGO_300x600'
                ];
                
                // Combine all logo columns
                const allLogoColumns = [...verticalColumns, ...horizontalColumns];
                
                // Handle both 2D array format and JSON object format
                let rows = [];
                let headers = [];
                let skippedHeaderRow = false;
                
                if (Array.isArray(data) && data.length > 0) {
                    if (Array.isArray(data[0])) {
                        // 2D array format - first row is headers
                        headers = data[0] || [];
                        rows = data.slice(1); // Skip header row
                        skippedHeaderRow = true;
                    } else {
                        // JSON object format - convert to 2D array
                        const allKeys = new Set();
                        data.forEach(obj => {
                            Object.keys(obj).forEach(key => allKeys.add(key));
                        });
                        headers = Array.from(allKeys);
                        
                        rows = data.map(obj => {
                            return headers.map(key => obj[key] || '');
                        });
                        skippedHeaderRow = false;
                    }
                }
                
                // Find logo column indices and their expected orientation
                const logoColumnInfo = {};
                allLogoColumns.forEach(logoCol => {
                    const index = headers.findIndex(h => 
                        h && h.toString().trim() === logoCol
                    );
                    if (index !== -1) {
                        const isVertical = verticalColumns.includes(logoCol);
                        const expectedOrientation = isVertical ? '_VER_' : '_HOR_';
                        logoColumnInfo[logoCol] = {
                            index: index,
                            expectedOrientation: expectedOrientation,
                            isVertical: isVertical
                        };
                    }
                });
                
                // Process each row
                rows.forEach((row, rowIndex) => {
                    if (Array.isArray(row)) {
                        // Check each logo column that exists
                        Object.keys(logoColumnInfo).forEach(logoCol => {
                            const colInfo = logoColumnInfo[logoCol];
                            const colIndex = colInfo.index;
                            const cellValue = row[colIndex];
                            const cellValueStr = cellValue ? String(cellValue) : '';
                            
                            // Check if cell value contains the expected orientation string (case-insensitive)
                            const containsExpectedOrientation = cellValueStr.toLowerCase().includes(colInfo.expectedOrientation.toLowerCase());
                            
                            // Row number: +2 if we skipped header row, +1 if we didn't (1-based for display)
                            const rowNumber = skippedHeaderRow ? rowIndex + 2 : rowIndex + 1;
                            
                            cells.push({
                                row: rowNumber,
                                col: colIndex, // 0-based for API
                                column: logoCol,
                                cellValue: cellValueStr,
                                expectedOrientation: colInfo.expectedOrientation,
                                isValid: containsExpectedOrientation,
                                actualValue: cellValueStr
                            });
                        });
                    }
                });
                
                return cells;
            }

            async function highlightLogoOrientationInGSheet(logoOrientationCells) {
                const sheetId = logoOrientationCurrentSheetId || window.currentGSheetId;
                const gid = logoOrientationCurrentGid !== null && logoOrientationCurrentGid !== undefined 
                    ? logoOrientationCurrentGid 
                    : (window.currentGSheetGid || '0');
                
                if (!sheetId) {
                    throw new Error('Google Sheet information not available. Please make sure you selected a valid Google Sheet.');
                }
                
                const highlightBtn = logoOrientationButton;
                if (highlightBtn) {
                    highlightBtn.disabled = true;
                    highlightBtn.textContent = 'Highlighting cells...';
                }

                try {
                    const parsedGid = parseInt(gid);
                    
                    if (logoOrientationCells.length === 0) {
                        return;
                    }

                    // Determine server URL
                    const serverUrl = window.location.protocol === 'file:' 
                        ? 'http://localhost:3000' 
                        : window.location.origin;

                    // Prepare cells with validation info
                    const cellsToHighlight = logoOrientationCells.map(cell => {
                        const isValid = cell.isValid === true;
                        return {
                            rowIndex: cell.row - 1,
                            colIndex: cell.col,
                            isValid: isValid // true for valid, false for invalid
                        };
                    });
                    
                    // Call Node.js server API
                    const response = await fetch(`${serverUrl}/api/highlight-cells`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            spreadsheetId: sheetId,
                            sheetId: parsedGid,
                            cells: cellsToHighlight
                        })
                    });

                    // Check if response is HTML (error page) instead of JSON
                    const responseText = await response.text();
                    let data;
                    
                    try {
                        if (responseText.trim().startsWith('<!DOCTYPE') || 
                            responseText.trim().startsWith('<html') ||
                            responseText.includes('<!DOCTYPE')) {
                            throw new Error('Server returned HTML instead of JSON');
                        }
                        data = JSON.parse(responseText);
                    } catch (parseError) {
                        console.error('Failed to parse response:', parseError);
                        throw new Error(`Server returned invalid response: ${parseError.message}`);
                    }

                    if (!response.ok) {
                        throw new Error(data.error || 'Failed to highlight cells');
                    }

                    // Show success message
                    const successMsg = document.createElement('div');
                    successMsg.style.cssText = 'margin-top: 20px; padding: 15px; background: #d4edda; border-radius: 6px; border-left: 4px solid #28a745; color: #155724;';
                    successMsg.innerHTML = 'âœ… Cells highlighted in Google Sheet! Green = Valid, Red = Invalid';
                    logoOrientationResultsSection.appendChild(successMsg);
                    setTimeout(() => successMsg.remove(), 5000);

                    if (highlightBtn) {
                        highlightBtn.disabled = false;
                        highlightBtn.textContent = 'Verify Warranty Logo Orientation';
                    }
                } catch (error) {
                    console.error('Error highlighting in GSheet:', error);
                    if (highlightBtn) {
                        highlightBtn.disabled = false;
                        highlightBtn.textContent = 'Verify Warranty Logo Orientation';
                    }
                    throw error;
                }
            }

            async function highlightLogoOrientationInGSheetAllSheets(logoOrientationCells, spreadsheetId, allSheets) {
                if (!spreadsheetId || !allSheets || allSheets.length === 0) {
                    throw new Error('Invalid sheet information for highlighting');
                }

                console.log(`Highlighting Warranty Logo Orientation in ${allSheets.length} sheets...`);
                
                const highlightBtn = logoOrientationButton;
                if (highlightBtn) {
                    highlightBtn.disabled = true;
                    highlightBtn.textContent = 'Highlighting cells...';
                }

                try {
                    // Determine server URL
                    const serverUrl = window.location.protocol === 'file:' 
                        ? 'http://localhost:3000' 
                        : window.location.origin;

                    let totalUpdated = 0;
                    let processedCount = 0;
                    const errors = [];

                    // Process each sheet
                    for (const sheet of allSheets) {
                        try {
                            const gid = parseInt(sheet.sheetId);
                            const normalizedGid = isNaN(gid) ? 0 : gid;
                            
                            console.log(`Processing sheet: ${sheet.title} (gid: ${gid})`);
                            
                            // Filter logo orientation cells for this specific sheet
                            const sheetLogoOrientationCells = logoOrientationCells.filter(cell => {
                                const cellSheetId = cell.sheetId !== undefined ? parseInt(cell.sheetId) : null;
                                return cellSheetId === normalizedGid;
                            });
                            
                            console.log(`  â†’ Filtered ${sheetLogoOrientationCells.length} logo orientation cells for "${sheet.title}" (gid: ${normalizedGid}) from total ${logoOrientationCells.length} cells`);
                            
                            if (sheetLogoOrientationCells.length === 0) {
                                console.log(`  â†’ No logo orientation cells found in "${sheet.title}", skipping...`);
                                continue;
                            }

                            // Prepare cell data for this sheet
                            const cellsToHighlight = sheetLogoOrientationCells.map(cell => {
                                const isValid = cell.isValid === true;
                                return {
                                    rowIndex: cell.row - 1,
                                    colIndex: cell.col,
                                    isValid: isValid
                                };
                            });
                            
                            console.log(`  â†’ Highlighting ${cellsToHighlight.length} logo orientation cells in "${sheet.title}"`);
                            
                            // Send request to backend
                            const requestBody = {
                                spreadsheetId: spreadsheetId,
                                sheetId: normalizedGid,
                                cells: cellsToHighlight
                            };
                            
                            const response = await fetch(`${serverUrl}/api/highlight-cells`, {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json'
                                },
                                body: JSON.stringify(requestBody)
                            });

                            // Check if response is HTML (error page) instead of JSON
                            const responseText = await response.text();
                            let data;
                            
                            try {
                                if (responseText.trim().startsWith('<!DOCTYPE') || 
                                    responseText.trim().startsWith('<html') ||
                                    responseText.includes('<!DOCTYPE')) {
                                    throw new Error('Server returned HTML instead of JSON');
                                }
                                data = JSON.parse(responseText);
                            } catch (parseError) {
                                console.error(`  â†’ âŒ Failed to parse response for "${sheet.title}":`, parseError);
                                throw new Error(`Server returned invalid response: ${parseError.message}`);
                            }

                            if (!response.ok) {
                                throw new Error(data.error || `Failed to highlight cells in "${sheet.title}"`);
                            }

                            const updatedCount = data.updatedCells || cellsToHighlight.length;
                            totalUpdated += updatedCount;
                            processedCount++;
                            
                            console.log(`  â†’ âœ… Successfully highlighted ${updatedCount} cells in "${sheet.title}"`);
                            
                            // Small delay to prevent rate limiting
                            if (processedCount < allSheets.length) {
                                await new Promise(resolve => setTimeout(resolve, 500));
                            }
                        } catch (sheetError) {
                            console.error(`  â†’ âŒ Error processing sheet "${sheet.title}":`, sheetError);
                            errors.push({ sheet: sheet.title, error: sheetError.message });
                        }
                    }

                    // Show summary
                    if (processedCount > 0) {
                        const successMsg = document.createElement('div');
                        successMsg.style.cssText = 'margin-top: 20px; padding: 15px; background: #d4edda; border-radius: 6px; border-left: 4px solid #28a745; color: #155724;';
                        successMsg.innerHTML = `âœ… Highlighted ${totalUpdated} cells across ${processedCount} sheet(s)! Green = Valid, Red = Invalid`;
                        logoOrientationResultsSection.appendChild(successMsg);
                        setTimeout(() => successMsg.remove(), 5000);
                    }

                    if (errors.length > 0) {
                        const errorMsg = document.createElement('div');
                        errorMsg.style.cssText = 'margin-top: 10px; padding: 15px; background: #f8d7da; border-radius: 6px; border-left: 4px solid #dc3545; color: #721c24;';
                        errorMsg.innerHTML = `âš ï¸ Some sheets had errors: ${errors.map(e => `${e.sheet}: ${e.error}`).join(', ')}`;
                        logoOrientationResultsSection.appendChild(errorMsg);
                    }

                    if (highlightBtn) {
                        highlightBtn.disabled = false;
                        highlightBtn.textContent = 'Verify Warranty Logo Orientation';
                    }
                } catch (error) {
                    console.error('Error highlighting in GSheets:', error);
                    if (highlightBtn) {
                        highlightBtn.disabled = false;
                        highlightBtn.textContent = 'Verify Warranty Logo Orientation';
                    }
                    throw error;
                }
            }

            async function highlightLogoOrientationInExcel(logoOrientationCells, file) {
                if (typeof ExcelJS === 'undefined') {
                    throw new Error('ExcelJS library not loaded. Please refresh the page.');
                }

                try {
                    if (!file) {
                        throw new Error('File not available');
                    }

                    const fileName = file.name.toLowerCase();
                    const isCSV = fileName.endsWith('.csv');

                    // Read the file with ExcelJS
                    const excelWorkbook = new ExcelJS.Workbook();
                    
                    if (isCSV) {
                        // Handle CSV files
                        const text = await file.text();
                        const worksheet = excelWorkbook.addWorksheet('Sheet1');
                        
                        // Parse CSV
                        const lines = text.split(/\r?\n/).filter(line => line.trim());
                        const parsedRows = [];
                        
                        lines.forEach((line) => {
                            const values = [];
                            let current = '';
                            let inQuotes = false;
                            
                            for (let i = 0; i < line.length; i++) {
                                const char = line[i];
                                if (char === '"') {
                                    inQuotes = !inQuotes;
                                } else if (char === ',' && !inQuotes) {
                                    values.push(current.trim());
                                    current = '';
                                } else {
                                    current += char;
                                }
                            }
                            values.push(current.trim());
                            parsedRows.push(values);
                        });
                        
                        // Add rows to worksheet
                        parsedRows.forEach((values, rowIndex) => {
                            const row = worksheet.addRow(values);
                            
                            // Highlight cells with logo orientations
                            logoOrientationCells.forEach(cell => {
                                if (cell.row === rowIndex + 1 && cell.col < values.length) {
                                    const excelCell = row.getCell(cell.col + 1);
                                    excelCell.fill = {
                                        type: 'pattern',
                                        pattern: 'solid',
                                        fgColor: cell.isValid 
                                            ? { argb: 'FF00FF00' } // Green for valid
                                            : { argb: 'FFFF0000' } // Red for invalid
                                    };
                                }
                            });
                        });
                    } else {
                        // Handle Excel files (.xlsx, .xls)
                        const arrayBuffer = await file.arrayBuffer();
                        
                        try {
                            if (fileName.endsWith('.xlsx')) {
                                await excelWorkbook.xlsx.load(arrayBuffer);
                            } else if (fileName.endsWith('.xls')) {
                                throw new Error('XLS format (.xls) is not fully supported. Please convert to XLSX format or use CSV.');
                            } else {
                                throw new Error('Unsupported file format. Please use .xlsx, .xls, or .csv');
                            }
                        } catch (loadError) {
                            if (loadError.message.includes('not fully supported') || loadError.message.includes('Unsupported')) {
                                throw loadError;
                            }
                            throw new Error('Failed to read Excel file. The file may be corrupted or in an unsupported format: ' + loadError.message);
                        }
                        
                        const worksheet = excelWorkbook.worksheets[0];
                        
                        logoOrientationCells.forEach(cell => {
                            const excelRow = worksheet.getRow(cell.row);
                            const excelCell = excelRow.getCell(cell.col + 1);
                            
                            excelCell.fill = {
                                type: 'pattern',
                                pattern: 'solid',
                                fgColor: cell.isValid 
                                    ? { argb: 'FF00FF00' } // Green for valid
                                    : { argb: 'FFFF0000' } // Red for invalid
                            };
                        });
                    }

                    // Generate download
                    const buffer = await excelWorkbook.xlsx.writeBuffer();
                    const downloadFileName = isCSV ? 'logo-orientation-verified.xlsx' : file.name.replace(/\.(xlsx|xls|csv)$/i, '_verified.xlsx');
                    const blob = new Blob([buffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = downloadFileName;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    
                    // Show success message
                    const successMsg = document.createElement('div');
                    successMsg.style.cssText = 'margin-top: 20px; padding: 15px; background: #d4edda; border-radius: 6px; border-left: 4px solid #28a745; color: #155724;';
                    successMsg.innerHTML = 'âœ… File downloaded with highlighted cells! Green = Valid, Red = Invalid';
                    logoOrientationResultsSection.appendChild(successMsg);
                    setTimeout(() => successMsg.remove(), 5000);
                } catch (error) {
                    console.error('Error highlighting in Excel:', error);
                    throw new Error('Failed to highlight Excel file: ' + error.message);
                }
            }

            async function highlightLogoOrientationInExcelAllSheets(logoOrientationCells, file, allSheetNames) {
                if (typeof ExcelJS === 'undefined') {
                    throw new Error('ExcelJS library not loaded. Please refresh the page.');
                }

                try {
                    if (!file) {
                        throw new Error('File not available');
                    }

                    const fileName = file.name.toLowerCase();
                    const isCSV = fileName.endsWith('.csv');

                    // Read the file with ExcelJS
                    const excelWorkbook = new ExcelJS.Workbook();
                    
                    if (isCSV) {
                        // CSV files only have one sheet, so process normally
                        const text = await file.text();
                        const worksheet = excelWorkbook.addWorksheet('Sheet1');
                        
                        const lines = text.split(/\r?\n/).filter(line => line.trim());
                        const parsedRows = [];
                        
                        lines.forEach((line) => {
                            const values = [];
                            let current = '';
                            let inQuotes = false;
                            
                            for (let i = 0; i < line.length; i++) {
                                const char = line[i];
                                if (char === '"') {
                                    inQuotes = !inQuotes;
                                } else if (char === ',' && !inQuotes) {
                                    values.push(current.trim());
                                    current = '';
                                } else {
                                    current += char;
                                }
                            }
                            values.push(current.trim());
                            parsedRows.push(values);
                        });
                        
                        parsedRows.forEach((values, rowIndex) => {
                            const row = worksheet.addRow(values);
                            
                            // Highlight cells with logo orientations (CSV only has one sheet, so sheetId is 0)
                            logoOrientationCells.filter(c => c.sheetId === 0).forEach(cell => {
                                if (cell.row === rowIndex + 1 && cell.col < values.length) {
                                    const excelCell = row.getCell(cell.col + 1);
                                    excelCell.fill = {
                                        type: 'pattern',
                                        pattern: 'solid',
                                        fgColor: cell.isValid 
                                            ? { argb: 'FF00FF00' } // Green for valid
                                            : { argb: 'FFFF0000' } // Red for invalid
                                    };
                                }
                            });
                        });
                    } else {
                        // Handle Excel files (.xlsx, .xls)
                        const arrayBuffer = await file.arrayBuffer();
                        
                        try {
                            if (fileName.endsWith('.xlsx')) {
                                await excelWorkbook.xlsx.load(arrayBuffer);
                            } else if (fileName.endsWith('.xls')) {
                                throw new Error('XLS format (.xls) is not fully supported. Please convert to XLSX format or use CSV.');
                            } else {
                                throw new Error('Unsupported file format. Please use .xlsx, .xls, or .csv');
                            }
                        } catch (loadError) {
                            if (loadError.message.includes('not fully supported') || loadError.message.includes('Unsupported')) {
                                throw loadError;
                            }
                            throw new Error('Failed to read Excel file. The file may be corrupted or in an unsupported format: ' + loadError.message);
                        }
                        
                        // Process each sheet
                        allSheetNames.forEach((sheetName, sheetIndex) => {
                            const worksheet = excelWorkbook.getWorksheet(sheetName) || excelWorkbook.worksheets[sheetIndex];
                            if (!worksheet) return;
                            
                            // Filter logo orientation cells for this specific sheet
                            const sheetLogoOrientationCells = logoOrientationCells.filter(cell => cell.sheetId === sheetIndex);
                            
                            // Highlight cells in this sheet
                            sheetLogoOrientationCells.forEach(cell => {
                                const excelRow = worksheet.getRow(cell.row);
                                const excelCell = excelRow.getCell(cell.col + 1);
                                
                                excelCell.fill = {
                                    type: 'pattern',
                                    pattern: 'solid',
                                    fgColor: cell.isValid 
                                        ? { argb: 'FF00FF00' } // Green for valid
                                        : { argb: 'FFFF0000' } // Red for invalid
                                };
                            });
                        });
                    }

                    // Generate download
                    const buffer = await excelWorkbook.xlsx.writeBuffer();
                    const downloadFileName = isCSV ? 'logo-orientation-verified.xlsx' : file.name.replace(/\.(xlsx|xls|csv)$/i, '_verified.xlsx');
                    const blob = new Blob([buffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = downloadFileName;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    
                    // Show success message
                    const successMsg = document.createElement('div');
                    successMsg.style.cssText = 'margin-top: 20px; padding: 15px; background: #d4edda; border-radius: 6px; border-left: 4px solid #28a745; color: #155724;';
                    successMsg.innerHTML = `âœ… File downloaded with highlighted cells across ${allSheetNames.length} sheet(s)! Green = Valid, Red = Invalid`;
                    logoOrientationResultsSection.appendChild(successMsg);
                    setTimeout(() => successMsg.remove(), 5000);
                } catch (error) {
                    console.error('Error highlighting in Excel:', error);
                    throw new Error('Failed to highlight Excel file: ' + error.message);
                }
            }

            function displayLogoOrientationResults(results) {
                logoOrientationResults.innerHTML = '';

                const validCount = results.filter(r => r.isValid).length;
                const invalidCount = results.filter(r => !r.isValid).length;
                const totalCount = results.length;

                // Create summary section with table
                const summaryDiv = document.createElement('div');
                summaryDiv.style.cssText = 'margin-bottom: 30px; padding: 20px; background: linear-gradient(135deg, rgba(86, 18, 189, 0.1) 0%, rgba(146, 80, 242, 0.1) 100%); border-radius: 12px; border-left: 4px solid #5612BD;';
                summaryDiv.innerHTML = `
                    <h3 style="margin: 0 0 15px 0; color: #250651; font-size: 1.3rem;">Summary</h3>
                    <table style="width: 100%; border-collapse: collapse; background: white; border-radius: 8px; overflow: hidden; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                        <thead>
                            <tr style="background-color: #5612BD; color: #fff;">
                                <th style="padding: 12px; text-align: left; font-weight: 600;">Status</th>
                                <th style="padding: 12px; text-align: left; font-weight: 600;">Count</th>
                                <th style="padding: 12px; text-align: left; font-weight: 600;">Color</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr style="border-bottom: 1px solid #eee;">
                                <td style="padding: 12px;"><span style="color: #28a745; font-weight: 600;">Valid</span></td>
                                <td style="padding: 12px; font-weight: 600;">${validCount}</td>
                                <td style="padding: 12px;"><span style="color: #28a745; font-weight: 600;">Green</span></td>
                            </tr>
                            <tr style="border-bottom: 1px solid #eee;">
                                <td style="padding: 12px;"><span style="color: #dc3545; font-weight: 600;">Invalid</span></td>
                                <td style="padding: 12px; font-weight: 600;">${invalidCount}</td>
                                <td style="padding: 12px;"><span style="color: #dc3545; font-weight: 600;">Red</span></td>
                            </tr>
                            <tr style="background-color: #f8f9fa;">
                                <td style="padding: 12px; font-weight: 600;">Total</td>
                                <td style="padding: 12px; font-weight: 600;">${totalCount}</td>
                                <td style="padding: 12px;">-</td>
                            </tr>
                        </tbody>
                    </table>
                `;
                logoOrientationResults.appendChild(summaryDiv);

                const table = document.createElement('table');
                table.className = 'results-table';
                table.innerHTML = `
                    <thead>
                        <tr>
                            <th>Row</th>
                            <th>Column</th>
                            <th>Value</th>
                            <th>Expected</th>
                            <th>Status</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                `;

                const tbody = table.querySelector('tbody');
                
                results.forEach(result => {
                    const row = document.createElement('tr');
                    const statusText = result.isValid ? 'âœ“ Valid' : 'âœ— Invalid';
                    const colorCode = result.isValid ? '#28a745' : '#dc3545';
                    const columnName = result.column || getColumnLetter(result.col);
                    
                    row.innerHTML = `
                        <td>${result.row}</td>
                        <td>${columnName}</td>
                        <td>${result.cellValue}</td>
                        <td>${result.expectedOrientation}</td>
                        <td><span style="color: ${colorCode}; font-weight: 600;">${statusText}</span></td>
                    `;
                    
                    tbody.appendChild(row);
                });

                logoOrientationResults.appendChild(table);
            }

            function displayLogoOrientationResultsForAllSheets(sheetResults) {
                logoOrientationResults.innerHTML = '';

                // Calculate totals
                const totalSheets = sheetResults.length;
                let totalCells = 0;
                let totalValid = 0;
                let totalInvalid = 0;
                
                sheetResults.forEach(sheet => {
                    totalCells += sheet.logoOrientationCells.length;
                    totalValid += sheet.logoOrientationCells.filter(c => c.isValid).length;
                    totalInvalid += sheet.logoOrientationCells.filter(c => !c.isValid).length;
                });

                // Create summary section with table
                const summaryDiv = document.createElement('div');
                summaryDiv.style.cssText = 'margin-bottom: 30px; padding: 20px; background: linear-gradient(135deg, rgba(86, 18, 189, 0.1) 0%, rgba(146, 80, 242, 0.1) 100%); border-radius: 12px; border-left: 4px solid #5612BD;';
                summaryDiv.innerHTML = `
                    <h3 style="margin: 0 0 15px 0; color: #250651; font-size: 1.3rem;">Summary</h3>
                    <table style="width: 100%; border-collapse: collapse; background: white; border-radius: 8px; overflow: hidden; box-shadow: 0 2px 4px rgba(0,0,0,0.1); margin-bottom: 20px;">
                        <thead>
                            <tr style="background-color: #5612BD; color: #fff;">
                                <th style="padding: 12px; text-align: left; font-weight: 600;">Sheet</th>
                                <th style="padding: 12px; text-align: left; font-weight: 600;">Total Cells</th>
                                <th style="padding: 12px; text-align: left; font-weight: 600;">Valid</th>
                                <th style="padding: 12px; text-align: left; font-weight: 600;">Invalid</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${sheetResults.map(sheet => {
                                const sheetValid = sheet.logoOrientationCells.filter(c => c.isValid).length;
                                const sheetInvalid = sheet.logoOrientationCells.filter(c => !c.isValid).length;
                                return `
                                <tr style="border-bottom: 1px solid #eee;">
                                    <td style="padding: 12px; font-weight: 600; color: #5612BD;">${sheet.sheetName}</td>
                                    <td style="padding: 12px;">${sheet.logoOrientationCells.length}</td>
                                    <td style="padding: 12px;"><span style="color: #28a745; font-weight: 600;">${sheetValid}</span></td>
                                    <td style="padding: 12px;"><span style="color: #dc3545; font-weight: 600;">${sheetInvalid}</span></td>
                                </tr>
                                `;
                            }).join('')}
                            <tr style="background-color: #f8f9fa; font-weight: 600;">
                                <td style="padding: 12px;">Total</td>
                                <td style="padding: 12px;">${totalCells}</td>
                                <td style="padding: 12px;"><span style="color: #28a745;">${totalValid}</span></td>
                                <td style="padding: 12px;"><span style="color: #dc3545;">${totalInvalid}</span></td>
                            </tr>
                        </tbody>
                    </table>
                `;
                logoOrientationResults.appendChild(summaryDiv);

                // Create a table for all logo orientation cells
                const table = document.createElement('table');
                table.className = 'results-table';
                table.style.width = '100%';
                table.style.borderCollapse = 'collapse';
                table.style.marginTop = '20px';
                table.style.backgroundColor = '#fff';
                table.style.borderRadius = '6px';
                table.style.overflow = 'hidden';
                table.style.boxShadow = '0 2px 4px rgba(0, 0, 0, 0.1)';
                table.innerHTML = `
                    <thead>
                        <tr style="background-color: #5612BD; color: #fff;">
                            <th style="padding: 12px; text-align: left; font-weight: 600;">Sheet</th>
                            <th style="padding: 12px; text-align: left; font-weight: 600;">Row</th>
                            <th style="padding: 12px; text-align: left; font-weight: 600;">Column</th>
                            <th style="padding: 12px; text-align: left; font-weight: 600;">Value</th>
                            <th style="padding: 12px; text-align: left; font-weight: 600;">Expected</th>
                            <th style="padding: 12px; text-align: left; font-weight: 600;">Status</th>
                        </tr>
                    </thead>
                    <tbody></tbody>
                `;

                const tbody = table.querySelector('tbody');
                
                sheetResults.forEach(sheet => {
                    sheet.logoOrientationCells.forEach(result => {
                        const row = document.createElement('tr');
                        const statusText = result.isValid ? 'âœ“ Valid' : 'âœ— Invalid';
                        const colorCode = result.isValid ? '#28a745' : '#dc3545';
                        const columnName = result.column || getColumnLetter(result.col);
                        
                        row.innerHTML = `
                            <td style="padding: 10px; border-bottom: 1px solid #eee;">${sheet.sheetName}</td>
                            <td style="padding: 10px; border-bottom: 1px solid #eee;">${result.row}</td>
                            <td style="padding: 10px; border-bottom: 1px solid #eee;">${columnName}</td>
                            <td style="padding: 10px; border-bottom: 1px solid #eee;">${result.cellValue}</td>
                            <td style="padding: 10px; border-bottom: 1px solid #eee;">${result.expectedOrientation}</td>
                            <td style="padding: 10px; border-bottom: 1px solid #eee;"><span style="color: ${colorCode}; font-weight: 600;">${statusText}</span></td>
                        `;
                        
                        tbody.appendChild(row);
                    });
                });

                logoOrientationResults.appendChild(table);
            }

            // Warranty Logo Language functionality
            const logoLanguageDropdown = document.getElementById('logo-language-sheet-type');
            const logoLanguageInput = document.getElementById('logo-language-input');
            const logoLanguageValueInput = document.getElementById('logo-language-value');
            const logoLanguageLabel = document.getElementById('logo-language-label');
            
            logoLanguageDropdown.addEventListener('change', function() {
                if (this.value) {
                    logoLanguageInput.classList.add('active');
                    if (this.value === 'excel-csv') {
                        logoLanguageValueInput.type = 'file';
                        logoLanguageValueInput.accept = '.xlsx,.xls,.csv';
                        logoLanguageValueInput.placeholder = '';
                        logoLanguageLabel.textContent = 'Select file';
                    } else if (this.value === 'gsheet') {
                        logoLanguageValueInput.type = 'text';
                        logoLanguageValueInput.accept = '';
                        logoLanguageValueInput.placeholder = 'Enter GSheet URL';
                        logoLanguageLabel.textContent = 'Enter GSheet URL';
                    }
                } else {
                    logoLanguageInput.classList.remove('active');
                }
            });

            // Warranty Logo Language button functionality
            const logoLanguageButton = document.getElementById('logo-language-btn');
            const logoLanguageResultsSection = document.getElementById('logo-language-results-section');
            const logoLanguageLoadingMessage = document.getElementById('logo-language-loading-message');
            const logoLanguageErrorMessage = document.getElementById('logo-language-error-message');
            const logoLanguageNoResults = document.getElementById('logo-language-no-results');
            const logoLanguageResults = document.getElementById('logo-language-results');
            const logoLanguageResultsCount = document.getElementById('logo-language-results-count');

            function showLogoLanguageError(message) {
                logoLanguageResultsSection.classList.add('active');
                logoLanguageErrorMessage.textContent = message;
                logoLanguageErrorMessage.style.display = 'block';
                logoLanguageLoadingMessage.style.display = 'none';
                logoLanguageNoResults.style.display = 'none';
            }

            function clearLogoLanguageResults() {
                logoLanguageResults.innerHTML = '';
                logoLanguageErrorMessage.style.display = 'none';
                logoLanguageNoResults.style.display = 'none';
                logoLanguageResultsCount.textContent = '';
            }

            let logoLanguageCurrentSheetId = null;
            let logoLanguageCurrentGid = null;
            let logoLanguageCurrentSheetUrl = null;
            let logoLanguageCurrentWorkbook = null;

            logoLanguageButton.addEventListener('click', async function() {
                const sheetType = logoLanguageDropdown.value;
                const sheetValue = logoLanguageValueInput.value;

                if (!sheetType) {
                    showLogoLanguageError('Please select a sheet type');
                    return;
                }

                if (!sheetValue) {
                    showLogoLanguageError('Please provide a sheet URL or file');
                    return;
                }

                clearLogoLanguageResults();
                logoLanguageResultsSection.classList.add('active');
                logoLanguageLoadingMessage.style.display = 'block';
                logoLanguageButton.disabled = true;
                logoLanguageButton.textContent = 'Processing...';

                try {
                    // Placeholder - will be implemented when requirements are provided
                    logoLanguageLoadingMessage.style.display = 'none';
                    logoLanguageButton.disabled = false;
                    logoLanguageButton.textContent = 'Verify Warranty Logo Language';
                    logoLanguageNoResults.style.display = 'block';
                    logoLanguageResultsCount.textContent = 'Functionality to be implemented';
                } catch (error) {
                    console.error('Error:', error);
                    showLogoLanguageError('Error: ' + error.message);
                    logoLanguageButton.disabled = false;
                    logoLanguageButton.textContent = 'Verify Warranty Logo Language';
                }
            });

            // Year of Warranty Logo functionality
            const yearOfWarrantyLogoDropdown = document.getElementById('year-of-warranty-logo-sheet-type');
            const yearOfWarrantyLogoInput = document.getElementById('year-of-warranty-logo-input');
            const yearOfWarrantyLogoValueInput = document.getElementById('year-of-warranty-logo-value');
            const yearOfWarrantyLogoLabel = document.getElementById('year-of-warranty-logo-label');
            
            yearOfWarrantyLogoDropdown.addEventListener('change', function() {
                if (this.value) {
                    yearOfWarrantyLogoInput.classList.add('active');
                    if (this.value === 'excel-csv') {
                        yearOfWarrantyLogoValueInput.type = 'file';
                        yearOfWarrantyLogoValueInput.accept = '.xlsx,.xls,.csv';
                        yearOfWarrantyLogoValueInput.placeholder = '';
                        yearOfWarrantyLogoLabel.textContent = 'Select file';
                    } else if (this.value === 'gsheet') {
                        yearOfWarrantyLogoValueInput.type = 'text';
                        yearOfWarrantyLogoValueInput.accept = '';
                        yearOfWarrantyLogoValueInput.placeholder = 'Enter GSheet URL';
                        yearOfWarrantyLogoLabel.textContent = 'Enter GSheet URL';
                    }
                } else {
                    yearOfWarrantyLogoInput.classList.remove('active');
                }
            });

            // Year of Warranty Logo button functionality
            const yearOfWarrantyLogoButton = document.getElementById('year-of-warranty-logo-btn');
            const yearOfWarrantyLogoResultsSection = document.getElementById('year-of-warranty-logo-results-section');
            const yearOfWarrantyLogoLoadingMessage = document.getElementById('year-of-warranty-logo-loading-message');
            const yearOfWarrantyLogoErrorMessage = document.getElementById('year-of-warranty-logo-error-message');
            const yearOfWarrantyLogoNoResults = document.getElementById('year-of-warranty-logo-no-results');
            const yearOfWarrantyLogoResults = document.getElementById('year-of-warranty-logo-results');
            const yearOfWarrantyLogoResultsCount = document.getElementById('year-of-warranty-logo-results-count');

            function showYearOfWarrantyLogoError(message) {
                yearOfWarrantyLogoResultsSection.classList.add('active');
                yearOfWarrantyLogoErrorMessage.textContent = message;
                yearOfWarrantyLogoErrorMessage.style.display = 'block';
                yearOfWarrantyLogoLoadingMessage.style.display = 'none';
                yearOfWarrantyLogoNoResults.style.display = 'none';
            }

            function clearYearOfWarrantyLogoResults() {
                yearOfWarrantyLogoResults.innerHTML = '';
                yearOfWarrantyLogoErrorMessage.style.display = 'none';
                yearOfWarrantyLogoNoResults.style.display = 'none';
                yearOfWarrantyLogoResultsCount.textContent = '';
            }

            let yearOfWarrantyLogoCurrentSheetId = null;
            let yearOfWarrantyLogoCurrentGid = null;
            let yearOfWarrantyLogoCurrentSheetUrl = null;
            let yearOfWarrantyLogoCurrentWorkbook = null;

            yearOfWarrantyLogoButton.addEventListener('click', async function() {
                const sheetType = yearOfWarrantyLogoDropdown.value;
                const sheetValue = yearOfWarrantyLogoValueInput.value;

                if (!sheetType) {
                    showYearOfWarrantyLogoError('Please select a sheet type');
                    return;
                }

                if (!sheetValue) {
                    showYearOfWarrantyLogoError('Please provide a sheet URL or file');
                    return;
                }

                clearYearOfWarrantyLogoResults();
                yearOfWarrantyLogoResultsSection.classList.add('active');
                yearOfWarrantyLogoLoadingMessage.style.display = 'block';
                yearOfWarrantyLogoButton.disabled = true;
                yearOfWarrantyLogoButton.textContent = 'Processing...';

                try {
                    // Placeholder - will be implemented when requirements are provided
                    yearOfWarrantyLogoLoadingMessage.style.display = 'none';
                    yearOfWarrantyLogoButton.disabled = false;
                    yearOfWarrantyLogoButton.textContent = 'Verify Year of Warranty Logo';
                    yearOfWarrantyLogoNoResults.style.display = 'block';
                    yearOfWarrantyLogoResultsCount.textContent = 'Functionality to be implemented';
                } catch (error) {
                    console.error('Error:', error);
                    showYearOfWarrantyLogoError('Error: ' + error.message);
                    yearOfWarrantyLogoButton.disabled = false;
                    yearOfWarrantyLogoButton.textContent = 'Verify Year of Warranty Logo';
                }
            });

            // Rate Format functionality
            const rateFormatDropdown = document.getElementById('rate-format-sheet-type');
            const rateFormatInput = document.getElementById('rate-format-input');
            const rateFormatValueInput = document.getElementById('rate-format-value');
            const rateFormatLabel = document.getElementById('rate-format-label');
            
            rateFormatDropdown.addEventListener('change', function() {
                if (this.value) {
                    rateFormatInput.classList.add('active');
                    if (this.value === 'excel-csv') {
                        rateFormatValueInput.type = 'file';
                        rateFormatValueInput.accept = '.xlsx,.xls,.csv';
                        rateFormatValueInput.placeholder = '';
                        rateFormatLabel.textContent = 'Select file';
                    } else if (this.value === 'gsheet') {
                        rateFormatValueInput.type = 'text';
                        rateFormatValueInput.accept = '';
                        rateFormatValueInput.placeholder = 'Enter GSheet URL';
                        rateFormatLabel.textContent = 'Enter GSheet URL';
                    }
                } else {
                    rateFormatInput.classList.remove('active');
                }
            });

            // Rate Format button functionality
            const rateFormatButton = document.getElementById('rate-format-btn');
            const rateFormatResultsSection = document.getElementById('rate-format-results-section');
            const rateFormatLoadingMessage = document.getElementById('rate-format-loading-message');
            const rateFormatErrorMessage = document.getElementById('rate-format-error-message');
            const rateFormatNoResults = document.getElementById('rate-format-no-results');
            const rateFormatResults = document.getElementById('rate-format-results');
            const rateFormatResultsCount = document.getElementById('rate-format-results-count');

            function showRateFormatError(message) {
                rateFormatResultsSection.classList.add('active');
                rateFormatErrorMessage.textContent = message;
                rateFormatErrorMessage.style.display = 'block';
                rateFormatLoadingMessage.style.display = 'none';
                rateFormatNoResults.style.display = 'none';
            }

            function clearRateFormatResults() {
                rateFormatResults.innerHTML = '';
                rateFormatErrorMessage.style.display = 'none';
                rateFormatNoResults.style.display = 'none';
                rateFormatResultsCount.textContent = '';
            }

            let rateFormatCurrentSheetId = null;
            let rateFormatCurrentGid = null;
            let rateFormatCurrentSheetUrl = null;
            let rateFormatCurrentWorkbook = null;

            rateFormatButton.addEventListener('click', async function() {
                const sheetType = rateFormatDropdown.value;
                const sheetValue = rateFormatValueInput.value;

                if (!sheetType) {
                    showRateFormatError('Please select a sheet type');
                    return;
                }

                if (!sheetValue) {
                    showRateFormatError('Please provide a sheet URL or file');
                    return;
                }

                clearRateFormatResults();
                rateFormatResultsSection.classList.add('active');
                rateFormatLoadingMessage.style.display = 'block';
                rateFormatButton.disabled = true;
                rateFormatButton.textContent = 'Processing...';

                try {
                    // Placeholder - will be implemented when requirements are provided
                    rateFormatLoadingMessage.style.display = 'none';
                    rateFormatButton.disabled = false;
                    rateFormatButton.textContent = 'Verify Rate Format';
                    rateFormatNoResults.style.display = 'block';
                    rateFormatResultsCount.textContent = 'Functionality to be implemented';
                } catch (error) {
                    console.error('Error:', error);
                    showRateFormatError('Error: ' + error.message);
                    rateFormatButton.disabled = false;
                    rateFormatButton.textContent = 'Verify Rate Format';
                }
            });

            // Frame Count functionality
            const frameCountDropdown = document.getElementById('frame-count-sheet-type');
            const frameCountInput = document.getElementById('frame-count-input');
            const frameCountValueInput = document.getElementById('frame-count-value');
            const frameCountLabel = document.getElementById('frame-count-label');
            
            frameCountDropdown.addEventListener('change', function() {
                if (this.value) {
                    frameCountInput.classList.add('active');
                    if (this.value === 'excel-csv') {
                        frameCountValueInput.type = 'file';
                        frameCountValueInput.accept = '.xlsx,.xls,.csv';
                        frameCountValueInput.placeholder = '';
                        frameCountLabel.textContent = 'Select file';
                    } else if (this.value === 'gsheet') {
                        frameCountValueInput.type = 'text';
                        frameCountValueInput.accept = '';
                        frameCountValueInput.placeholder = 'Enter GSheet URL';
                        frameCountLabel.textContent = 'Enter GSheet URL';
                    }
                } else {
                    frameCountInput.classList.remove('active');
                }
            });

            // Frame Count button functionality
            const frameCountButton = document.getElementById('frame-count-btn');
            const frameCountResultsSection = document.getElementById('frame-count-results-section');
            const frameCountLoadingMessage = document.getElementById('frame-count-loading-message');
            const frameCountErrorMessage = document.getElementById('frame-count-error-message');
            const frameCountNoResults = document.getElementById('frame-count-no-results');
            const frameCountResults = document.getElementById('frame-count-results');
            const frameCountResultsCount = document.getElementById('frame-count-results-count');

            function showFrameCountError(message) {
                frameCountResultsSection.classList.add('active');
                frameCountErrorMessage.textContent = message;
                frameCountErrorMessage.style.display = 'block';
                frameCountLoadingMessage.style.display = 'none';
                frameCountNoResults.style.display = 'none';
            }

            function clearFrameCountResults() {
                frameCountResults.innerHTML = '';
                frameCountErrorMessage.style.display = 'none';
                frameCountNoResults.style.display = 'none';
                frameCountResultsCount.textContent = '';
            }

            let frameCountCurrentSheetId = null;
            let frameCountCurrentGid = null;
            let frameCountCurrentSheetUrl = null;
            let frameCountCurrentWorkbook = null;

            frameCountButton.addEventListener('click', async function() {
                const sheetType = frameCountDropdown.value;
                const sheetValue = frameCountValueInput.value;

                if (!sheetType) {
                    showFrameCountError('Please select a sheet type');
                    return;
                }

                if (!sheetValue) {
                    showFrameCountError('Please provide a sheet URL or file');
                    return;
                }

                clearFrameCountResults();
                frameCountResultsSection.classList.add('active');
                frameCountLoadingMessage.style.display = 'block';
                frameCountButton.disabled = true;
                frameCountButton.textContent = 'Processing...';

                try {
                    let data = [];
                    let workbook = null;
                    
                    if (sheetType === 'gsheet') {
                        // Read Google Sheet with workbook info
                        const result = await readGoogleSheetWithWorkbook(sheetValue);
                        const spreadsheetId = result.sheetId;
                        const processAllSheets = result.processAllSheets === true;
                        const gid = result.gid;
                        
                        if (processAllSheets) {
                            // Process all sheets to find the one with Image_Frame3 and Image_Frame4
                            const allSheets = await getAllSheets(spreadsheetId);
                            if (allSheets.length === 0) {
                                throw new Error('Could not retrieve sheet list. Please specify a specific sheet in the URL (add #gid=XXX to the URL).');
                            }
                            
                            console.log(`Searching for Image_Frame3 and Image_Frame4 in ${allSheets.length} sheets:`, allSheets.map(s => s.title));
                            
                            let foundSheet = null;
                            let foundData = null;
                            
                            // Search through all sheets
                            for (const sheet of allSheets) {
                                try {
                                    console.log(`Checking sheet: ${sheet.title} (gid: ${sheet.sheetId})`);
                                    
                                    // Read this specific sheet
                                    const sheetUrl = `https://docs.google.com/spreadsheets/d/${spreadsheetId}/export?format=csv&gid=${sheet.sheetId}`;
                                    const sheetResult = await readGoogleSheetCSV(sheetUrl);
                                    
                                    // Check if this sheet has the required columns
                                    const tempResult = compareFrameCountColumns(sheetResult.data);
                                    if (!tempResult.error) {
                                        foundSheet = sheet;
                                        foundData = sheetResult.data;
                                        console.log(`Found Image_Frame3 and Image_Frame4 in sheet: ${sheet.title}`);
                                        break;
                                    }
                                } catch (sheetError) {
                                    console.error(`Error checking sheet "${sheet.title}":`, sheetError);
                                    // Continue with other sheets
                                }
                            }
                            
                            if (!foundData) {
                                throw new Error("Couldn't proceed since Image_Frame3 and Image_Frame4 is missing");
                            }
                            
                            data = foundData;
                        } else {
                            // Process specific sheet (gid specified in URL)
                            data = result.data;
                        }
                        workbook = result.workbook;
                    } else if (sheetType === 'excel-csv') {
                        // Read Excel/CSV file
                        const file = frameCountValueInput.files[0];
                        if (!file) {
                            throw new Error('Please select a file');
                        }
                        const result = await readExcelFileWithWorkbook(file);
                        const allSheetNames = result.workbook.SheetNames;
                        
                        // Search through all sheets in Excel
                        let foundSheet = null;
                        let foundData = null;
                        
                        for (const sheetName of allSheetNames) {
                            try {
                                console.log(`Checking sheet: ${sheetName}`);
                                
                                // Read this specific sheet
                                const worksheet = result.workbook.Sheets[sheetName];
                                const sheetData = XLSX.utils.sheet_to_json(worksheet, { header: 1, defval: null });
                                
                                // Check if this sheet has the required columns
                                const tempResult = compareFrameCountColumns(sheetData);
                                if (!tempResult.error) {
                                    foundSheet = sheetName;
                                    foundData = sheetData;
                                    console.log(`Found Image_Frame3 and Image_Frame4 in sheet: ${sheetName}`);
                                    break;
                                }
                            } catch (sheetError) {
                                console.error(`Error checking sheet "${sheetName}":`, sheetError);
                                // Continue with other sheets
                            }
                        }
                        
                        if (!foundData) {
                            // If not found in any sheet, try the first sheet data
                            data = result.data;
                        } else {
                            data = foundData;
                        }
                        workbook = result.workbook;
                    }
                    
                    // Check for required columns and compare values
                    const frameCountResult = compareFrameCountColumns(data);
                    
                    frameCountLoadingMessage.style.display = 'none';
                    frameCountButton.disabled = false;
                    frameCountButton.textContent = 'Verify Frame Count';
                    
                    // Show results section
                    frameCountResultsSection.classList.add('active');
                    
                    if (frameCountResult.error) {
                        showFrameCountError(frameCountResult.error);
                    } else {
                        displayFrameCountResults(frameCountResult);
                        frameCountResultsCount.textContent = frameCountResult.result;
                    }
                } catch (error) {
                    console.error('Error:', error);
                    showFrameCountError('Error: ' + error.message);
                    frameCountButton.disabled = false;
                    frameCountButton.textContent = 'Verify Frame Count';
                }
            });

            // Frame Count verification functions
            function compareFrameCountColumns(data) {
                // Handle both 2D array format and JSON object format
                let rows = [];
                let headers = [];
                let skippedHeaderRow = false;
                
                if (Array.isArray(data) && data.length > 0) {
                    if (Array.isArray(data[0])) {
                        // 2D array format - first row is headers
                        headers = data[0] || [];
                        rows = data.slice(1); // Skip header row
                        skippedHeaderRow = true;
                    } else {
                        // JSON object format - convert to 2D array
                        const allKeys = new Set();
                        data.forEach(obj => {
                            Object.keys(obj).forEach(key => allKeys.add(key));
                        });
                        headers = Array.from(allKeys);
                        
                        rows = data.map(obj => {
                            return headers.map(key => obj[key] || '');
                        });
                        skippedHeaderRow = false;
                    }
                }
                
                // Check if required columns exist
                const frame3ColIndex = headers.findIndex(h => 
                    h && h.toString().trim() === 'Image_Frame3'
                );
                const frame4ColIndex = headers.findIndex(h => 
                    h && h.toString().trim() === 'Image_Frame4'
                );
                
                if (frame3ColIndex === -1 || frame4ColIndex === -1) {
                    return {
                        error: "Couldn't proceed since Image_Frame3 and Image_Frame4 is missing"
                    };
                }
                
                // Compare values row by row
                const mismatches = [];
                let allMatch = true;
                
                rows.forEach((row, rowIndex) => {
                    if (Array.isArray(row)) {
                        const frame3Value = row[frame3ColIndex];
                        const frame4Value = row[frame4ColIndex];
                        
                        // Convert to strings for comparison (handle null/undefined)
                        const frame3Str = frame3Value !== null && frame3Value !== undefined ? String(frame3Value).trim() : '';
                        const frame4Str = frame4Value !== null && frame4Value !== undefined ? String(frame4Value).trim() : '';
                        
                        // Exact match comparison
                        if (frame3Str !== frame4Str) {
                            allMatch = false;
                            // Row number: +2 if we skipped header row, +1 if we didn't (1-based for display)
                            const rowNumber = skippedHeaderRow ? rowIndex + 2 : rowIndex + 1;
                            mismatches.push({
                                row: rowNumber,
                                frame3Value: frame3Str || '(empty)',
                                frame4Value: frame4Str || '(empty)'
                            });
                        }
                    }
                });
                
                const result = allMatch ? '3 Frames' : '4 Frames';
                
                return {
                    result: result,
                    allMatch: allMatch,
                    mismatches: mismatches,
                    totalRows: rows.length
                };
            }

            function displayFrameCountResults(frameCountResult) {
                frameCountResults.innerHTML = '';
                
                // Create result summary
                const summaryDiv = document.createElement('div');
                summaryDiv.style.cssText = 'margin-bottom: 30px; padding: 20px; background: linear-gradient(135deg, rgba(86, 18, 189, 0.1) 0%, rgba(146, 80, 242, 0.1) 100%); border-radius: 12px; border-left: 4px solid #5612BD;';
                
                const resultText = frameCountResult.result;
                const isMatch = frameCountResult.allMatch;
                const resultColor = isMatch ? '#28a745' : '#dc3545';
                
                summaryDiv.innerHTML = `
                    <h3 style="margin: 0 0 15px 0; color: #250651; font-size: 1.3rem;">Frame Count Result</h3>
                    <div style="background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                        <div style="font-size: 1.5rem; font-weight: 700; color: ${resultColor}; margin-bottom: 10px;">
                            ${resultText}
                        </div>
                        <div style="color: #666; font-size: 0.95rem;">
                            Total rows checked: ${frameCountResult.totalRows}
                            ${!isMatch ? `<br>Rows with mismatches: ${frameCountResult.mismatches.length}` : '<br>All rows match exactly'}
                        </div>
                    </div>
                `;
                frameCountResults.appendChild(summaryDiv);
                
                // If there are mismatches, show details table
                if (!isMatch && frameCountResult.mismatches.length > 0) {
                    const table = document.createElement('table');
                    table.className = 'results-table';
                    table.style.width = '100%';
                    table.style.borderCollapse = 'collapse';
                    table.style.marginTop = '20px';
                    table.style.backgroundColor = '#fff';
                    table.style.borderRadius = '6px';
                    table.style.overflow = 'hidden';
                    table.style.boxShadow = '0 2px 4px rgba(0, 0, 0, 0.1)';
                    table.innerHTML = `
                        <thead>
                            <tr style="background-color: #5612BD; color: #fff;">
                                <th style="padding: 12px; text-align: left; font-weight: 600;">Row</th>
                                <th style="padding: 12px; text-align: left; font-weight: 600;">Image_Frame3</th>
                                <th style="padding: 12px; text-align: left; font-weight: 600;">Image_Frame4</th>
                            </tr>
                        </thead>
                        <tbody></tbody>
                    `;
                    
                    const tbody = table.querySelector('tbody');
                    
                    frameCountResult.mismatches.forEach(mismatch => {
                        const row = document.createElement('tr');
                        row.innerHTML = `
                            <td style="padding: 10px; border-bottom: 1px solid #eee; font-weight: 600;">${mismatch.row}</td>
                            <td style="padding: 10px; border-bottom: 1px solid #eee;">${mismatch.frame3Value}</td>
                            <td style="padding: 10px; border-bottom: 1px solid #eee;">${mismatch.frame4Value}</td>
                        `;
                        tbody.appendChild(row);
                    });
                    
                    frameCountResults.appendChild(table);
                }
            }

            // Creative Model Names functionality
            const creativeModelNamesInput = document.getElementById('creative-model-names-input');
            const creativeModelNamesValueInput = document.getElementById('creative-model-names-value');
            const creativeModelNamesLabel = document.getElementById('creative-model-names-label');
            const creativeModelNamesButton = document.getElementById('creative-model-names-btn');
            const creativeModelNamesResults = document.getElementById('creative-model-names-results');
            const creativeModelNamesLoading = document.getElementById('creative-model-names-loading-message');
            const creativeModelNamesError = document.getElementById('creative-model-names-error-message');
            const creativeModelNamesNoResults = document.getElementById('creative-model-names-no-results');
            const creativeModelNamesResultsCount = document.getElementById('creative-model-names-results-count');
            const creativeModelNamesResultsSection = document.getElementById('creative-model-names-results-section');
            
            // Function to show error message
            function showCreativeModelNamesError(message) {
                creativeModelNamesError.textContent = message;
                creativeModelNamesError.style.display = 'block';
                creativeModelNamesLoading.style.display = 'none';
                creativeModelNamesNoResults.style.display = 'none';
                creativeModelNamesResultsSection.style.display = 'block';
            }

            // Function to display results
            function displayCreativeModelNamesResults(data) {
                creativeModelNamesResults.innerHTML = '';
                creativeModelNamesError.style.display = 'none';
                creativeModelNamesLoading.style.display = 'none';
                creativeModelNamesNoResults.style.display = 'none';
                creativeModelNamesResultsSection.style.display = 'block';

                if (!data.ok) {
                    showCreativeModelNamesError(data.error || 'An error occurred');
                    return;
                }

                // Get creatives data for summary table
                let creatives = data.creatives || [];
                const hlMatches = data.hlMatches || [];
                
                // If no creatives but we have hlMatches, create creatives from hlMatches
                if (creatives.length === 0 && hlMatches.length > 0) {
                    // Collect all frm1_HL_*, frm2_HL_*, frm3_HL_*, and frm4_HL_* elements
                    const allHLElements = [];
                    const allHLElements2 = [];
                    const allHLElements3 = [];
                    const allHLElements4 = [];
                    hlMatches.forEach(hlMatch => {
                        if (hlMatch.matches && hlMatch.matches.length > 0) {
                            hlMatch.matches.forEach(match => {
                                allHLElements.push({
                                    ...match,
                                    frameUrl: hlMatch.frameUrl,
                                    frameName: hlMatch.frameName
                                });
                            });
                        }
                        if (hlMatch.matches2 && hlMatch.matches2.length > 0) {
                            hlMatch.matches2.forEach(match => {
                                allHLElements2.push({
                                    ...match,
                                    frameUrl: hlMatch.frameUrl,
                                    frameName: hlMatch.frameName
                                });
                            });
                        }
                        if (hlMatch.matches3 && hlMatch.matches3.length > 0) {
                            hlMatch.matches3.forEach(match => {
                                allHLElements3.push({
                                    ...match,
                                    frameUrl: hlMatch.frameUrl,
                                    frameName: hlMatch.frameName
                                });
                            });
                        }
                        if (hlMatch.matches4 && hlMatch.matches4.length > 0) {
                            hlMatch.matches4.forEach(match => {
                                allHLElements4.push({
                                    ...match,
                                    frameUrl: hlMatch.frameUrl,
                                    frameName: hlMatch.frameName
                                });
                            });
                        }
                    });
                    
                    if (allHLElements.length > 0 || allHLElements2.length > 0 || allHLElements3.length > 0 || allHLElements4.length > 0) {
                        creatives.push({
                            index: 1,
                            title: 'Creative (No title found)',
                            originalTitle: '',
                            hasFrm1HLElements: allHLElements.length > 0,
                            frm1HLElements: allHLElements,
                            hasFrm2HLElements: allHLElements2.length > 0,
                            frm2HLElements: allHLElements2,
                            hasFrm3HLElements: allHLElements3.length > 0,
                            frm3HLElements: allHLElements3,
                            hasFrm4HLElements: allHLElements4.length > 0,
                            frm4HLElements: allHLElements4
                        });
                    }
                }
                
                // Show the creative summary table if we have creatives or hlMatches
                if (creatives.length > 0 || hlMatches.length > 0) {
                    const summaryTableDiv = document.createElement('div');
                    summaryTableDiv.style.marginBottom = '30px';
                    summaryTableDiv.innerHTML = `
                        <h3 style="color: #250651; font-size: 1.2rem; margin-bottom: 15px;">Creative Summary</h3>
                    `;
                    
                    const summaryTable = document.createElement('table');
                    summaryTable.className = 'results-table';
                    summaryTable.style.width = '100%';
                    summaryTable.style.borderCollapse = 'collapse';
                    summaryTable.style.backgroundColor = '#fff';
                    summaryTable.style.borderRadius = '8px';
                    summaryTable.style.overflow = 'hidden';
                    summaryTable.style.boxShadow = '0 2px 4px rgba(0,0,0,0.1)';
                    summaryTable.innerHTML = `
                        <thead>
                            <tr style="background-color: #5612BD; color: #fff;">
                                <th style="padding: 12px; text-align: left; font-weight: 600;">Creative</th>
                                <th style="padding: 12px; text-align: left; font-weight: 600;">jvxBase_ Iframe</th>
                                <th style="padding: 12px; text-align: left; font-weight: 600;">frm1_HL_* Elements</th>
                                <th style="padding: 12px; text-align: left; font-weight: 600;">frm2_HL_* Elements</th>
                                <th style="padding: 12px; text-align: left; font-weight: 600;">frm3_HL_* Elements</th>
                                <th style="padding: 12px; text-align: left; font-weight: 600;">frm4_HL_* Elements</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${creatives.map((creative) => {
                                // Helper function to store and display elements
                                const processElements = (elements, hasElements, elementType, creativeIndex) => {
                                    const variableName = `creative${creativeIndex}_${elementType}HLElements`;
                                    
                                    // Store in window object and console log if elements exist
                                    if (hasElements && elements.length > 0) {
                                        window[variableName] = elements;
                                        console.log(`âœ… Stored ${elements.length} ${elementType}_HL_* elements for "${creative.title}" in window.${variableName}`);
                                        console.log(`ðŸ’¡ Access via: window.${variableName}`);
                                        console.log(`ðŸ“‹ Elements:`, elements);
                                    }
                                    
                                    // Display element IDs if they exist (deduplicated)
                                    let display = '';
                                    if (hasElements && elements.length > 0) {
                                        const uniqueElementIds = [...new Set(elements.map(el => el.id).filter(id => id))];
                                        if (uniqueElementIds.length > 0) {
                                            const displayId = uniqueElementIds[0]; // Show only the first unique element
                                            display = `<div style="margin-top: 5px;">
                                                <span style="color: #28a745; font-weight: 600;">âœ“ Yes</span>
                                                <div style="margin-top: 8px; padding: 8px; background: #f8f9fa; border-radius: 4px;">
                                                    <div style="font-family: monospace; font-size: 0.85rem; color: #5612BD; margin: 3px 0;">${displayId}</div>
                                                </div>
                                            </div>`;
                                        } else {
                                            display = `<span style="color: #28a745; font-weight: 600;">âœ“ Yes</span>`;
                                        }
                                    } else {
                                        display = `<span style="color: #dc3545; font-weight: 600;">âœ— No</span>`;
                                    }
                                    
                                    return display;
                                };
                                
                                const frm1Display = processElements(
                                    creative.frm1HLElements || [],
                                    creative.hasFrm1HLElements,
                                    'frm1',
                                    creative.index
                                );
                                const frm2Display = processElements(
                                    creative.frm2HLElements || [],
                                    creative.hasFrm2HLElements,
                                    'frm2',
                                    creative.index
                                );
                                const frm3Display = processElements(
                                    creative.frm3HLElements || [],
                                    creative.hasFrm3HLElements,
                                    'frm3',
                                    creative.index
                                );
                                const frm4Display = processElements(
                                    creative.frm4HLElements || [],
                                    creative.hasFrm4HLElements,
                                    'frm4',
                                    creative.index
                                );
                                
                                // Display jvxBase_ iframe ID
                                const jvxBaseDisplay = creative.jvxBaseIframeId 
                                    ? `<div style="font-family: monospace; font-size: 0.9rem; color: #5612BD; font-weight: 600;">${creative.jvxBaseIframeId}</div>`
                                    : `<span style="color: #6c757d; font-style: italic;">Not found</span>`;
                                
                                return `
                                    <tr style="border-bottom: 1px solid #eee;">
                                        <td style="padding: 10px;">
                                            <strong style="color: #250651; font-size: 1rem;">${creative.title}</strong>
                                        </td>
                                        <td style="padding: 10px;">
                                            ${jvxBaseDisplay}
                                        </td>
                                        <td style="padding: 10px;">
                                            ${frm1Display}
                                        </td>
                                        <td style="padding: 10px;">
                                            ${frm2Display}
                                        </td>
                                        <td style="padding: 10px;">
                                            ${frm3Display}
                                        </td>
                                        <td style="padding: 10px;">
                                            ${frm4Display}
                                        </td>
                                    </tr>
                                `;
                            }).join('')}
                        </tbody>
                    `;
                    summaryTableDiv.appendChild(summaryTable);
                    creativeModelNamesResults.appendChild(summaryTableDiv);
                } else {
                    creativeModelNamesNoResults.style.display = 'block';
                }

                // Update results count
                const totalCreatives = creatives.length;
                const totalWithFrm1 = creatives.filter(c => c.hasFrm1HLElements).length;
                const totalWithFrm2 = creatives.filter(c => c.hasFrm2HLElements).length;
                const totalWithFrm3 = creatives.filter(c => c.hasFrm3HLElements).length;
                const totalWithFrm4 = creatives.filter(c => c.hasFrm4HLElements).length;
                creativeModelNamesResultsCount.textContent = `${totalCreatives} creative(s) - frm1: ${totalWithFrm1}, frm2: ${totalWithFrm2}, frm3: ${totalWithFrm3}, frm4: ${totalWithFrm4}`;
            }

                if (creativeModelNamesButton) {
                    creativeModelNamesButton.addEventListener('click', async function() {
                    const url = creativeModelNamesValueInput.value.trim();
                    
                    if (!url) {
                        showCreativeModelNamesError('Please enter a URL');
                        return;
                    }

                    // Validate URL format
                    try {
                        new URL(url);
                    } catch (e) {
                        showCreativeModelNamesError('Please enter a valid URL');
                        return;
                    }

                    // Show loading state
                    creativeModelNamesButton.disabled = true;
                    creativeModelNamesButton.textContent = 'Processing...';
                    creativeModelNamesLoading.style.display = 'block';
                    creativeModelNamesError.style.display = 'none';
                    creativeModelNamesNoResults.style.display = 'none';
                    creativeModelNamesResults.innerHTML = '';
                    creativeModelNamesResultsSection.style.display = 'block';

                    try {
                        const response = await fetch(`/api/count?url=${encodeURIComponent(url)}`);
                        
                        // Check if response is OK
                        if (!response.ok) {
                            const errorText = await response.text();
                            showCreativeModelNamesError(`Server error (${response.status}): ${errorText.substring(0, 200)}`);
                            return;
                        }
                        
                        // Check content type
                        const contentType = response.headers.get('content-type');
                        if (!contentType || !contentType.includes('application/json')) {
                            const text = await response.text();
                            showCreativeModelNamesError(`Expected JSON but got ${contentType}. Response: ${text.substring(0, 200)}...`);
                            return;
                        }
                        
                        const data = await response.json();
                        displayCreativeModelNamesResults(data);
                    } catch (error) {
                        console.error('Error fetching /api/count:', error);
                        showCreativeModelNamesError(`Error: ${error.message || 'Failed to process URL'}`);
                    } finally {
                        creativeModelNamesButton.disabled = false;
                        creativeModelNamesButton.textContent = 'Process Model Names';
                        creativeModelNamesLoading.style.display = 'none';
                    }
                });
            }

            // Rate Card functionality
            const rateCardDropdown = document.getElementById('rate-card-sheet-type');
            const rateCardInput = document.getElementById('rate-card-input');
            const rateCardValueInput = document.getElementById('rate-card-value');
            const rateCardLabel = document.getElementById('rate-card-label');
            const rateCardButton = document.getElementById('rate-card-btn');
            
            if (rateCardDropdown) {
                rateCardDropdown.addEventListener('change', function() {
                    if (this.value) {
                        rateCardInput.classList.add('active');
                        if (this.value === 'excel-csv') {
                            rateCardValueInput.type = 'file';
                            rateCardValueInput.accept = '.xlsx,.xls,.csv';
                            rateCardValueInput.placeholder = '';
                            rateCardLabel.textContent = 'Select file';
                        } else if (this.value === 'gsheet') {
                            rateCardValueInput.type = 'text';
                            rateCardValueInput.accept = '';
                            rateCardValueInput.placeholder = 'Enter GSheet URL';
                            rateCardLabel.textContent = 'Enter GSheet URL';
                        }
                    } else {
                        rateCardInput.classList.remove('active');
                    }
                });

                if (rateCardButton) {
                    rateCardButton.addEventListener('click', async function() {
                        alert('Rate Card functionality will be implemented here.');
                    });
                }
            }

            // Font Size functionality
            const fontSizeDropdown = document.getElementById('font-size-sheet-type');
            const fontSizeInput = document.getElementById('font-size-input');
            const fontSizeValueInput = document.getElementById('font-size-value');
            const fontSizeLabel = document.getElementById('font-size-label');
            const fontSizeButton = document.getElementById('font-size-btn');
            
            if (fontSizeDropdown) {
                fontSizeDropdown.addEventListener('change', function() {
                    if (this.value) {
                        fontSizeInput.classList.add('active');
                        if (this.value === 'excel-csv') {
                            fontSizeValueInput.type = 'file';
                            fontSizeValueInput.accept = '.xlsx,.xls,.csv';
                            fontSizeValueInput.placeholder = '';
                            fontSizeLabel.textContent = 'Select file';
                        } else if (this.value === 'gsheet') {
                            fontSizeValueInput.type = 'text';
                            fontSizeValueInput.accept = '';
                            fontSizeValueInput.placeholder = 'Enter GSheet URL';
                            fontSizeLabel.textContent = 'Enter GSheet URL';
                        }
                    } else {
                        fontSizeInput.classList.remove('active');
                    }
                });

                if (fontSizeButton) {
                    fontSizeButton.addEventListener('click', async function() {
                        alert('Font Size functionality will be implemented here.');
                    });
                }
            }

            function getAccessTokenOnce() {
                return new Promise((resolve) => {
                    const tokenDiv = document.createElement('div');
                    tokenDiv.style.cssText = 'position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 30px; border-radius: 12px; box-shadow: 0 8px 32px rgba(0,0,0,0.3); z-index: 10000; max-width: 650px; width: 90%; max-height: 90vh; overflow-y: auto;';
                    
                    // Create unique IDs for this dialog instance
                    const textareaId = 'token-input-once-' + Date.now();
                    const useBtnId = 'use-token-btn-' + Date.now();
                    const cancelBtnId = 'cancel-token-btn-' + Date.now();

                    tokenDiv.innerHTML = `
                        <h3 style="margin-top: 0; color: #5612BD; font-size: 1.5rem; margin-bottom: 15px;">ðŸ”‘ One-Time Setup (2 minutes)</h3>
                        <div style="background: linear-gradient(135deg, rgba(86, 18, 189, 0.1) 0%, rgba(146, 80, 242, 0.1) 100%); padding: 15px; border-radius: 8px; border-left: 4px solid #5612BD; margin-bottom: 20px;">
                            <p style="margin: 0; color: #250651; font-weight: 500; line-height: 1.6;">
                                <strong>âœ… One-Time Setup:</strong> Enter your access token ONCE, and we'll save it automatically!<br>
                                <span style="font-size: 0.9em; color: #5612BD;">You won't need to enter it again until it expires (after 1 hour).</span>
                            </p>
                        </div>
                        <div style="background: #e7f3ff; padding: 15px; border-radius: 8px; border-left: 4px solid #2196F3; margin-bottom: 20px;">
                            <strong>ðŸ“‹ Step-by-Step Instructions:</strong>
                            <ol style="color: #333; line-height: 2.2; margin: 10px 0 0 0; padding-left: 20px;">
                                <li>Click: <a href="https://developers.google.com/oauthplayground/" target="_blank" style="color: #5612BD; font-weight: 600;">OAuth 2.0 Playground</a> (opens in new tab)</li>
                                <li>In <strong>"Step 1"</strong>, find <strong>"Input your own scopes"</strong> field</li>
                                <li>Copy and paste this EXACT text:<br>
                                    <code style="background: #f0f0f0; padding: 8px 12px; border-radius: 4px; display: inline-block; margin-top: 5px; font-size: 13px; word-break: break-all;">https://www.googleapis.com/auth/spreadsheets</code>
                                    <button onclick="navigator.clipboard.writeText('https://www.googleapis.com/auth/spreadsheets').then(() => { this.textContent = 'âœ“ Copied!'; setTimeout(() => this.textContent = 'Copy Scope', 2000); });" style="margin-left: 10px; padding: 6px 12px; background: #5612BD; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">Copy Scope</button>
                                </li>
                                <li>Click <strong>"Authorize APIs"</strong> â†’ Sign in â†’ <strong>"Allow"</strong></li>
                                <li>In <strong>"Step 2"</strong>, click <strong>"Exchange authorization code for tokens"</strong></li>
                                <li>Copy the <strong>"Access token"</strong> (starts with "ya29...")</li>
                            </ol>
                        </div>
                        <div style="background: #d4edda; padding: 15px; border-radius: 8px; border-left: 4px solid #28a745; margin-bottom: 20px;">
                            <strong>âœ… After completing steps above:</strong>
                            <p style="margin: 10px 0 0 0; color: #155724; font-weight: 600;">
                                Paste the access token in the box below and click <strong>"Save & Highlight"</strong>
                            </p>
                        </div>
                        <div style="background: #ffe6e6; padding: 12px; border-radius: 6px; border-left: 4px solid #dc3545; margin-bottom: 15px;">
                            <strong>âš ï¸ Important:</strong> Don't select from the list! You must <strong>manually type or paste</strong> the scope URL in the "Input your own scopes" field.
                        </div>
                        <div style="background: #d1ecf1; padding: 12px; border-radius: 6px; border-left: 4px solid #0c5460; margin-bottom: 15px;">
                            <strong>ðŸ’¾ Auto-Save:</strong> Your token will be saved automatically and reused for all future highlights!<br>
                            <span style="font-size: 0.9em;">Token expires after 1 hour - you'll only need to enter it again if it expires.</span>
                        </div>
                        <div style="margin-bottom: 15px;">
                            <label style="display: block; margin-bottom: 8px; color: #333; font-weight: 600; font-size: 1.1rem;">ðŸ“ Paste Access Token Here:</label>
                            <textarea id="${textareaId}" placeholder="Paste your access token here (starts with ya29...)" style="width: 100%; min-height: 100px; padding: 12px; border: 2px solid #5612BD; border-radius: 6px; font-family: monospace; margin-bottom: 15px; box-sizing: border-box; font-size: 14px;"></textarea>
                        </div>
                        <div style="display: flex; gap: 10px;">
                            <button id="${cancelBtnId}" style="flex: 1; padding: 12px; background: #ccc; border: none; border-radius: 6px; cursor: pointer; font-weight: 600;">Cancel</button>
                            <button id="${useBtnId}" style="flex: 1; padding: 12px; background: linear-gradient(135deg, #5612BD 0%, #6b1dd4 100%); color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600;">Save & Highlight</button>
                        </div>
                    `;
                    
                    // Add event listeners after innerHTML is set
                    document.body.appendChild(tokenDiv);
                    
                    const textarea = document.getElementById(textareaId);
                    const useTokenBtn = document.getElementById(useBtnId);
                    const cancelBtn = document.getElementById(cancelBtnId);
                    
                    useTokenBtn.onclick = () => {
                        const token = textarea.value.trim();
                        if (token) {
                            tokenDiv.remove();
                            resolve(token);
                        } else {
                            alert('Please enter an access token');
                        }
                    };
                    
                    cancelBtn.onclick = () => {
                        tokenDiv.remove();
                        resolve(null);
                    };
                    
                    setTimeout(() => textarea.focus(), 100);
                });
            }

            async function highlightWithAPI(accessToken, sheetId, gid) {
                // Get sheet metadata first
                const metadataUrl = `https://sheets.googleapis.com/v4/spreadsheets/${sheetId}`;
                const metadataRes = await fetch(metadataUrl, {
                    headers: { "Authorization": `Bearer ${accessToken}` }
                });

                if (!metadataRes.ok) {
                    const errorData = await metadataRes.json();
                    throw new Error(`Failed to get sheet: ${errorData.error?.message || metadataRes.statusText}`);
                }

                const metadata = await metadataRes.json();
                const targetSheet = metadata.sheets.find(sheet => sheet.properties.sheetId === gid);
                
                if (!targetSheet) {
                    throw new Error(`Sheet with ID ${gid} not found`);
                }

                // Prepare highlight requests
                const requests = blankCells.map(cell => ({
                    repeatCell: {
                        range: {
                            sheetId: gid,
                            startRowIndex: cell.row - 1,
                            endRowIndex: cell.row,
                            startColumnIndex: cell.col,
                            endColumnIndex: cell.col + 1
                        },
                        cell: {
                            userEnteredFormat: {
                                backgroundColor: { red: 1, green: 1, blue: 0 }
                            }
                        },
                        fields: "userEnteredFormat.backgroundColor"
                    }
                }));

                if (requests.length === 0) {
                    throw new Error('No cells to highlight');
                }

                // Apply highlights
                const updateUrl = `https://sheets.googleapis.com/v4/spreadsheets/${sheetId}:batchUpdate`;
                const updateRes = await fetch(updateUrl, {
                    method: "POST",
                    headers: {
                        "Authorization": `Bearer ${accessToken}`,
                        "Content-Type": "application/json"
                    },
                    body: JSON.stringify({ requests })
                });

                if (!updateRes.ok) {
                    const errorData = await updateRes.json();
                    throw new Error(`Failed to highlight: ${errorData.error?.message || updateRes.statusText}`);
                }

                // Show success
                showHighlightSuccess(requests.length);
            }

            function showScriptInstructions(openedWindow, sheetUrl, script, bookmarkletUrl, cellCount) {
                const instructionsDiv = document.createElement('div');
                instructionsDiv.style.cssText = 'margin-top: 20px; padding: 25px; background: linear-gradient(135deg, rgba(86, 18, 189, 0.1) 0%, rgba(146, 80, 242, 0.1) 100%); border-radius: 12px; border: 2px solid #5612BD;';
                
                // Auto-copy script to clipboard
                let autoCopied = false;
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    navigator.clipboard.writeText(script).then(() => {
                        autoCopied = true;
                        console.log('Script auto-copied to clipboard');
                    }).catch(() => {
                        console.log('Could not auto-copy script');
                    });
                }
                
                instructionsDiv.innerHTML = `
                    <h3 style="margin-top: 0; color: #5612BD; font-size: 1.4rem; margin-bottom: 15px;">âœ¨ Quick Highlighting (30 seconds)</h3>
                    <div style="background: white; padding: 20px; border-radius: 8px; margin-bottom: 15px; border-left: 4px solid #5612BD;">
                        ${autoCopied ? '<div style="background: #d4edda; padding: 15px; border-radius: 6px; margin-bottom: 15px; border-left: 4px solid #28a745;"><strong>âœ… Script is already copied to your clipboard!</strong></div>' : ''}
                        <p style="margin: 0 0 15px 0; color: #333; line-height: 1.6; font-size: 1.1rem;">
                            <strong>Simple 3 steps:</strong>
                        </p>
                        <ol style="margin: 0; padding-left: 20px; color: #333; line-height: 2.5; font-size: 1.05rem;">
                            <li>Go to the <a href="${sheetUrl}" target="_blank" style="color: #5612BD; font-weight: 600;">Google Sheet tab</a> that just opened</li>
                            <li>Press <kbd style="background: #f0f0f0; padding: 6px 12px; border-radius: 4px; font-size: 1em; font-weight: 600;">F12</kbd> â†’ Click <strong>"Console"</strong> tab</li>
                            <li>Press <kbd style="background: #5612BD; color: white; padding: 6px 12px; border-radius: 4px; font-size: 1em; font-weight: 600;">Ctrl+V</kbd> (or <kbd style="background: #5612BD; color: white; padding: 6px 12px; border-radius: 4px; font-size: 1em; font-weight: 600;">Cmd+V</kbd> on Mac) â†’ Press <kbd style="background: #28a745; color: white; padding: 6px 12px; border-radius: 4px; font-size: 1em; font-weight: 600;">Enter</kbd></li>
                            <li>Watch the console for progress messages - you should see "âœ… Successfully highlighted" when done</li>
                        </ol>
                        <p style="margin: 15px 0 0 0; color: #28a745; font-weight: 600; font-size: 1.1rem;">
                            ðŸŽ‰ ${cellCount} blank cells will be highlighted automatically!
                        </p>
                        <div style="background: #e7f3ff; padding: 12px; border-radius: 6px; margin-top: 15px; border-left: 4px solid #2196F3;">
                            <strong>ðŸ’¡ Tip:</strong> If it doesn't work, check the console (F12) for error messages. The script will show detailed logs of what's happening.
                        </div>
                    </div>
                    <div style="background: #fff3cd; padding: 15px; border-radius: 8px; border-left: 4px solid #ffc107; margin-bottom: 15px;">
                        <strong>ðŸ’¡ Note:</strong> Uses your existing Google session - no login or token needed!
                    </div>
                    <div style="margin-bottom: 15px;">
                        <details style="cursor: pointer;">
                            <summary style="color: #5612BD; font-weight: 600; margin-bottom: 10px; user-select: none;">ðŸ“‹ View/Re-copy Script</summary>
                            <textarea id="console-script-instructions" readonly style="width: 100%; min-height: 150px; padding: 12px; border: 2px solid #5612BD; border-radius: 6px; font-family: monospace; font-size: 12px; background: #f8f9fa; box-sizing: border-box; margin-top: 10px;">${script}</textarea>
                            <button onclick="navigator.clipboard.writeText(document.getElementById('console-script-instructions').value).then(() => { this.textContent = 'âœ“ Copied!'; setTimeout(() => this.textContent = 'Copy Script', 2000); });" style="margin-top: 10px; padding: 10px 20px; background: linear-gradient(135deg, #5612BD 0%, #6b1dd4 100%); color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600;">Copy Script</button>
                        </details>
                    </div>
                    <div style="background: white; padding: 15px; border-radius: 8px; border-left: 4px solid #9250F2;">
                        <p style="margin: 0 0 10px 0; color: #333; font-weight: 600;">ðŸ”– Alternative: Bookmarklet (One-Click)</p>
                        <p style="margin: 0 0 10px 0; color: #666; font-size: 0.9em;">Drag this button to your bookmarks bar, then click it while on the Google Sheet:</p>
                        <a href="${bookmarkletUrl}" style="display: inline-block; padding: 12px 24px; background: linear-gradient(135deg, #9250F2 0%, #a866ff 100%); color: white; text-decoration: none; border-radius: 8px; font-weight: 600; cursor: move; box-shadow: 0 4px 12px rgba(146, 80, 242, 0.3);">ðŸ“Œ Highlight Blank Cells</a>
                    </div>
                `;
                
                const blankSpaceResults = document.getElementById('blank-space-results-section');
                if (blankSpaceResults) {
                    const existing = blankSpaceResults.querySelector('.script-instructions');
                    if (existing) existing.remove();
                    instructionsDiv.className = 'script-instructions';
                    blankSpaceResults.appendChild(instructionsDiv);
                }
            }

            function showSimpleHighlightButton(openedWindow, sheetUrl, bookmarkletUrl, cellCount) {
                const buttonDiv = document.createElement('div');
                buttonDiv.style.cssText = 'margin-top: 20px; padding: 25px; background: linear-gradient(135deg, rgba(86, 18, 189, 0.1) 0%, rgba(146, 80, 242, 0.1) 100%); border-radius: 12px; border: 2px solid #5612BD; text-align: center;';
                
                buttonDiv.innerHTML = `
                    <h3 style="margin-top: 0; color: #5612BD; font-size: 1.4rem; margin-bottom: 15px;">âœ¨ One-Click Highlighting</h3>
                    <div style="background: white; padding: 20px; border-radius: 8px; margin-bottom: 15px; border-left: 4px solid #5612BD;">
                        <p style="margin: 0 0 20px 0; color: #333; line-height: 1.6; font-size: 1.1rem;">
                            Go to the Google Sheet tab, then click the button below to highlight <strong>${cellCount}</strong> blank cells:
                        </p>
                        <a href="${bookmarkletUrl}" onclick="setTimeout(() => { const msg = document.querySelector('.highlight-success-msg'); if(msg) msg.style.display='block'; }, 1000);" style="display: inline-block; padding: 16px 32px; background: linear-gradient(135deg, #5612BD 0%, #6b1dd4 100%); color: white; text-decoration: none; border-radius: 10px; font-size: 1.2rem; font-weight: 600; box-shadow: 0 4px 12px rgba(86, 18, 189, 0.4); transition: all 0.3s ease;">
                            ðŸŽ¯ Highlight Blank Cells
                        </a>
                        <div class="highlight-success-msg" style="display: none; margin-top: 15px; padding: 12px; background: #d4edda; border-radius: 6px; color: #155724; font-weight: 600;">
                            âœ… Highlighting in progress! Check your Google Sheet tab.
                        </div>
                    </div>
                    <div style="background: #fff3cd; padding: 15px; border-radius: 8px; border-left: 4px solid #ffc107;">
                        <strong>ðŸ’¡ Note:</strong> Make sure you're on the Google Sheet tab when you click. Uses your existing Google session - no login needed!
                    </div>
                `;
                
                const blankSpaceResults = document.getElementById('blank-space-results-section');
                if (blankSpaceResults) {
                    const existing = blankSpaceResults.querySelector('.one-click-highlight');
                    if (existing) existing.remove();
                    buttonDiv.className = 'one-click-highlight';
                    blankSpaceResults.appendChild(buttonDiv);
                }
            }

            function showHighlightSuccess(count) {
                const successDiv = document.createElement('div');
                successDiv.style.cssText = 'margin-top: 20px; padding: 25px; background: linear-gradient(135deg, rgba(40, 167, 69, 0.1) 0%, rgba(40, 167, 69, 0.2) 100%); border-radius: 12px; border: 2px solid #28a745;';
                successDiv.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 15px;">
                        <div style="font-size: 3rem;">âœ…</div>
                        <div>
                            <h3 style="margin: 0; color: #155724; font-size: 1.4rem;">Success!</h3>
                            <p style="margin: 5px 0 0 0; color: #155724; font-size: 1.1rem;">
                                Successfully highlighted <strong>${count}</strong> blank cells in yellow!
                            </p>
                            <a href="${window.currentGSheetUrl || `https://docs.google.com/spreadsheets/d/${window.currentGSheetId}/edit#gid=${window.currentGSheetGid}`}" target="_blank" style="display: inline-block; margin-top: 10px; padding: 10px 20px; background: linear-gradient(135deg, #5612BD 0%, #6b1dd4 100%); color: white; text-decoration: none; border-radius: 6px; font-weight: 600;">
                                View Your Google Sheet â†’
                            </a>
                        </div>
                    </div>
                `;
                
                const blankSpaceResults = document.getElementById('blank-space-results-section');
                if (blankSpaceResults) {
                    const existing = blankSpaceResults.querySelector('.highlight-success');
                    if (existing) existing.remove();
                    successDiv.className = 'highlight-success';
                    blankSpaceResults.appendChild(successDiv);
                }
            }

            function generateDirectHighlightScript(sheetId, gid, cells) {
                return `
(function() {
    console.log('ðŸš€ Starting automatic highlight...');
    console.log('Sheet ID:', '${sheetId}');
    console.log('GID:', ${gid});
    console.log('Cells to highlight:', ${JSON.stringify(cells)});
    
    let attempts = 0;
    const maxAttempts = 30; // 15 seconds max wait
    
    // Try to get gapi from various possible locations
    function getGapi() {
        if (typeof gapi !== 'undefined') return gapi;
        if (typeof window !== 'undefined' && window.gapi) return window.gapi;
        if (typeof google !== 'undefined' && google.gapi) return google.gapi;
        return null;
    }
    
    function highlightCells() {
        attempts++;
        console.log('Attempt', attempts, 'of', maxAttempts);
        
        const gapi = getGapi();
        
        // Check if gapi is available
        if (!gapi) {
            console.log('â³ gapi not found, waiting...');
            if (attempts < maxAttempts) {
                setTimeout(highlightCells, 500);
            } else {
                alert('âŒ Error: Google Sheets API (gapi) not found.\\n\\nMake sure you are on a Google Sheets page and try refreshing the page.');
            }
            return;
        }
        
        console.log('âœ… gapi found');
        
        // Check if gapi.client exists
        if (!gapi.client) {
            console.log('â³ gapi.client not found, waiting...');
            if (attempts < maxAttempts) {
                setTimeout(highlightCells, 500);
            } else {
                alert('âŒ Error: gapi.client not initialized.\\n\\nTry refreshing the Google Sheets page and run the script again.');
            }
            return;
        }
        
        console.log('âœ… gapi.client found');
        
        // Try to initialize or use the API
        if (!gapi.client.sheets) {
            console.log('â³ Loading Google Sheets API v4...');
            try {
                gapi.client.load('sheets', 'v4').then(function() {
                    console.log('âœ… Google Sheets API loaded');
                    performHighlight(gapi);
                }).catch(function(error) {
                    console.error('âŒ Error loading API:', error);
                    // Try alternative initialization
                    tryAlternativeMethod(gapi);
                });
            } catch (e) {
                console.error('âŒ Exception loading API:', e);
                tryAlternativeMethod(gapi);
            }
        } else {
            console.log('âœ… Google Sheets API already loaded');
            performHighlight(gapi);
        }
    }
    
    function tryAlternativeMethod(gapi) {
        console.log('ðŸ”„ Trying alternative method...');
        // Try using the API directly if it's available in a different way
        if (gapi.client && gapi.client.request) {
            performHighlightWithRequest(gapi);
        } else {
            alert('âŒ Could not initialize Google Sheets API.\\n\\nPlease make sure you are logged into Google and have edit access to the sheet.');
        }
    }
    
    function performHighlight(gapi) {
        console.log('ðŸŽ¨ Preparing highlight requests...');
        
        const requests = cells.map(cell => ({
            repeatCell: {
                range: {
                    sheetId: ${gid},
                    startRowIndex: cell.rowIndex,
                    endRowIndex: cell.rowIndex + 1,
                    startColumnIndex: cell.colIndex,
                    endColumnIndex: cell.colIndex + 1
                },
                cell: {
                    userEnteredFormat: {
                        backgroundColor: {
                            red: 1,
                            green: 1,
                            blue: 0
                        }
                    }
                },
                fields: 'userEnteredFormat.backgroundColor'
            }
        }));
        
        console.log('ðŸ“¤ Sending', requests.length, 'highlight requests...');
        console.log('Request details:', JSON.stringify(requests[0], null, 2));
        
        try {
            gapi.client.sheets.spreadsheets.batchUpdate({
                spreadsheetId: '${sheetId}',
                resource: { requests: requests }
            }).then(function(response) {
                console.log('âœ… Success! Response:', response);
                console.log('âœ… Successfully highlighted ' + cells.length + ' cells!');
                alert('âœ… Successfully highlighted ' + cells.length + ' blank cells in yellow!\\n\\nThe page will reload in 2 seconds...');
                setTimeout(() => {
                    console.log('ðŸ”„ Reloading page...');
                    location.reload();
                }, 2000);
            }).catch(function(error) {
                handleError(error);
            });
        } catch (e) {
            console.error('âŒ Exception calling API:', e);
            alert('âŒ Exception: ' + (e.message || 'Unknown error') + '\\n\\nCheck the console for details.');
        }
    }
    
    function handleError(error) {
        console.error('âŒ Error highlighting cells:', error);
        console.error('Error type:', typeof error);
        console.error('Error keys:', Object.keys(error || {}));
        
        if (error && typeof error === 'object') {
            console.error('Full error object:', JSON.stringify(error, null, 2));
        }
        
        let errorMsg = 'Unknown error';
        if (error && error.result && error.result.error) {
            const err = error.result.error;
            errorMsg = err.message || JSON.stringify(err);
            console.error('API Error:', err);
        } else if (error && error.message) {
            errorMsg = error.message;
        } else if (error && error.statusText) {
            errorMsg = error.statusText;
        } else if (typeof error === 'string') {
            errorMsg = error;
        }
        
        console.error('Final error message:', errorMsg);
        alert('âŒ Error highlighting cells:\\n\\n' + errorMsg + '\\n\\nCheck the console (F12) for more details.\\n\\nMake sure you have edit access to the sheet.');
    }
    
    // Start the process
    highlightCells();
})();
                `.trim();
            }

            function showDirectHighlightInstructions(openedWindow, sheetUrl, script, cellCount) {
                const instructionsDiv = document.createElement('div');
                instructionsDiv.style.cssText = 'margin-top: 20px; padding: 25px; background: linear-gradient(135deg, rgba(86, 18, 189, 0.1) 0%, rgba(146, 80, 242, 0.1) 100%); border-radius: 12px; border: 2px solid #5612BD;';
                
                // Auto-copy script to clipboard
                if (navigator.clipboard) {
                    navigator.clipboard.writeText(script).then(() => {
                        console.log('Script auto-copied to clipboard');
                    }).catch(() => {
                        console.log('Could not auto-copy script');
                    });
                }
                
                const bookmarklet = 'javascript:' + encodeURIComponent(script);
                
                instructionsDiv.innerHTML = `
                    <h3 style="margin-top: 0; color: #5612BD; font-size: 1.4rem; margin-bottom: 15px;">âœ¨ Automatic Highlighting</h3>
                    <div style="background: white; padding: 20px; border-radius: 8px; margin-bottom: 15px; border-left: 4px solid #5612BD;">
                        <div style="background: #d4edda; padding: 15px; border-radius: 6px; margin-bottom: 15px; border-left: 4px solid #28a745;">
                            <strong>âœ… Script is already copied to your clipboard!</strong>
                        </div>
                        <p style="margin: 0 0 15px 0; color: #333; line-height: 1.6; font-size: 1.1rem;">
                            <strong>Quick Steps (30 seconds):</strong>
                        </p>
                        <ol style="margin: 0; padding-left: 20px; color: #333; line-height: 2.5; font-size: 1.05rem;">
                            <li>Go to the Google Sheet tab that just opened</li>
                            <li>Press <kbd style="background: #f0f0f0; padding: 6px 12px; border-radius: 4px; font-size: 1em; font-weight: 600;">F12</kbd> to open Developer Tools</li>
                            <li>Click the <strong>"Console"</strong> tab</li>
                            <li>Press <kbd style="background: #5612BD; color: white; padding: 6px 12px; border-radius: 4px; font-size: 1em; font-weight: 600;">Ctrl+V</kbd> (or <kbd style="background: #5612BD; color: white; padding: 6px 12px; border-radius: 4px; font-size: 1em; font-weight: 600;">Cmd+V</kbd> on Mac) to paste</li>
                            <li>Press <kbd style="background: #28a745; color: white; padding: 6px 12px; border-radius: 4px; font-size: 1em; font-weight: 600;">Enter</kbd></li>
                        </ol>
                        <p style="margin: 15px 0 0 0; color: #28a745; font-weight: 600; font-size: 1.1rem;">
                            ðŸŽ‰ ${cellCount} blank cells will be highlighted automatically!
                        </p>
                    </div>
                    <div style="background: #fff3cd; padding: 15px; border-radius: 8px; border-left: 4px solid #ffc107; margin-bottom: 15px;">
                        <strong>ðŸ’¡ Note:</strong> This uses your existing Google session, so no login or token needed!
                    </div>
                    <div style="margin-bottom: 15px;">
                        <details style="cursor: pointer;">
                            <summary style="color: #5612BD; font-weight: 600; margin-bottom: 10px; user-select: none;">ðŸ“‹ View/Re-copy Script (if needed)</summary>
                            <textarea id="console-script-direct" readonly style="width: 100%; min-height: 150px; padding: 12px; border: 2px solid #5612BD; border-radius: 6px; font-family: monospace; font-size: 12px; background: #f8f9fa; box-sizing: border-box; margin-top: 10px;">${script}</textarea>
                            <button onclick="navigator.clipboard.writeText(document.getElementById('console-script-direct').value).then(() => { this.textContent = 'âœ“ Copied!'; setTimeout(() => this.textContent = 'Copy Script', 2000); });" style="margin-top: 10px; padding: 10px 20px; background: linear-gradient(135deg, #5612BD 0%, #6b1dd4 100%); color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600;">Copy Script Again</button>
                        </details>
                    </div>
                    <div style="background: white; padding: 15px; border-radius: 8px; border-left: 4px solid #9250F2;">
                        <p style="margin: 0 0 10px 0; color: #333; font-weight: 600;">ðŸ”– Alternative: Bookmarklet (One-Click)</p>
                        <p style="margin: 0 0 10px 0; color: #666; font-size: 0.9em;">Drag this button to your bookmarks bar, then click it while on the Google Sheet:</p>
                        <a href="${bookmarklet}" style="display: inline-block; padding: 12px 24px; background: linear-gradient(135deg, #9250F2 0%, #a866ff 100%); color: white; text-decoration: none; border-radius: 8px; font-weight: 600; cursor: move; box-shadow: 0 4px 12px rgba(146, 80, 242, 0.3);">ðŸ“Œ Highlight Blank Cells</a>
                    </div>
                `;
                
                const blankSpaceResults = document.getElementById('blank-space-results-section');
                if (blankSpaceResults) {
                    // Remove existing instructions
                    const existing = blankSpaceResults.querySelector('.direct-highlight-instructions');
                    if (existing) existing.remove();
                    instructionsDiv.className = 'direct-highlight-instructions';
                    blankSpaceResults.appendChild(instructionsDiv);
                }
            }

            function generateAutoHighlightScript(sheetId, gid, cells) {
                return `
                    (function() {
                        console.log('Auto-highlight script starting...');
                        const sheetId = '${sheetId}';
                        const gid = ${gid};
                        const cells = ${JSON.stringify(cells)};
                        
                        function highlightCells() {
                            // Wait for gapi to be available
                            if (typeof gapi === 'undefined' || !gapi.client || !gapi.client.sheets) {
                                console.log('Waiting for Google Sheets API...');
                                setTimeout(highlightCells, 500);
                                return;
                            }
                            
                            // Check if we need to load the API
                            if (!gapi.client.sheets) {
                                gapi.client.load('sheets', 'v4', function() {
                                    performHighlight();
                                });
                            } else {
                                performHighlight();
                            }
                        }
                        
                        function performHighlight() {
                            const requests = cells.map(cell => ({
                                repeatCell: {
                                    range: {
                                        sheetId: gid,
                                        startRowIndex: cell.rowIndex,
                                        endRowIndex: cell.rowIndex + 1,
                                        startColumnIndex: cell.colIndex,
                                        endColumnIndex: cell.colIndex + 1
                                    },
                                    cell: {
                                        userEnteredFormat: {
                                            backgroundColor: {
                                                red: 1,
                                                green: 1,
                                                blue: 0
                                            }
                                        }
                                    },
                                    fields: 'userEnteredFormat.backgroundColor'
                                }
                            }));
                            
                            gapi.client.sheets.spreadsheets.batchUpdate({
                                spreadsheetId: sheetId,
                                resource: { requests: requests }
                            }).then(function(response) {
                                console.log('Successfully highlighted cells!');
                                alert('âœ… Successfully highlighted ' + cells.length + ' blank cells in yellow!');
                                // Reload to see the changes
                                setTimeout(() => location.reload(), 1000);
                            }).catch(function(error) {
                                console.error('Error highlighting cells:', error);
                                alert('Could not highlight automatically. Please use the console script method.');
                            });
                        }
                        
                        // Start the process
                        highlightCells();
                    })();
                `;
            }

            function injectScriptViaURL(targetWindow, scriptContent) {
                try {
                    // Create a bookmarklet URL
                    const bookmarklet = 'javascript:' + encodeURIComponent(scriptContent);
                    
                    // Try to navigate to it (this won't work due to security, but we'll provide it as fallback)
                    // Instead, we'll provide it as a clickable link
                    return bookmarklet;
                } catch (e) {
                    console.error('Could not create bookmarklet:', e);
                    return null;
                }
            }

            function showHighlightSuccess(count) {
                const successDiv = document.createElement('div');
                successDiv.style.cssText = 'margin-top: 20px; padding: 25px; background: linear-gradient(135deg, rgba(40, 167, 69, 0.1) 0%, rgba(40, 167, 69, 0.2) 100%); border-radius: 12px; border: 2px solid #28a745;';
                successDiv.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 15px;">
                        <div style="font-size: 3rem;">âœ…</div>
                        <div>
                            <h3 style="margin: 0; color: #155724; font-size: 1.4rem;">Success!</h3>
                            <p style="margin: 5px 0 0 0; color: #155724; font-size: 1.1rem;">
                                Successfully highlighted <strong>${count}</strong> blank cells in yellow!
                            </p>
                            <a href="${window.currentGSheetUrl || `https://docs.google.com/spreadsheets/d/${window.currentGSheetId}/edit#gid=${window.currentGSheetGid}`}" target="_blank" style="display: inline-block; margin-top: 10px; padding: 10px 20px; background: linear-gradient(135deg, #5612BD 0%, #6b1dd4 100%); color: white; text-decoration: none; border-radius: 6px; font-weight: 600;">
                                View Your Google Sheet â†’
                            </a>
                        </div>
                    </div>
                `;
                
                const blankSpaceResults = document.getElementById('blank-space-results-section');
                if (blankSpaceResults) {
                    const existing = blankSpaceResults.querySelector('.highlight-success');
                    if (existing) existing.remove();
                    successDiv.className = 'highlight-success';
                    blankSpaceResults.appendChild(successDiv);
                }
            }

            function showAutoHighlightInstructions(openedWindow, sheetUrl) {
                const instructionsDiv = document.createElement('div');
                instructionsDiv.style.cssText = 'margin-top: 20px; padding: 25px; background: linear-gradient(135deg, rgba(86, 18, 189, 0.1) 0%, rgba(146, 80, 242, 0.1) 100%); border-radius: 12px; border: 2px solid #5612BD;';
                
                const scriptContent = generateAutoHighlightScript(
                    window.currentGSheetId,
                    parseInt(window.currentGSheetGid),
                    blankCells.map(cell => ({
                        row: cell.row - 1,
                        col: cell.col,
                        rowIndex: cell.row - 1,
                        colIndex: cell.col
                    }))
                );

                const bookmarklet = 'javascript:' + encodeURIComponent(scriptContent);
                
                // Auto-copy script to clipboard
                if (navigator.clipboard) {
                    navigator.clipboard.writeText(scriptContent.trim()).then(() => {
                        console.log('Script auto-copied to clipboard');
                    }).catch(() => {
                        console.log('Could not auto-copy script');
                    });
                }
                
                instructionsDiv.innerHTML = `
                    <h3 style="margin-top: 0; color: #5612BD; font-size: 1.4rem; margin-bottom: 15px;">âœ¨ One-Step Highlighting</h3>
                    <div style="background: white; padding: 20px; border-radius: 8px; margin-bottom: 15px; border-left: 4px solid #5612BD;">
                        <div style="background: #d4edda; padding: 15px; border-radius: 6px; margin-bottom: 15px; border-left: 4px solid #28a745;">
                            <strong>âœ… Script is already copied to your clipboard!</strong>
                        </div>
                        <p style="margin: 0 0 15px 0; color: #333; line-height: 1.6; font-size: 1.1rem;">
                            <strong>Just 2 steps:</strong>
                        </p>
                        <ol style="margin: 0; padding-left: 20px; color: #333; line-height: 2.5; font-size: 1.05rem;">
                            <li>Go to the Google Sheet tab that just opened</li>
                            <li>Press <kbd style="background: #f0f0f0; padding: 6px 12px; border-radius: 4px; font-size: 1em; font-weight: 600;">F12</kbd> â†’ Click <strong>"Console"</strong> tab â†’ Press <kbd style="background: #5612BD; color: white; padding: 6px 12px; border-radius: 4px; font-size: 1em; font-weight: 600;">Ctrl+V</kbd> (or <kbd style="background: #5612BD; color: white; padding: 6px 12px; border-radius: 4px; font-size: 1em; font-weight: 600;">Cmd+V</kbd> on Mac) â†’ Press <kbd style="background: #28a745; color: white; padding: 6px 12px; border-radius: 4px; font-size: 1em; font-weight: 600;">Enter</kbd></li>
                        </ol>
                        <p style="margin: 15px 0 0 0; color: #28a745; font-weight: 600; font-size: 1.1rem;">
                            ðŸŽ‰ That's it! Cells will be highlighted automatically!
                        </p>
                    </div>
                    <div style="background: #fff3cd; padding: 15px; border-radius: 8px; border-left: 4px solid #ffc107; margin-bottom: 15px;">
                        <strong>ðŸ’¡ Tip:</strong> The script uses your existing Google session, so no login or authentication needed!
                    </div>
                    <div style="margin-bottom: 15px;">
                        <details style="cursor: pointer;">
                            <summary style="color: #5612BD; font-weight: 600; margin-bottom: 10px; user-select: none;">ðŸ“‹ View/Re-copy Script (if needed)</summary>
                            <textarea id="console-script-auto" readonly style="width: 100%; min-height: 150px; padding: 12px; border: 2px solid #5612BD; border-radius: 6px; font-family: monospace; font-size: 12px; background: #f8f9fa; box-sizing: border-box; margin-top: 10px;">${scriptContent.trim()}</textarea>
                            <button onclick="navigator.clipboard.writeText(document.getElementById('console-script-auto').value).then(() => { this.textContent = 'âœ“ Copied!'; setTimeout(() => this.textContent = 'Copy Script', 2000); });" style="margin-top: 10px; padding: 10px 20px; background: linear-gradient(135deg, #5612BD 0%, #6b1dd4 100%); color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600;">Copy Script Again</button>
                        </details>
                    </div>
                    <div style="background: white; padding: 15px; border-radius: 8px; border-left: 4px solid #9250F2;">
                        <p style="margin: 0 0 10px 0; color: #333; font-weight: 600;">ðŸ”– Alternative: Bookmarklet (One-Click)</p>
                        <p style="margin: 0 0 10px 0; color: #666; font-size: 0.9em;">Drag this button to your bookmarks bar, then click it while on the Google Sheet:</p>
                        <a href="${bookmarklet}" style="display: inline-block; padding: 12px 24px; background: linear-gradient(135deg, #9250F2 0%, #a866ff 100%); color: white; text-decoration: none; border-radius: 8px; font-weight: 600; cursor: move; box-shadow: 0 4px 12px rgba(146, 80, 242, 0.3);">ðŸ“Œ Highlight Blank Cells</a>
                    </div>
                `;
                
                const blankSpaceResults = document.getElementById('blank-space-results-section');
                if (blankSpaceResults) {
                    // Remove existing instructions
                    const existing = blankSpaceResults.querySelector('.auto-highlight-instructions');
                    if (existing) existing.remove();
                    instructionsDiv.className = 'auto-highlight-instructions';
                    blankSpaceResults.appendChild(instructionsDiv);
                }
            }

            function getGoogleAccessToken() {
                return new Promise((resolve) => {
                    // Check if we have a stored token (for convenience)
                    const storedToken = sessionStorage.getItem('google_access_token');
                    if (storedToken) {
                        const useStored = confirm(
                            'Use previously saved access token?\n\n' +
                            'OK = Use saved token\n' +
                            'Cancel = Enter new token'
                        );
                        if (useStored) {
                            resolve(storedToken);
                            return;
                        }
                    }

                    // Show token input dialog
                    showTokenInputDialog(resolve);
                });
            }

            function showTokenInputDialog(resolve) {
                const tokenDiv = document.createElement('div');
                tokenDiv.style.cssText = 'position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 30px; border-radius: 12px; box-shadow: 0 8px 32px rgba(0,0,0,0.3); z-index: 10000; max-width: 600px; width: 90%; max-height: 90vh; overflow-y: auto;';
                
                const cancelBtn = document.createElement('button');
                cancelBtn.textContent = 'Cancel';
                cancelBtn.style.cssText = 'flex: 1; padding: 12px; background: #ccc; border: none; border-radius: 6px; cursor: pointer; font-weight: 600;';
                cancelBtn.onclick = () => {
                    tokenDiv.remove();
                    resolve(null);
                };

                const useTokenBtn = document.createElement('button');
                useTokenBtn.textContent = 'Use Token';
                useTokenBtn.style.cssText = 'flex: 1; padding: 12px; background: linear-gradient(135deg, #5612BD 0%, #6b1dd4 100%); color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600;';
                useTokenBtn.onclick = () => {
                    const tokenInput = document.getElementById('token-input');
                    const saveTokenCheckbox = document.getElementById('save-token-checkbox');
                    const token = tokenInput ? tokenInput.value.trim() : '';
                    if (token) {
                        // Save token if checkbox is checked
                        if (saveTokenCheckbox && saveTokenCheckbox.checked) {
                            sessionStorage.setItem('google_access_token', token);
                        }
                        tokenDiv.remove();
                        resolve(token);
                    } else {
                        alert('Please enter an access token');
                    }
                };

                const textarea = document.createElement('textarea');
                textarea.id = 'token-input';
                textarea.placeholder = 'Paste your access token here...';
                textarea.style.cssText = 'width: 100%; min-height: 100px; padding: 12px; border: 2px solid #5612BD; border-radius: 6px; font-family: monospace; margin-bottom: 15px; box-sizing: border-box; font-size: 14px;';

                const saveTokenCheckbox = document.createElement('input');
                saveTokenCheckbox.type = 'checkbox';
                saveTokenCheckbox.id = 'save-token-checkbox';
                saveTokenCheckbox.checked = true;
                saveTokenCheckbox.style.cssText = 'margin-right: 8px;';

                const checkboxLabel = document.createElement('label');
                checkboxLabel.htmlFor = 'save-token-checkbox';
                checkboxLabel.textContent = 'Save token for this session';
                checkboxLabel.style.cssText = 'color: #666; font-size: 14px; cursor: pointer;';

                const checkboxDiv = document.createElement('div');
                checkboxDiv.style.cssText = 'margin-bottom: 15px; display: flex; align-items: center;';
                checkboxDiv.appendChild(saveTokenCheckbox);
                checkboxDiv.appendChild(checkboxLabel);

                const buttonDiv = document.createElement('div');
                buttonDiv.style.cssText = 'display: flex; gap: 10px;';
                buttonDiv.appendChild(cancelBtn);
                buttonDiv.appendChild(useTokenBtn);

                tokenDiv.innerHTML = `
                    <h3 style="margin-top: 0; color: #5612BD; margin-bottom: 15px; font-size: 1.5rem;">ðŸ”‘ Get Google Access Token</h3>
                    <div style="background: linear-gradient(135deg, rgba(86, 18, 189, 0.1) 0%, rgba(146, 80, 242, 0.1) 100%); padding: 15px; border-radius: 8px; border-left: 4px solid #5612BD; margin-bottom: 20px;">
                        <p style="margin: 0; color: #250651; font-weight: 500; line-height: 1.6;">
                            <strong>Quick Steps:</strong> Get your access token in 30 seconds - no setup required!
                        </p>
                    </div>
                    <ol style="color: #333; line-height: 2; margin-bottom: 20px; padding-left: 20px;">
                        <li>Click this link: <a href="https://developers.google.com/oauthplayground/" target="_blank" style="color: #5612BD; font-weight: 600;">OAuth 2.0 Playground</a> (opens in new tab)</li>
                        <li>In the left panel, scroll and find <strong>"Google Sheets API v4"</strong></li>
                        <li>Check the box: <code style="background: #f0f0f0; padding: 2px 6px; border-radius: 3px;">https://www.googleapis.com/auth/spreadsheets</code></li>
                        <li>Click <strong>"Authorize APIs"</strong> button at the top</li>
                        <li>Sign in with your Google account and click <strong>"Allow"</strong></li>
                        <li>Click <strong>"Exchange authorization code for tokens"</strong> button</li>
                        <li>Copy the <strong>"Access token"</strong> value (long string starting with "ya29...")</li>
                        <li>Paste it in the box below</li>
                    </ol>
                    <div style="background: #fff3cd; padding: 12px; border-radius: 6px; border-left: 4px solid #ffc107; margin-bottom: 15px;">
                        <strong>ðŸ’¡ Tip:</strong> The token expires after 1 hour. You'll need to get a new one if it expires.
                    </div>
                `;
                tokenDiv.appendChild(textarea);
                tokenDiv.appendChild(checkboxDiv);
                tokenDiv.appendChild(buttonDiv);
                document.body.appendChild(tokenDiv);
                
                // Focus on textarea
                setTimeout(() => textarea.focus(), 100);
            }

            function showManualHighlightOption() {
                const scriptCode = generateGSheetHighlightScript(blankCells);
                showAutomatedHighlightOption(scriptCode);
            }

            async function highlightEmptyCellsWithAPI(accessToken) {
                const spreadsheetId = window.currentGSheetId;
                const sheetId = parseInt(window.currentGSheetGid);
                
                try {
                    // First, get the sheet name from the spreadsheet metadata
                    const metadataUrl = `https://sheets.googleapis.com/v4/spreadsheets/${spreadsheetId}`;
                    const metadataRes = await fetch(metadataUrl, {
                        headers: {
                            "Authorization": `Bearer ${accessToken}`
                        }
                    });

                    if (!metadataRes.ok) {
                        const errorData = await metadataRes.json();
                        throw new Error(`Failed to get sheet metadata: ${errorData.error?.message || metadataRes.statusText}`);
                    }

                    const metadata = await metadataRes.json();
                    const targetSheet = metadata.sheets.find(sheet => sheet.properties.sheetId === sheetId);
                    
                    if (!targetSheet) {
                        throw new Error(`Sheet with ID ${sheetId} not found in spreadsheet`);
                    }

                    const sheetName = targetSheet.properties.title;
                    
                    // Determine the range to read (find max row and column from blankCells)
                    let maxRow = 0;
                    let maxCol = 0;
                    blankCells.forEach(cell => {
                        if (cell.row > maxRow) maxRow = cell.row;
                        if (cell.col > maxCol) maxCol = cell.col;
                    });
                    
                    // Add some buffer
                    maxRow = Math.max(maxRow + 10, 100);
                    maxCol = Math.max(maxCol + 5, 26);
                    
                    // Convert maxCol to column letter (Z = 26)
                    const endCol = getColumnLetter(maxCol - 1);
                    const range = `'${sheetName}'!A1:${endCol}${maxRow}`;

                    // 1ï¸âƒ£ READ SHEET DATA from the specific sheet
                    const readUrl = `https://sheets.googleapis.com/v4/spreadsheets/${spreadsheetId}/values/${encodeURIComponent(range)}`;
                    
                    const readRes = await fetch(readUrl, {
                        headers: {
                            "Authorization": `Bearer ${accessToken}`
                        }
                    });

                    if (!readRes.ok) {
                        const errorData = await readRes.json();
                        throw new Error(`Failed to read sheet: ${errorData.error?.message || readRes.statusText}`);
                    }

                    const data = await readRes.json();
                    const values = data.values || [];

                    let requests = [];

                    // 2ï¸âƒ£ DETECT EMPTY CELLS (only highlight the ones we found earlier)
                    blankCells.forEach(cell => {
                        const row = cell.row - 1; // Convert to 0-based
                        const col = cell.col; // Already 0-based
                        
                        // Verify the cell is actually empty
                        const cellValue = values[row] && values[row][col] !== undefined
                            ? values[row][col].trim()
                            : "";

                        if (cellValue === "") {
                            requests.push({
                                repeatCell: {
                                    range: {
                                        sheetId: sheetId,
                                        startRowIndex: row,
                                        endRowIndex: row + 1,
                                        startColumnIndex: col,
                                        endColumnIndex: col + 1
                                    },
                                    cell: {
                                        userEnteredFormat: {
                                            backgroundColor: {
                                                red: 1,
                                                green: 1,
                                                blue: 0
                                            }
                                        }
                                    },
                                    fields: "userEnteredFormat.backgroundColor"
                                }
                            });
                        }
                    });

                    if (requests.length === 0) {
                        showBlankSpaceError('No empty cells found to highlight.');
                        return;
                    }

                    // 3ï¸âƒ£ APPLY YELLOW HIGHLIGHT
                    const updateUrl = `https://sheets.googleapis.com/v4/spreadsheets/${spreadsheetId}:batchUpdate`;

                    const updateRes = await fetch(updateUrl, {
                        method: "POST",
                        headers: {
                            "Authorization": `Bearer ${accessToken}`,
                            "Content-Type": "application/json"
                        },
                        body: JSON.stringify({ requests })
                    });

                    if (!updateRes.ok) {
                        const errorData = await updateRes.json();
                        throw new Error(`Failed to update sheet: ${errorData.error?.message || updateRes.statusText}`);
                    }

                    // Show success message
                    const successDiv = document.createElement('div');
                    successDiv.style.marginTop = '20px';
                    successDiv.style.padding = '20px';
                    successDiv.style.backgroundColor = '#d4edda';
                    successDiv.style.borderRadius = '8px';
                    successDiv.style.border = '2px solid #28a745';
                    successDiv.style.color = '#155724';
                    successDiv.innerHTML = `
                        <strong>âœ… Success!</strong> ${requests.length} blank cells have been highlighted in yellow in your Google Sheet.
                        <br><a href="${window.currentGSheetUrl || `https://docs.google.com/spreadsheets/d/${spreadsheetId}/edit#gid=${sheetId}`}" target="_blank" style="color: #5612BD; font-weight: 600; margin-top: 10px; display: inline-block;">View your Google Sheet â†’</a>
                    `;
                    
                    const blankSpaceResults = document.getElementById('blank-space-results-section');
                    if (blankSpaceResults) {
                        // Remove any existing success/error messages
                        const existingSuccess = blankSpaceResults.querySelector('.success-message');
                        if (existingSuccess) existingSuccess.remove();
                        successDiv.className = 'success-message';
                        blankSpaceResults.appendChild(successDiv);
                    }

                    console.log("âœ… Empty cells highlighted!");
                } catch (error) {
                    console.error('API Error:', error);
                    throw error;
                }
            }

            function injectHighlightScript(targetWindow) {
                if (!targetWindow || targetWindow.closed) {
                    return;
                }
                
                try {
                    // Create script that will run in the Google Sheets page context
                    const script = targetWindow.document.createElement('script');
                    script.textContent = generateBrowserHighlightScript();
                    targetWindow.document.head.appendChild(script);
                } catch (e) {
                    // Cross-origin restrictions - this is expected
                    console.log('Cannot inject script due to cross-origin restrictions');
                }
            }

            function generateBrowserHighlightScript() {
                const sheetId = window.currentGSheetId;
                const gid = parseInt(window.currentGSheetGid);
                const cells = blankCells.map(cell => {
                    const colLetter = getColumnLetter(cell.col);
                    return { row: cell.row, col: colLetter, colIndex: cell.col };
                });

                return `
                    (function() {
                        console.log('Highlight script loaded');
                        const sheetId = '${sheetId}';
                        const gid = ${gid};
                        const cells = ${JSON.stringify(cells)};
                        
                        // Wait for Google Sheets API to be available
                        function waitForAPI() {
                            if (window.gapi && window.gapi.client && window.gapi.client.sheets) {
                                highlightCells();
                            } else {
                                setTimeout(waitForAPI, 500);
                            }
                        }
                        
                        function highlightCells() {
                            const requests = cells.map(cell => ({
                                repeatCell: {
                                    range: {
                                        sheetId: gid,
                                        startRowIndex: cell.row - 1,
                                        endRowIndex: cell.row,
                                        startColumnIndex: cell.colIndex,
                                        endColumnIndex: cell.colIndex + 1
                                    },
                                    cell: {
                                        userEnteredFormat: {
                                            backgroundColor: { red: 1, green: 1, blue: 0 }
                                        }
                                    },
                                    fields: 'userEnteredFormat.backgroundColor'
                                }
                            }));
                            
                            window.gapi.client.sheets.spreadsheets.batchUpdate({
                                spreadsheetId: sheetId,
                                resource: { requests: requests }
                            }).then(() => {
                                alert('Successfully highlighted ' + cells.length + ' blank cells!');
                                location.reload();
                            }).catch(err => {
                                console.error('Error:', err);
                                alert('Could not highlight automatically. Please use the Apps Script method from the instructions.');
                            });
                        }
                        
                        waitForAPI();
                    })();
                `;
            }

            function showAutomatedHighlightOption(scriptCode, openedWindow) {
                const autoDiv = document.createElement('div');
                autoDiv.style.marginTop = '20px';
                autoDiv.style.padding = '30px';
                autoDiv.style.backgroundColor = '#f3e8ff';
                autoDiv.style.borderRadius = '12px';
                autoDiv.style.border = '2px solid #5612BD';
                autoDiv.style.boxShadow = '0 4px 12px rgba(86, 18, 189, 0.15)';
                
                const bookmarkletCode = generateBookmarklet();
                const sheetUrl = window.currentGSheetUrl || `https://docs.google.com/spreadsheets/d/${window.currentGSheetId}/edit#gid=${window.currentGSheetGid}`;
                const appsScriptEditorUrl = `https://script.google.com/home/projects/create?folder=0&fileId=0`;
                
                // Create a data URL with the script code that can be used
                const scriptDataUrl = `data:text/plain;charset=utf-8,${encodeURIComponent(scriptCode)}`;
                
                autoDiv.innerHTML = `
                    <div style="margin-bottom: 20px; padding: 15px; background: linear-gradient(135deg, rgba(86, 18, 189, 0.1) 0%, rgba(146, 80, 242, 0.1) 100%); border-radius: 8px; border: 1px solid #5612BD;">
                        <p style="margin: 0; color: #250651; font-weight: 500; line-height: 1.6;">
                            <strong>âœ… Script is ready!</strong> The code below is <strong>automatically copied to your clipboard</strong>. 
                            Click the button to open Apps Script, then just <strong>paste (Ctrl+V)</strong> and <strong>click Run</strong>. 
                            It will highlight all ${blankCells.length} blank cells in yellow.
                        </p>
                    </div>
                    <h3 style="margin-top: 0; color: #5612BD; font-size: 1.5rem; margin-bottom: 20px;">âœ¨ Quick Start (3 Steps)</h3>
                    
                    <div style="margin-bottom: 25px; padding: 20px; background: white; border-radius: 8px; border-left: 4px solid #5612BD; box-shadow: 0 2px 8px rgba(0,0,0,0.05);">
                        <div style="margin-bottom: 20px; text-align: center;">
                            <button onclick="openAppsScriptWithCode()" style="padding: 16px 32px; background: linear-gradient(135deg, #5612BD 0%, #6b1dd4 100%); color: white; border: none; border-radius: 10px; font-size: 1.1rem; font-weight: 600; cursor: pointer; box-shadow: 0 4px 12px rgba(86, 18, 189, 0.4); transition: all 0.3s ease;">
                                ðŸš€ Open Apps Script Editor
                            </button>
                            <p style="margin-top: 10px; color: #666; font-size: 0.9em;">Click above, then follow steps below</p>
                        </div>
                        <h4 style="color: #5612BD; margin-bottom: 15px; font-size: 1.2rem;">ðŸ“‹ Steps:</h4>
                        <ol style="line-height: 2.2; margin-left: 20px; color: #333; font-size: 1.05rem;">
                            <li>In the Apps Script editor that just opened, <strong>paste the code</strong> (Ctrl+V / Cmd+V - it's already copied!)</li>
                            <li>Click the <strong>Run</strong> button (â–¶) at the top - the script will automatically highlight cells</li>
                            <li>Click <strong>"Review permissions"</strong> â†’ <strong>"Allow"</strong> when prompted (first time only)</li>
                            <li>Go back to your <a href="${sheetUrl}" target="_blank" style="color: #5612BD; font-weight: 600;">Google Sheet</a> and refresh - ${blankCells.length} blank cells are now highlighted in yellow! ðŸŽ‰</li>
                        </ol>
                        <div style="margin-top: 15px; padding: 12px; background: #e8f5e9; border-radius: 6px; border-left: 4px solid #4caf50;">
                            <strong>ðŸ’¡ Tip:</strong> The script auto-runs when you click Run, so you don't need to call any function manually!
                        </div>
                        <div style="margin-top: 20px;">
                            <label style="font-weight: 600; display: block; margin-bottom: 10px; color: #250651;">Google Apps Script Code:</label>
                            <textarea id="gsheet-script-code" readonly style="width: 100%; height: 250px; padding: 15px; font-family: 'Courier New', monospace; font-size: 13px; border: 2px solid #ddd; border-radius: 8px; background-color: #fafafa; resize: vertical; line-height: 1.6;">${scriptCode}</textarea>
                            <div style="margin-top: 15px; display: flex; gap: 10px;">
                                <button onclick="copyGSheetScript()" style="padding: 12px 24px; background: linear-gradient(135deg, #5612BD 0%, #6b1dd4 100%); color: white; border: none; border-radius: 8px; font-weight: 600; cursor: pointer; box-shadow: 0 4px 12px rgba(86, 18, 189, 0.3); transition: all 0.3s ease;">ðŸ“‹ Copy Script</button>
                                <a href="${appsScriptUrl}" target="_blank" style="padding: 12px 24px; background: linear-gradient(135deg, #9250F2 0%, #a866ff 100%); color: white; text-decoration: none; border-radius: 8px; font-weight: 600; box-shadow: 0 4px 12px rgba(146, 80, 242, 0.3); display: inline-block;">ðŸš€ Open Apps Script</a>
                            </div>
                        </div>
                    </div>
                    
                    <div style="margin-bottom: 20px; padding: 20px; background: white; border-radius: 8px; border-left: 4px solid #9250F2;">
                        <h4 style="color: #5612BD; margin-bottom: 15px; font-size: 1.2rem;">ðŸ”– Method 2: Bookmarklet (Alternative)</h4>
                        <ol style="line-height: 2; margin-left: 20px; color: #333;">
                            <li>Drag the button below to your bookmarks bar</li>
                            <li>Open your Google Sheet in another tab</li>
                            <li>Click the bookmarklet in your bookmarks bar</li>
                            <li>Cells will be highlighted automatically!</li>
                        </ol>
                        <div style="margin-top: 15px;">
                            <a href="${bookmarkletCode}" id="bookmarklet-link" style="display: inline-block; padding: 12px 24px; background: linear-gradient(135deg, #5612BD 0%, #6b1dd4 100%); color: white; text-decoration: none; border-radius: 8px; font-weight: 600; cursor: move; box-shadow: 0 4px 12px rgba(86, 18, 189, 0.3);">ðŸ“Œ Highlight Blank Cells</a>
                            <p style="margin-top: 10px; font-size: 0.9em; color: #666;">ðŸ‘† Drag this button to your bookmarks bar</p>
                        </div>
                    </div>
                `;
                
                // Remove existing auto div if any
                const existingAuto = document.getElementById('automated-highlight-option');
                if (existingAuto) {
                    existingAuto.remove();
                }
                
                autoDiv.id = 'automated-highlight-option';
                blankSpaceResults.appendChild(autoDiv);
                
                // Auto-copy script to clipboard when instructions appear
                setTimeout(() => {
                    const textarea = document.getElementById('gsheet-script-code');
                    if (textarea && navigator.clipboard) {
                        navigator.clipboard.writeText(scriptCode).then(() => {
                            console.log('Script auto-copied to clipboard');
                        }).catch(() => {
                            console.log('Could not auto-copy');
                        });
                    }
                }, 500);
                
                const highlightBtn = document.getElementById('highlight-gsheet-btn');
                if (highlightBtn) {
                    highlightBtn.disabled = false;
                    highlightBtn.textContent = 'Highlight Cells in Google Sheet';
                }
            }

            function generateConsoleScript() {
                const sheetId = window.currentGSheetId;
                const gid = parseInt(window.currentGSheetGid);
                const cells = blankCells.map(cell => {
                    const colLetter = getColumnLetter(cell.col);
                    return { row: cell.row, col: colLetter, colIndex: cell.col };
                });

                return `// Paste this in browser console while on Google Sheets page
(function() {
    const cells = ${JSON.stringify(cells)};
    const gid = ${gid};
    
    // Find the sheet by gid
    const sheets = window.google?.visualization?.Query?.setResponse || 
                   document.querySelectorAll('[data-sheet-id]');
    
    // Use Google Sheets API if available
    if (window.gapi && window.gapi.client && window.gapi.client.sheets) {
        const requests = cells.map(cell => ({
            repeatCell: {
                range: {
                    sheetId: gid,
                    startRowIndex: cell.row - 1,
                    endRowIndex: cell.row,
                    startColumnIndex: cell.colIndex,
                    endColumnIndex: cell.colIndex + 1
                },
                cell: {
                    userEnteredFormat: {
                        backgroundColor: { red: 1, green: 1, blue: 0 }
                    }
                },
                fields: 'userEnteredFormat.backgroundColor'
            }
        }));
        
        window.gapi.client.sheets.spreadsheets.batchUpdate({
            spreadsheetId: '${sheetId}',
            resource: { requests: requests }
        }).then(() => {
            console.log('Cells highlighted!');
            alert('Successfully highlighted ' + cells.length + ' cells!');
        });
    } else {
        alert('Please install the bookmarklet method instead. Google Sheets API is not available in this context.');
    }
})();`;
            }

            window.copyConsoleScript = function() {
                const textarea = document.getElementById('console-script');
                if (textarea) {
                    textarea.select();
                    document.execCommand('copy');
                    const btn = event.target;
                    const originalText = btn.textContent;
                    btn.textContent = 'Copied!';
                    btn.style.backgroundColor = '#28a745';
                    setTimeout(() => {
                        btn.textContent = originalText;
                        btn.style.backgroundColor = '#28a745';
                    }, 2000);
                }
            };

            function showBookmarkletOption() {
                // Fallback: Show bookmarklet option
                const bookmarkletDiv = document.createElement('div');
                bookmarkletDiv.style.marginTop = '20px';
                bookmarkletDiv.style.padding = '20px';
                bookmarkletDiv.style.backgroundColor = '#fff3cd';
                bookmarkletDiv.style.borderRadius = '6px';
                bookmarkletDiv.style.border = '2px solid #ffc107';
                
                const bookmarkletCode = generateBookmarklet();
                
                bookmarkletDiv.innerHTML = `
                    <h3 style="margin-top: 0; color: #856404;">Automated Highlighting (Bookmarklet)</h3>
                    <p style="line-height: 1.8;">Since direct API access requires setup, use this bookmarklet:</p>
                    <ol style="line-height: 1.8;">
                        <li>Drag the button below to your bookmarks bar</li>
                        <li>Open your Google Sheet: <a href="${window.currentGSheetUrl || '#'}" target="_blank">${window.currentGSheetUrl || 'Your Sheet'}</a></li>
                        <li>Click the bookmarklet in your bookmarks bar</li>
                        <li>Cells will be highlighted automatically!</li>
                    </ol>
                    <div style="margin-top: 15px;">
                        <a href="${bookmarkletCode}" id="bookmarklet-link" style="display: inline-block; padding: 12px 24px; background-color: #ffc107; color: #000; text-decoration: none; border-radius: 4px; font-weight: 600; cursor: move;">ðŸ“Œ Highlight Blank Cells</a>
                        <p style="margin-top: 10px; font-size: 0.9em; color: #666;">Drag this button to your bookmarks bar</p>
                    </div>
                `;
                
                blankSpaceResults.appendChild(bookmarkletDiv);
                
                const highlightBtn = document.getElementById('highlight-gsheet-btn');
                if (highlightBtn) {
                    highlightBtn.disabled = false;
                    highlightBtn.textContent = 'Highlight Cells in Google Sheet';
                }
            }

            function generateBookmarklet() {
                const sheetId = window.currentGSheetId;
                const gid = parseInt(window.currentGSheetGid);
                const cells = blankCells.map(cell => {
                    const colLetter = getColumnLetter(cell.col);
                    return { row: cell.row, col: colLetter, colIndex: cell.col };
                });

                // Create a bookmarklet that works on Google Sheets page
                const script = `
                    (function(){
                        const sheetId='${sheetId}';
                        const gid=${gid};
                        const cells=${JSON.stringify(cells)};
                        
                        function highlightCells() {
                            // Try to get the spreadsheet object from Google Sheets page
                            if (window.google && window.google.visualization && window.google.visualization.Query) {
                                // Use the Google Sheets API if available
                                if (window.gapi && window.gapi.client && window.gapi.client.sheets) {
                                    const requests = cells.map(cell => ({
                                        repeatCell: {
                                            range: {
                                                sheetId: gid,
                                                startRowIndex: cell.row - 1,
                                                endRowIndex: cell.row,
                                                startColumnIndex: cell.colIndex,
                                                endColumnIndex: cell.colIndex + 1
                                            },
                                            cell: {
                                                userEnteredFormat: {
                                                    backgroundColor: { red: 1, green: 1, blue: 0 }
                                                }
                                            },
                                            fields: 'userEnteredFormat.backgroundColor'
                                        }
                                    }));
                                    
                                    window.gapi.client.sheets.spreadsheets.batchUpdate({
                                        spreadsheetId: sheetId,
                                        resource: { requests: requests }
                                    }).then(() => {
                                        alert('âœ“ Successfully highlighted ' + cells.length + ' blank cells!');
                                        setTimeout(() => location.reload(), 1000);
                                    }).catch(err => {
                                        console.error('API Error:', err);
                                        alert('Could not use API. Please use the Apps Script method from the instructions.');
                                    });
                                } else {
                                    // Try to load the API
                                    if (typeof gapi === 'undefined') {
                                        const script = document.createElement('script');
                                        script.src = 'https://apis.google.com/js/api.js';
                                        script.onload = function() {
                                            gapi.load('client:auth2', function() {
                                                gapi.client.init({
                                                    apiKey: '',
                                                    discoveryDocs: ['https://sheets.googleapis.com/$discovery/rest?version=v4'],
                                                    scope: 'https://www.googleapis.com/auth/spreadsheets'
                                                }).then(() => {
                                                    highlightCells();
                                                });
                                            });
                                        };
                                        document.head.appendChild(script);
                                    } else {
                                        alert('Google Sheets API not available. Please use the Apps Script method (Method 1) from the instructions.');
                                    }
                                }
                            } else {
                                alert('Please run this bookmarklet while on a Google Sheets page.');
                            }
                        }
                        
                        highlightCells();
                    })();
                `.replace(/\s+/g, ' ').trim();

                return `javascript:${encodeURIComponent(script)}`;
            }

            function generateGSheetHighlightScript(blankCells) {
                // Get the current sheet by gid
                const gid = window.currentGSheetGid || '0';
                
                // Create array of cell references
                const cellRefs = blankCells.map(cell => {
                    // Convert column name to column letter (A, B, C, etc.)
                    const colLetter = getColumnLetter(cell.col);
                    return `'${colLetter}${cell.row}'`;
                }).join(', ');
                
                return `function highlightBlankCells() {
  try {
    const sheetId = '${window.currentGSheetId}';
    const gid = ${gid};
    
    // Open the spreadsheet
    const spreadsheet = SpreadsheetApp.openById(sheetId);
    
    // Get the specific sheet by gid
    let targetSheet = null;
    const sheets = spreadsheet.getSheets();
    for (let i = 0; i < sheets.length; i++) {
      if (sheets[i].getSheetId() == gid) {
        targetSheet = sheets[i];
        break;
      }
    }
    
    // If sheet not found by gid, use active sheet
    if (!targetSheet) {
      targetSheet = spreadsheet.getActiveSheet();
      console.log('Sheet with gid ' + gid + ' not found, using active sheet: ' + targetSheet.getName());
    } else {
      console.log('Found target sheet: ' + targetSheet.getName());
    }
    
    // Cell references to highlight
    const cellsToHighlight = [${cellRefs}];
    let highlightedCount = 0;
    let errorCount = 0;
    
    // Highlight each cell in yellow
    cellsToHighlight.forEach(function(cellRef) {
      try {
        const range = targetSheet.getRange(cellRef);
        // Check if cell is actually blank
        const value = range.getValue();
        if (value === null || value === '' || value === undefined || (typeof value === 'string' && value.trim() === '')) {
          range.setBackground('#FFFF00'); // Yellow
          highlightedCount++;
        }
      } catch (e) {
        console.log('Error highlighting cell ' + cellRef + ': ' + e);
        errorCount++;
      }
    });
    
    const message = 'Successfully highlighted ' + highlightedCount + ' blank cells in yellow!' + 
                    (errorCount > 0 ? '\\n(' + errorCount + ' cells had errors)' : '');
    SpreadsheetApp.getUi().alert(message);
    console.log(message);
    
    // Return to the spreadsheet
    return highlightedCount;
  } catch (error) {
    const errorMsg = 'Error: ' + error.toString();
    SpreadsheetApp.getUi().alert(errorMsg);
    console.error(errorMsg);
    throw error;
  }
}

// Auto-run the function
highlightBlankCells();`;
            }

            function getColumnLetter(colIndex) {
                // Convert 0-based column index to Excel column letter (A, B, C, ..., Z, AA, AB, etc.)
                let result = '';
                colIndex++; // Convert to 1-based
                while (colIndex > 0) {
                    colIndex--;
                    result = String.fromCharCode(65 + (colIndex % 26)) + result;
                    colIndex = Math.floor(colIndex / 26);
                }
                return result;
            }

            // Global function for copy button
            window.openAppsScriptWithCode = function() {
                // Copy script to clipboard first
                const textarea = document.getElementById('gsheet-script-code');
                if (textarea) {
                    const text = textarea.value;
                    if (navigator.clipboard && navigator.clipboard.writeText) {
                        navigator.clipboard.writeText(text).then(() => {
                            // Open Apps Script editor
                            const sheetId = window.currentGSheetId;
                            const appsScriptUrl = `https://script.google.com/home/projects/create?folder=0&fileId=0`;
                            window.open(appsScriptUrl, '_blank');
                            
                            // Show success message
                            setTimeout(() => {
                                alert('âœ“ Script copied to clipboard!\n\nApps Script editor opened.\n\nNow:\n1. Paste the code (Ctrl+V / Cmd+V)\n2. Click Run (â–¶)\n3. Authorize when prompted');
                            }, 500);
                        });
                    } else {
                        // Fallback
                        textarea.select();
                        document.execCommand('copy');
                        const appsScriptUrl = `https://script.google.com/home/projects/create?folder=0&fileId=0`;
                        window.open(appsScriptUrl, '_blank');
                        alert('Script copied! Paste it in the Apps Script editor.');
                    }
                }
            };

            window.copyGSheetScript = function() {
                const textarea = document.getElementById('gsheet-script-code');
                if (textarea) {
                    const text = textarea.value;
                    
                    // Use modern Clipboard API if available
                    if (navigator.clipboard && navigator.clipboard.writeText) {
                        navigator.clipboard.writeText(text).then(() => {
                            showCopySuccess(event.target);
                        }).catch(() => {
                            // Fallback to old method
                            textarea.select();
                            document.execCommand('copy');
                            showCopySuccess(event.target);
                        });
                    } else {
                        // Fallback to old method
                        textarea.select();
                        document.execCommand('copy');
                        showCopySuccess(event.target);
                    }
                }
            };

            function showCopySuccess(btn) {
                const originalText = btn.textContent;
                const originalBg = btn.style.background;
                btn.textContent = 'âœ“ Copied!';
                btn.style.background = 'linear-gradient(135deg, #28a745 0%, #34ce57 100%)';
                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.style.background = originalBg;
                }, 2000);
            }

            // Model Names functionality
            const brandNamesButton = document.getElementById('brand-names-btn');
            const brandNamesValueInput = document.getElementById('brand-names-value');
            const brandNamesResults = document.getElementById('brand-names-results');
            const brandNamesLoading = document.getElementById('brand-names-loading-message');
            const brandNamesError = document.getElementById('brand-names-error-message');
            const brandNamesNoResults = document.getElementById('brand-names-no-results');
            const brandNamesResultsSection = document.getElementById('brand-names-results-section');

            function showBrandNamesError(message) {
                brandNamesError.textContent = message;
                brandNamesError.style.display = 'block';
                brandNamesLoading.style.display = 'none';
                brandNamesNoResults.style.display = 'none';
                brandNamesResultsSection.style.display = 'block';
            }

            function displayBrandNamesResults(data) {
                brandNamesError.style.display = 'none';
                brandNamesLoading.style.display = 'none';
                brandNamesResults.innerHTML = '';
                brandNamesNoResults.style.display = 'none';

                if (!data.ok) {
                    showBrandNamesError(data.error || 'An error occurred');
                    return;
                }
                
                // Debug logging
                console.log('Displaying results:', {
                    ok: data.ok,
                    count: data.count,
                    framesCount: data.frames?.length || 0,
                    hlMatchesCount: data.hlMatches?.length || 0,
                    brokenModelsCount: data.brokenModels?.length || 0
                });
                if (data.brokenModels && data.brokenModels.length > 0) {
                    console.log('Broken models data:', data.brokenModels);
                }

                // Display frames list
                if (data.frames && data.frames.length > 0) {
                    const framesDiv = document.createElement('div');
                    framesDiv.style.marginBottom = '30px';
                    framesDiv.innerHTML = '<h3 style="color: #250651; font-size: 1.2rem; margin-bottom: 15px;">Detected jvxBase_* Iframes</h3>';
                    
                    const framesTable = document.createElement('table');
                    framesTable.className = 'results-table';
                    framesTable.style.width = '100%';
                    framesTable.style.borderCollapse = 'collapse';
                    framesTable.style.backgroundColor = '#fff';
                    framesTable.style.borderRadius = '8px';
                    framesTable.style.overflow = 'hidden';
                    framesTable.style.boxShadow = '0 2px 4px rgba(0,0,0,0.1)';
                    framesTable.innerHTML = `
                        <thead>
                            <tr style="background-color: #5612BD; color: #fff;">
                                <th style="padding: 12px; text-align: left; font-weight: 600;">Iframe ID</th>
                                <th style="padding: 12px; text-align: left; font-weight: 600;">Source URL</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${data.frames.map(frame => `
                                <tr style="border-bottom: 1px solid #eee;">
                                    <td style="padding: 10px;">
                                        <strong style="color: #250651; font-family: monospace; font-size: 0.95rem;">${frame.id}</strong>
                                    </td>
                                    <td style="padding: 10px;">
                                        <span style="color: #666; font-size: 0.9rem; word-break: break-all;">${frame.src || 'N/A'}</span>
                                    </td>
                                </tr>
                            `).join('')}
                        </tbody>
                    `;
                    framesDiv.appendChild(framesTable);
                    brandNamesResults.appendChild(framesDiv);
                }

                // Display HL matches in separate tables (HL and SL)
                if (data.hlMatches && data.hlMatches.length > 0) {
                    // Helper function to format elements
                    const formatElements = (elements) => {
                        if (!elements || elements.length === 0) {
                            return '<span style="color: #dc3545; font-weight: 600;">âœ— No</span>';
                        }
                        return elements.map(el => `
                            <div style="margin-bottom: 8px; padding: 8px; background: #f8f9fa; border-radius: 4px;">
                                <div style="font-family: monospace; color: #5612BD; font-weight: 600; font-size: 0.9rem; margin-bottom: 4px;">${el.id}</div>
                                <div style="font-family: monospace; font-size: 0.75rem; color: #666; max-height: 60px; overflow-y: auto;">${escapeHtml(el.outerHTML || 'N/A')}</div>
                            </div>
                        `).join('');
                    };
                    
                    // Table 1: HL_* Elements
                    const hlMatchesDiv = document.createElement('div');
                    hlMatchesDiv.style.marginTop = '30px';
                    hlMatchesDiv.innerHTML = '<h3 style="color: #250651; font-size: 1.2rem; margin-bottom: 20px;">HL_* Elements</h3>';
                    
                    const hlTable = document.createElement('table');
                    hlTable.className = 'results-table';
                    hlTable.style.width = '100%';
                    hlTable.style.borderCollapse = 'collapse';
                    hlTable.style.backgroundColor = '#fff';
                    hlTable.style.borderRadius = '8px';
                    hlTable.style.overflow = 'hidden';
                    hlTable.style.boxShadow = '0 2px 4px rgba(0,0,0,0.1)';
                    hlTable.style.marginBottom = '30px';
                    
                    const hlThead = document.createElement('thead');
                    hlThead.style.backgroundColor = '#5612BD';
                    hlThead.style.color = '#fff';
                    hlThead.innerHTML = `
                        <tr>
                            <th style="padding: 12px; text-align: left; font-weight: 600;">Creative Variation</th>
                            <th style="padding: 12px; text-align: left; font-weight: 600;">frm1_HL_*</th>
                            <th style="padding: 12px; text-align: left; font-weight: 600;">frm2_HL_*</th>
                            <th style="padding: 12px; text-align: left; font-weight: 600;">frm3_HL_*</th>
                            <th style="padding: 12px; text-align: left; font-weight: 600;">frm4_HL_*</th>
                        </tr>
                    `;
                    
                    const hlTbody = document.createElement('tbody');
                    data.hlMatches.forEach(match => {
                        const row = document.createElement('tr');
                        row.style.borderBottom = '1px solid #eee';
                        row.innerHTML = `
                            <td style="padding: 10px;">
                                <strong style="color: #250651; font-size: 0.95rem;">${match.creativeVariation || 'N/A'}</strong>
                            </td>
                            <td style="padding: 10px; vertical-align: top;">
                                ${formatElements(match.matches)}
                            </td>
                            <td style="padding: 10px; vertical-align: top;">
                                ${formatElements(match.matches2)}
                            </td>
                            <td style="padding: 10px; vertical-align: top;">
                                ${formatElements(match.matches3)}
                            </td>
                            <td style="padding: 10px; vertical-align: top;">
                                ${formatElements(match.matches4)}
                            </td>
                        `;
                        hlTbody.appendChild(row);
                    });
                    
                    hlTable.appendChild(hlThead);
                    hlTable.appendChild(hlTbody);
                    hlMatchesDiv.appendChild(hlTable);
                    brandNamesResults.appendChild(hlMatchesDiv);
                    
                    // Table 2: SL_* Elements
                    const slMatchesDiv = document.createElement('div');
                    slMatchesDiv.style.marginTop = '30px';
                    slMatchesDiv.innerHTML = '<h3 style="color: #250651; font-size: 1.2rem; margin-bottom: 20px;">SL_* Elements</h3>';
                    
                    const slTable = document.createElement('table');
                    slTable.className = 'results-table';
                    slTable.style.width = '100%';
                    slTable.style.borderCollapse = 'collapse';
                    slTable.style.backgroundColor = '#fff';
                    slTable.style.borderRadius = '8px';
                    slTable.style.overflow = 'hidden';
                    slTable.style.boxShadow = '0 2px 4px rgba(0,0,0,0.1)';
                    
                    const slThead = document.createElement('thead');
                    slThead.style.backgroundColor = '#5612BD';
                    slThead.style.color = '#fff';
                    slThead.innerHTML = `
                        <tr>
                            <th style="padding: 12px; text-align: left; font-weight: 600;">Creative Variation</th>
                            <th style="padding: 12px; text-align: left; font-weight: 600;">frm1_SL_*</th>
                            <th style="padding: 12px; text-align: left; font-weight: 600;">frm2_SL_*</th>
                            <th style="padding: 12px; text-align: left; font-weight: 600;">frm3_SL_*</th>
                            <th style="padding: 12px; text-align: left; font-weight: 600;">frm4_SL_*</th>
                        </tr>
                    `;
                    
                    const slTbody = document.createElement('tbody');
                    data.hlMatches.forEach(match => {
                        const row = document.createElement('tr');
                        row.style.borderBottom = '1px solid #eee';
                        row.innerHTML = `
                            <td style="padding: 10px;">
                                <strong style="color: #250651; font-size: 0.95rem;">${match.creativeVariation || 'N/A'}</strong>
                            </td>
                            <td style="padding: 10px; vertical-align: top;">
                                ${formatElements(match.matchesSL1)}
                            </td>
                            <td style="padding: 10px; vertical-align: top;">
                                ${formatElements(match.matchesSL2)}
                            </td>
                            <td style="padding: 10px; vertical-align: top;">
                                ${formatElements(match.matchesSL3)}
                            </td>
                            <td style="padding: 10px; vertical-align: top;">
                                ${formatElements(match.matchesSL4)}
                            </td>
                        `;
                        slTbody.appendChild(row);
                    });
                    
                    slTable.appendChild(slThead);
                    slTable.appendChild(slTbody);
                    slMatchesDiv.appendChild(slTable);
                    brandNamesResults.appendChild(slMatchesDiv);
                } else {
                    brandNamesNoResults.style.display = 'block';
                }

                // Display model names status table (always show to indicate status of all found models)
                const brokenModelsDiv = document.createElement('div');
                brokenModelsDiv.style.marginTop = '30px';
                
                // Show comprehensive model statuses table
                if (data.allModelStatuses && data.allModelStatuses.length > 0) {
                    brokenModelsDiv.innerHTML = '<h3 style="color: #250651; font-size: 1.2rem; margin-bottom: 20px;">ðŸ“Š Model Names Status</h3>';
                    
                    const statusTable = document.createElement('table');
                    statusTable.className = 'results-table';
                    statusTable.style.width = '100%';
                    statusTable.style.borderCollapse = 'collapse';
                    statusTable.style.backgroundColor = '#fff';
                    statusTable.style.borderRadius = '8px';
                    statusTable.style.overflow = 'hidden';
                    statusTable.style.boxShadow = '0 2px 4px rgba(0,0,0,0.1)';
                    statusTable.style.marginBottom = '30px';
                    
                    const statusThead = document.createElement('thead');
                    statusThead.style.backgroundColor = '#5612BD';
                    statusThead.style.color = '#fff';
                    statusThead.innerHTML = `
                        <tr>
                            <th style="padding: 12px; text-align: left; font-weight: 600;">Creative Variation</th>
                            <th style="padding: 12px; text-align: left; font-weight: 600;">Element ID</th>
                            <th style="padding: 12px; text-align: left; font-weight: 600;">Type</th>
                            <th style="padding: 12px; text-align: left; font-weight: 600;">Model Name</th>
                            <th style="padding: 12px; text-align: left; font-weight: 600;">Status</th>
                        </tr>
                    `;
                    
                    const statusTbody = document.createElement('tbody');
                    data.allModelStatuses.forEach(item => {
                        item.modelStatuses.forEach(modelStatus => {
                            const row = document.createElement('tr');
                            row.style.borderBottom = '1px solid #eee';
                            const statusColor = modelStatus.singleLine ? '#28a745' : '#dc3545';
                            const statusText = modelStatus.singleLine ? 'âœ“ Single Line' : `âš ï¸ ${modelStatus.rectsCount} Lines`;
                            row.innerHTML = `
                                <td style="padding: 10px;">
                                    <strong style="color: #250651; font-size: 0.95rem;">${escapeHtml(item.creativeVariation)}</strong>
                                </td>
                                <td style="padding: 10px;">
                                    <code style="color: #5612BD; font-size: 0.9rem;">${escapeHtml(item.elementId)}</code>
                                </td>
                                <td style="padding: 10px;">
                                    <span style="padding: 4px 8px; background: ${item.elementType === 'HL' ? '#d4edda' : '#cce5ff'}; color: ${item.elementType === 'HL' ? '#155724' : '#004085'}; border-radius: 4px; font-weight: 600;">${item.elementType}</span>
                                </td>
                                <td style="padding: 10px;">
                                    <strong style="color: #250651;">${escapeHtml(modelStatus.model)}</strong>
                                </td>
                                <td style="padding: 10px;">
                                    <span style="color: ${statusColor}; font-weight: 600;">${statusText}</span>
                                </td>
                            `;
                            statusTbody.appendChild(row);
                        });
                    });
                    
                    statusTable.appendChild(statusThead);
                    statusTable.appendChild(statusTbody);
                    brokenModelsDiv.appendChild(statusTable);
                }
                
                // Display broken models table (if any)
                if (data.brokenModels && data.brokenModels.length > 0) {
                    const brokenHeader = document.createElement('h3');
                    brokenHeader.style.cssText = 'color: #dc3545; font-size: 1.2rem; margin-bottom: 20px; margin-top: 20px;';
                    brokenHeader.textContent = 'âš ï¸ Broken Model Names (Split Across Lines)';
                    brokenModelsDiv.appendChild(brokenHeader);
                    
                    const brokenTable = document.createElement('table');
                    brokenTable.className = 'results-table';
                    brokenTable.style.width = '100%';
                    brokenTable.style.borderCollapse = 'collapse';
                    brokenTable.style.backgroundColor = '#fff';
                    brokenTable.style.borderRadius = '8px';
                    brokenTable.style.overflow = 'hidden';
                    brokenTable.style.boxShadow = '0 2px 4px rgba(0,0,0,0.1)';
                    brokenTable.style.border = '2px solid #dc3545';
                    
                    const brokenThead = document.createElement('thead');
                    brokenThead.style.backgroundColor = '#dc3545';
                    brokenThead.style.color = '#fff';
                    brokenThead.innerHTML = `
                        <tr>
                            <th style="padding: 12px; text-align: left; font-weight: 600;">Creative Variation</th>
                            <th style="padding: 12px; text-align: left; font-weight: 600;">Element ID</th>
                            <th style="padding: 12px; text-align: left; font-weight: 600;">Type</th>
                            <th style="padding: 12px; text-align: left; font-weight: 600;">Broken Model(s)</th>
                            <th style="padding: 12px; text-align: left; font-weight: 600;">Lines</th>
                            <th style="padding: 12px; text-align: left; font-weight: 600;">HTML Preview</th>
                        </tr>
                    `;
                    
                    const brokenTbody = document.createElement('tbody');
                    data.brokenModels.forEach(item => {
                        const row = document.createElement('tr');
                        row.style.borderBottom = '1px solid #eee';
                        const brokenModelsList = item.brokenModels.map(bm => 
                            `<span style="display: inline-block; margin: 2px 4px; padding: 4px 8px; background: #fff3cd; border: 1px solid #ffc107; border-radius: 4px; font-weight: 600;">${escapeHtml(bm.model)}</span>`
                        ).join('');
                        row.innerHTML = `
                            <td style="padding: 10px;">
                                <strong style="color: #250651; font-size: 0.95rem;">${escapeHtml(item.creativeVariation)}</strong>
                            </td>
                            <td style="padding: 10px;">
                                <code style="color: #5612BD; font-size: 0.9rem;">${escapeHtml(item.elementId)}</code>
                            </td>
                            <td style="padding: 10px;">
                                <span style="padding: 4px 8px; background: ${item.elementType === 'HL' ? '#d4edda' : '#cce5ff'}; color: ${item.elementType === 'HL' ? '#155724' : '#004085'}; border-radius: 4px; font-weight: 600;">${item.elementType}</span>
                            </td>
                            <td style="padding: 10px;">
                                ${brokenModelsList}
                            </td>
                            <td style="padding: 10px;">
                                <span style="color: #dc3545; font-weight: 600;">${item.brokenModels[0].rectsCount} line(s)</span>
                            </td>
                            <td style="padding: 10px;">
                                <div style="font-family: monospace; font-size: 0.75rem; color: #666; max-height: 60px; overflow-y: auto; max-width: 300px;">${escapeHtml(item.outerHTML)}</div>
                            </td>
                        `;
                        brokenTbody.appendChild(row);
                    });
                    
                    brokenTable.appendChild(brokenThead);
                    brokenTable.appendChild(brokenTbody);
                    brokenModelsDiv.appendChild(brokenTable);
                } else {
                    // Show message when no broken models found
                    brokenModelsDiv.innerHTML = `
                        <h3 style="color: #28a745; font-size: 1.2rem; margin-bottom: 20px;">âœ… Model Names Status</h3>
                        <div style="padding: 20px; background: #d4edda; border: 1px solid #c3e6cb; border-radius: 8px; color: #155724;">
                            <strong>âœ“ All model names are on single lines</strong>
                            <p style="margin: 10px 0 0 0; font-size: 0.9rem;">No Mazda model names were found split across multiple lines. All detected model names (MAZDA CX-60, MAZDA CX-30, MAZDA CX-5, etc.) are displayed on single lines.</p>
                        </div>
                    `;
                }
                brandNamesResults.appendChild(brokenModelsDiv);

                brandNamesResultsSection.style.display = 'block';
            }

            function escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }

            if (brandNamesButton) {
                brandNamesButton.addEventListener('click', async function() {
                    const url = brandNamesValueInput.value.trim();
                    
                    if (!url) {
                        showBrandNamesError('Please enter a URL');
                        return;
                    }

                    // Validate URL format
                    try {
                        new URL(url);
                    } catch (e) {
                        showBrandNamesError('Please enter a valid URL');
                        return;
                    }

                    // Show loading state
                    brandNamesButton.disabled = true;
                    brandNamesButton.textContent = 'Analyzing...';
                    brandNamesLoading.style.display = 'block';
                    brandNamesError.style.display = 'none';
                    brandNamesNoResults.style.display = 'none';
                    brandNamesResults.innerHTML = '';
                    brandNamesResultsSection.style.display = 'block';

                    try {
                        const response = await fetch(`/api/count?url=${encodeURIComponent(url)}`);
                        const data = await response.json();

                        if (!response.ok) {
                            showBrandNamesError(data.error || 'Failed to analyze URL');
                            return;
                        }

                        displayBrandNamesResults(data);
                    } catch (error) {
                        showBrandNamesError(error.message || 'An error occurred while analyzing the URL');
                    } finally {
                        brandNamesButton.disabled = false;
                        brandNamesButton.textContent = 'Analyze';
                        brandNamesLoading.style.display = 'none';
                    }
                });

                // Allow Enter key to trigger analysis
                if (brandNamesValueInput) {
                    brandNamesValueInput.addEventListener('keypress', function(e) {
                        if (e.key === 'Enter') {
                            brandNamesButton.click();
                        }
                    });
                }
            }
        });
    </script>
</body>
</html>

